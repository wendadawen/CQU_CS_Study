# 排序算法

**例题：[912. 排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-an-array/)**

## 排序算法对比

![20200626164737833](初学上课笔记.assets\20200626164737833.png)

## 插入排序（Insertion Sort）

```c++
for(int i=1;i<n;i++)
    for(int j=i;(j>=1)&&(arr[j-1]>arr[j]);j--) swap(arr[j],arr[j-1]);
```

## 冒泡排序(Bubble Sort)

```c++
for(int i=0;i<n-1;i++){
    bool flag = false;
    for(int j=n-1;j>i;j--){
        if(arr[j-1]>arr[j]){
            swap(arr,j,j-1);
            flag = true;
        }
    }
    if(flag == false) break;
}
```

### Bubble Sort Improving one

![7E5F92CC-5767-4212-AC9D-1A01A40951CD](初学上课笔记.assets\7E5F92CC-5767-4212-AC9D-1A01A40951CD.PNG)

### Bubble Sort Improving two

![0C30F4F3-D544-43CC-8C4E-1D6F9A190C9A](初学上课笔记.assets\0C30F4F3-D544-43CC-8C4E-1D6F9A190C9A.PNG)

## 选择排序(Selection Sort)

```c++
for(int i=0;i<n-1;i++){
	int min_index = i;
    for(int j=n-1;j>i;j--){
        if(arr[min_index]>arr[j]) min_index = j;
    }
    swap(arr,i,min_index);
}
```

### Recursive Function

```c++
void Rec(int arr[],int n){  // Recursive Function (Selection Sort)
    if(n <= 1){
        return ;
    }
    int max_pos = 0;
    for(int i=0;i<n;i++){
        if(arr[max_pos]<arr[i]){
            max_pos = i;
        }
    }
    swap(arr,n-1,max_pos);
    Rec(arr, n-1);
}
```



## Mad Sort

```c++
for(int i=0;i<n;i++){
    for(int j=0;j<n;j++){
        if(arr[i]<arr[j]) swap(arr,i,j);  // 顺序
    }
}
```



## 合并排序（MergeSort）

**时间复杂度：nlogn**

```c++
void Merge(int arr[],int low,int mid,int high){
    int i=low,j=mid+1,k=0; 
    int *temp=new int[high-low+1]; 
    
    while(i<=mid&&j<=high){
        if(arr[i]<=arr[j]) 
            temp[k++]=arr[i++];
        else
            temp[k++]=arr[j++];
    }
    while(i<=mid)
        temp[k++]=arr[i++];
    while(j<=high)
        temp[k++]=arr[j++];
    for(i=low,k=0;i<=high;i++,k++)
		arr[i]=temp[k];
    delete []temp;
}
 

void MergeSort(int arr[],int low,int high){
    if(low<high){
        int mid=(low+high)/2;
        MergeSort(arr,low,mid);
        MergeSort(arr,mid+1,high);
        Merge(arr,low,mid,high);
    }
}
```

```c++
int * Merge(int arr1[],int arr2[],int n1,int n2){
    int * newArr = new int[n1+n2];
    int index = 0,i =0,j=0;
    while((i<n1)&&(j<n2)){
        if(arr1[i]<arr2[j]){
            newArr[index++] = arr1[i++];
        }
        else{
            newArr[index++] = arr2[j++];
        }
    }
    while(i<n1){
        newArr[index++] = arr1[i++];
    }
    while(j<n2){
        newArr[index++] = arr2[j++];
    }
    return newArr;
}
int* MergeSort(int arr[],int n){
    if(n<=1){
        return arr;
    }
    int * leftPart = new int[n/2];
    int * rightPart = new int[n/2+n%2];
    for(int i=0;i<n/2;i++){
        leftPart[i] =arr[i]; 
    }
    int index = 0;
    for(int i=n/2;i<n;i++){
        rightPart[index++] = arr[i];
    }
    return Merge(MergeSort(leftPart,n/2),MergeSort(rightPart,n/2+n%2),n/2,n/2+n%2);
}
```



## 快速排序(QuickSort)

**最坏时间复杂度cnlogn，只不过c很大，有算法能够线性时间找到中间基准值（quickSearch）**

![屏幕截图 2022-09-14 215954](初学上课笔记.assets\屏幕截图 2022-09-14 215954.png)

```c++
int partition(int arr[],int begin,int end){
    int pivot=arr[end];
    int i=begin-1;
    for(int j=begin;j<end;j++){
        if(arr[j]<=pivot){
            i+=1;
            swap(arr,i,j);
        }
    }
    swap(arr,i+1,end);  // i在LeftPart的最后一个
    return i+1;

}
void quickSort(int arr[],int begin,int end){
    if(begin<end){
        int index_pivot = partition(arr,begin,end);
        quickSort(arr,begin,index_pivot-1);
        quickSort(arr,index_pivot+1,end);
    }

}
```

![屏幕截图 2022-09-14 220053](初学上课笔记.assets\屏幕截图 2022-09-14 220053.png)

```c++
int partition(int arr[],int begin,int end){
    int pivot=arr[end];
    int l=begin-1,r=end;
    while(l<r){
        while(arr[++l]<pivot){}  // 不能<=
        while((l<r)&&(arr[--r]>pivot)){}
        swap(arr,l,r);
    }
    swap(arr,l,end);  // l在RightPart的第一个
    return l;
}
void quickSort(int arr[],int begin,int end){
    if(begin<end){
        int index_pivot = partition(arr,begin,end);
        quickSort(arr,begin,index_pivot-1);
        quickSort(arr,index_pivot+1,end);
    }

}
```

#### QuickSort Opt "Meian of Three"(三数取中)

```c++
int Median(int arr[],int a,int b,int c){
    if(arr[a]<arr[b]){
        if(arr[b]<arr[c]){
            return b;
        }
        else if(arr[a]<arr[c]){
            return c;
        }
        else{
            return a;
        }
    }
    else if(arr[b]>arr[c]){
        return b;
    }
    else if(arr[a]>arr[c]){
        return c;
    }
    else {
        return a;
    }

}  // return a>b? (b>c? b:(a>c? c:a)):(a>c? a:(b>c?c:b));
int partition(int arr[],int begin,int end){
    swap(arr,end,Median(arr,begin,(begin+end)/2,end));  // 交换到end位置
    int pivot=arr[end];
    int l=begin-1,r=end;
    while(l<r){
        while(arr[++l]<pivot){}
        while((l<r)&&(arr[--r]>pivot)){}
        swap(arr,l,r);
    }
    swap(arr,l,end);
    return l;
}
void quickSort(int arr[],int begin,int end){
    if(begin<end){
        int index_pivot = partition(arr,begin,end);
        quickSort(arr,begin,index_pivot-1);
        quickSort(arr,index_pivot+1,end);
    }

}
```

#### 三路快速排序 (Split-end partition) 

```c++
int partition(int arr[],int begin,int end){
    int pivot=arr[end];
    int i=begin-1;
    int h = begin-1;
    for(int j=begin;j<end;j++){
        if(arr[j]<=pivot){
            h++;
            swap(arr,h,j);
            if(arr[h]<pivot){
                i++;
                swap(arr,i,h);
            }
        }
    }
    swap(arr,h+1,end);  // i在LeftPart的最后一个
    return h+1;

}
void quickSort(int arr[],int begin,int end){
    if(begin<end){
        int h = partition(arr,begin,end);
        quickSort(arr,h+1,end);
        while((h>0)&&(arr[h-1] == arr[h])){
            h--;
        }
        quickSort(arr,begin,h-1);
    }

}

```





## 希尔排序（ShellSort）

**效率高的间隔gap:**1，3，5，7，......，2^k-1

```c++
void ShellSort(int *arr,int n){
    for(int gap=n/2;gap>0;gap/=2)  // 取间隔
        for(int p=0;p<gap;p++)  // 对每个间隔进行一次插入排序
            for(int i=p;i<n;i+=gap)  // 插入排序
                for(int j=i;(j>=gap)&&(arr[j-gap]>arr[j]);j-=gap) swap(arr[j-gap],arr[j]);
}
```



## 计数排序（Counting Sort）

**时间复杂度：n+m**

```c++
#include <bits/stdc++.h>

using ll = long long ;

int main(){
	int n = 0 ; 
	std::cin >> n ;
	
	std::vector<int> a(n + 1) ;
	for(int i=1;i<=n;++i) std::cin >> a[i] ;

	std::vector<int> b(n + 1) , c(1001) ;
	for(int i=1;i<=n;++i) c[a[i]] ++ ;
	for(int i=1;i<=1000;++i) c[i] += c[i-1] ;
	for(int i=n;i>=1;--i) b[c[a[i]]--] = a[i] ;
	a = b ;

	for(int i=1;i<=n;++i) std::cout << a[i] << " " ;
	
	return 0 ;
}
```



## 基数排序（Radix Sort）

**时间复杂度：n**

```c++
void countSort(int* a,int n,int* b,int shift){
    int* c = new int[256]{0};
    for(int i=0;i<n;i++){
        int val = a[i];
        c[(val >> shift)&0xFF]++;  // (val>>8)&0xFF右移八位对256取余
    }
    for(int i=1;i<256;i++) 
        c[i] += c[i-1];
    for(int i=n-1;i>=0;i--){ // 必须倒序遍历，否则不对，因为为了维持稳定性
        int val = a[i];
        b[--c[(val>>shift)&0xFF]] = a[i];
    }
    delete[] c;
}
// 基于计数排序实现的基数排序
void RadixSort(int* a,int n){
    int* b = new int[n]{0};
    int cnt = sizeof(int);  // 4个字节
    // 以256为基，则需要每次取元素的8bit进行计数排序，从低位到高位
	// bit为一个字节，则元素大小有多少个字节就需要进行多少次计数排序
    for(int i=0;i<cnt;i++){
        if(i%2 == 0) countSort(a,n,b,i<<3);
        else countSort(b,n,a,i<<3);
    }
    delete[] b;
}
```



## 桶排序（Bucket Sort）

**时间复杂度：n**

```c++
#include <iostream>
#include <vector>
#include <ctime>
using namespace std;
const int BUCKET_NUM = 10;
struct ListNode{
	int val;
	ListNode* next;
	ListNode(int _val=0):val(_val),next(NULL){}
};
void insert(ListNode* head,int val){
	auto i=head;
	for(i=head;(i->next!=NULL)&&(i->next->val <= val);i = i->next){}
	ListNode* node = new ListNode(val);
	node->next = i->next;
	i->next = node;
}
ListNode* Merge(ListNode* head1,ListNode* head2){
	auto i=head1;
	for(i=head1;i->next!=NULL;i=i->next){};
	i->next = head2->next;
	return head1;
}
void BucketSort(int *arr,int n){
	vector<ListNode*> buckets(BUCKET_NUM,NULL);
	for(int i=0;i<BUCKET_NUM;++i) buckets[i] = new ListNode(0);
	for(int i=0;i<n;++i){
		int index = arr[i]/100;
		insert(buckets[index],arr[i]);
	}
	ListNode* head = buckets[0];
	for(int i=1;i<BUCKET_NUM;++i){
		head = Merge(head,buckets[i]);
	}
	int k=0;
	for(ListNode* i=head->next;i!=NULL;i=i->next){
		arr[k++] = i->val;
	}
}
void print(int *a,int n){
    for(int i=0;i<n;i++){
        cout<<a[i]<<" ";
    }
    cout<<endl;
}
int main(){
    srand((unsigned)time(NULL));
    int *a = new int[100000]{0};
    for(int i=0;i<100000;i++) a[i] = rand()%1000;
    BucketSort(a,100000);
    print(a,100000);
    system("pause");
    return 0;
}
```



## 例题

**[912. 排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-an-array/submissions/)**

```c++
class Solution {
public:
    // 插入排序
    void insertionSort(vector<int>& nums){
       for(int i=1;i<nums.size();++i){
           for(int j=i;j>=1 && nums[j-1] > nums[j];--j){
               swap(nums[j-1],nums[j]);
           }
       } 
    }
    // 希尔排序
    void shallSort(vector<int>& nums){
        int n = nums.size();
        for(int gap=n/2;gap>0;gap/=2){
            for(int p=0;p<gap;++p){
                for(int i=p;i<n;i+=gap){
                    for(int j=i;j>=gap&&nums[j-gap] > nums[j];j-=gap){
                        swap(nums[j-gap],nums[j]);
                    }
                }
            }
        }
    }
    // 选择排序
    void selectSort(vector<int>& nums){
        int n = nums.size();
        for(int i=0;i<n;++i){
            int minIdx = i;
            for(int j=i;j<n;++j){
                if(nums[minIdx] > nums[j]) minIdx = j;
            }
            swap(nums[minIdx],nums[i]);
        }
    }
    // 冒泡排序
    void bubbleSort(vector<int>& nums){
        int n = nums.size();
        for(int i=0;i<n;++i){
            for(int j=n-1;j>=i+1;--j){
                if(nums[j-1] > nums[j]) swap(nums[j-1],nums[j]);
            }
        }
    }
    // 快速排序
    void quickSort(vector<int>& nums){
        auto midThree = [&](int a,int b,int c){
            return a>b? (b>c? b:(a>c? c:a)):(a>c? a:(b>c?c:b));
        };
        auto partition = [&](int l,int r)->int{
            swap(nums[r],nums[midThree(l,r,(l+r)/2)]);
            int i = l-1;  // 表示小于基准值的最有一个的下标
            int j = l;  // 表示大于等于基准值的第一个的下标
            int p = nums[r];  // 基准值
            for(j=l;j<r;++j){
                if(p > nums[j]){
                    ++i;
                    swap(nums[i],nums[j]);
                }
            }
            swap(nums[r],nums[i+1]);
            return i+1;
        };
        function<void(int,int)> helper = [&](int l,int r){
            if(l>=r) return; 
            int mid = partition(l,r);
            helper(l,mid-1);
            helper(mid+1,r);
        };
        helper(0,nums.size()-1);
    }
    // 合并排序
    void mergeSort(vector<int>& nums){
        auto merge = [&](int l,int m,int r){
            vector<int> t(r-l+1);
            int i = l,j = m+1,tot = 0;
            while(i<=m && j<=r){
                if(nums[i] > nums[j]){
                    t[tot++] = nums[j++];
                }else{ 
                    t[tot++] = nums[i++];
                }
            }
            while(i<=m){
                t[tot++] = nums[i++];
            }
            while(j<=r){
                t[tot++] = nums[j++];
            }
            tot = 0,i = l;
            while(i <= r)
                nums[i++] = t[tot++];
        };
        function<void(int,int)> helper = [&](int l,int r){
            if(l>=r) return;
            int m = (l+r)/2;
            helper(l,m);
            helper(m+1,r);
            merge(l,m,r);
        };
        helper(0,nums.size()-1);
    }
    // 堆排序 
    
    void heapSort(vector<int>& nums){
        #define lc ((x<<1)+1)
        #define rc ((x<<1)+2)
        int tail=nums.size()-1;
        auto down = [&](int x){
            while(lc<=tail){
                if(rc<=tail && nums[rc] >= nums[lc] && nums[rc] > nums[x]){
                    swap(nums[rc],nums[x]); x = rc;
                }else if(rc <= tail && nums[lc] >= nums[rc] && nums[lc] > nums[x]){
                    swap(nums[lc],nums[x]); x = lc;
                }else if(nums[lc] > nums[x] && rc > tail){
                    swap(nums[lc],nums[x]); x = lc;
                }else break;
            }
        };
        auto pop = [&](){
            swap(nums[0],nums[tail]);tail--;
            down(0);
        };
        for(int i=nums.size()/2-1;i>=0;--i) down(i);
        for(int i=0;i<nums.size();++i) pop();
    }
    // 计数排序
    void countSort(vector<int>& a){
        vector<int> b(a.size());
        int Max = *max_element(a.begin(),a.end());
        int Min = *min_element(a.begin(),a.end());
        int c[max(Max-Min+1,Max+Min+1)];
        memset(c,0,sizeof(c));
        for(int i=0;i<a.size();++i){
            c[a[i]-Min]++;
        }
        for(int i=1;i<=max(Max-Min,Max+Min);++i){
            c[i] += c[i-1];
        }
        for(int i=a.size()-1;i>=0;--i){  // 倒序维持稳定性
            b[--c[a[i]-Min]] = a[i];
        }
        a = b;
    }
    // 基数排序
    void raidxSort(vector<int>& a){
        int Min = *min_element(a.begin(),a.end());
        for(int i=0;i<a.size();++i){  // 处理负数
            a[i] -= Min;
        }
        vector<int> b(a.size());
        int cnt = sizeof(int);
        auto helper = [](vector<int>& at,vector<int>& bt,int shift){
            int c[256];
            memset(c,0,sizeof(c));
            for(int i=0;i<at.size();++i){
                int v = (at[i]>>shift)&0xff;
                c[v]++;
            }
            for(int i=1;i<256;++i){
                c[i] += c[i-1];
            }
            for(int i=at.size()-1;i>=0;--i){
                int v = (at[i]>>shift)&0xff;
                bt[--c[v]] = at[i];
            }
        };
        for(int i=0;i<cnt;++i){
            if(i&1) helper(b,a,i<<3); 
            else  helper(a,b,i<<3);
        }
        for(int i=0;i<a.size();++i){  // 处理负数
            a[i] += Min;
        }
    }
};
```



# 查找算法

## 顺序搜索(Sequential Search）

**例题：**查找数组A[1....n]中的最大值和最小值，比较次数不超过1.5n。

```c++
int arr[] = {0,1,2,3,4,5,6,7,8,9};
void maxMinValue(int *arr,int n,int& maxp.int& minp){
    if(n==1){maxp=0;minp=0};  // 特殊情况特殊考虑
	for(int k=n&1;k<n;k+=2){  // 小技巧：n为奇数从1开始,偶数从0开始
        if(arr[k]<arr[k+1]){
            if(arr[maxp]<arr[k+1]) maxp=k+1；
            if(arr[minp]>arr[k]) minp=k;
        }else{
            if(arr[maxp]<arr[k]) maxp=k;
            if(arr[minp]>arr[k+1]) minp=k+1;
        }
    }
    
}

```



**例题：**寻找2~N的素数

```c++
// 筛选法
void prime(int n){
    bool a[n+1];
    memset(a,1,sizeof(a));
    for(int i=2;i<=n;++i){
        if(a[i]==false) continue;
        p.push_back(i);
        for(int j=i+i;j<=n;j+=i) a[j] = false;
    }
}


// 快速线性筛选法
void prime(int n){
    bool a[n+1];
    memset(a,1,sizeof(a));
    for(int i=2;i<=n;++i){
        if(a[i]==true) p.push_back(i);
        for(int j=0;j<p.size();++j){
            if(p[j]*i > n) break;
            a[p[j]*i] = false;
            if(i%p[j]==0) break;
        }
    }
}
```



## 二分查找（Binary Search）

```c++
int binSearch_1(vector<int>& nums,int k){
    int n = nums.size();
    int l = -1;  // 小于k的最后一个
    int r = n;  // 大于k的最后一个
    while(l+1 != r){
        int m = l+r>>1;
        if(k == nums[m]) return m;
        else if(k > nums[m]) l = m;
        else if(k < nums[m]) r = m;
    }
    return n;
}

```

```c++
int binSearch_2(vector<int>& nums,int k){
    int n = nums.size();
    int l = 0;  // 小于等于k的最后一个
    int r = n-1;  // 大于等于k的最后一个
    while(l <= r){
        int m = l+r>>1;
        if(k == nums[m]) return m;
        else if(k > nums[m]) l = m+1;
        else if(k < nums[m]) r = m-1;
    }
    return n;
}
```



**例题：**查找把一个范围内的值如[a,b)

```c++
int p1=0,p2=0;
void findRange_binary(int *arr,int n,int a,int b){
    int left=-1;
    int right=n;
    while(left+1 != right){
        int mid=(right+left)/2;
        if(arr[mid]<a) left = mid;
        else right = mid;
    }
    p1=right;
    
    left=-1;right=n;
    while(left+1 != right){
        int mid=(right+left)/2;
        if(arr[mid]>=b) right = mid;
        else left = mid;
    }
    p2=left;
}
```



**例题：**快速求幂a^n   (二分递归)

```c++
int pow(int a,int n){
    if(n==0) return 1;
    if(n==1) return a;
    return (n&1?a:1)*pow(a,n/2)*pow(a,n/2);
}
```



**例题：**山峰数组二分法

```c++
int func(int *arr,int n){
    int left=-1;
    int right=n;
    while(left+1 != right){
        int mid=(right+left)/2;
        if(arr[mid-1]<arr[mid] && arr[mid]>arr[mid+1]){
            return mid;
        }
        if(mid == n-1) return mid;  // 升序的特殊情况
        if(arr[mid-1]>arr[mid]) right = mid;
        else left = mid;
    }
    return n;  // 没有找到
}
```



## QuickSearch（找到排位k的元素）

**时间复杂度：n**

**例题：[P1923 【深基9.例4】求第 k 小的数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1923)**

```c++
#include <bits/stdc++.h>
using namespace std ; 
const int N = 5e6 + 10 ;
int n , nums[N] , k ;
int helper(int* nums,int l,int r){
    int i = l - 1 , p = nums[r] ;
    for(int j=l;j<r;++j) if(nums[j] <= p) swap(nums[++i],nums[j]) ;
    swap(nums[++i],nums[r]) ; return i ;
}
int quicksearch(int* nums,int l,int r,int k){
    if(l == r) return nums[l] ;
    int m = helper(nums,l,r) ; 
    if(m == k) return nums[m] ; 
    else if(m > k) return quicksearch(nums,l,m-1,k) ;
    else return quicksearch(nums,m+1,r,k);
    return -1 ;
}
int main(){
    ios::sync_with_stdio(0) ; cin.tie(nullptr) ;
    cin >> n >> k ; for(int i=1;i<=n;++i) cin >> nums[i] ;
    cout << quicksearch(nums,1,n,k+1) << endl  ;
    system("pause") ;
}
```



# 背包问题

**背包问题技巧：**
1.如果是0-1背包，即数组中的元素不可重复使用，nums放在外循环，target在内循环，且内循环倒序；

```python
for num in nums:
    for i in range(target, nums-1, -1):
```


2.如果是完全背包，即数组中的元素可重复使用，nums放在外循环，target在内循环。且内循环正序。

```python
for num in nums:
    for i in range(nums, target+1):
```

3.如果组合问题需考虑元素之间的顺序，需将target放在外循环，将nums放在内循环。

```python
for i in range(1, target+1):
    for num in nums:
```

[第九讲 背包问题问法的变化 · 背包问题九讲 · 看云 (kancloud.cn)](https://www.kancloud.cn/kancloud/pack/70133)

**`dp[i][j]`:**前 i 件物品，背包容量为 j 的情况下，可以装多满/装的最大价格是多少/... 其他需要最大化的目标。

**状态转移方程：**`dp[i][j]= max(dp[i-1][j],dp[i-1][j-v[i]]+w[i])`

**leetcode:**  416   322  518  494  474  879  1049  279 377 

## 01背包问题

**题目：[2. 01背包问题 - AcWing题库](https://www.acwing.com/problem/content/2/)**

**问题：**给定一些物品装入背包，装入背包的最大价值的多少？假设背包容量为m，有n个物品，每个物品的体积为v[i]，价值为w[i]。

```c++
// 朴素思想
#include <bits/stdc++.h>
using namespace std;
#define maxN 1001     // 商品数量 
#define maxM 1001     // 背包容量
int v[maxN],w[maxN];
int dp[maxN][maxM];
int n,m;
void _01Knapsack(){
    for(int i=0;i<=m;++i) dp[0][i] = 0, dp[i][0] = 0;
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            dp[i][j] = dp[i-1][j];
            if(j>=v[i]){
                dp[i][j] = max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]);
            }
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i) scanf("%d%d",&v[i],&w[i]);
    _01Knapsack();
    printf("%d\n",dp[n][m]);
    system("pause");
    return 0;
}
/*
5 6
1 2
2 4
3 4
4 5
5 6
*/

```



```c++
// 滚动数组优化
#include <bits/stdc++.h>
using namespace std;
#define maxN 1001     // 商品数量 
#define maxM 1001     // 背包容量
int v[maxN],w[maxN];
int dp[maxM];
int n,m;
void _01Knapsack(){
    for(int i=0;i<=m;++i) dp[i] = 0;  // 不放商品价值：0
    for(int i=1;i<=n;++i){
        for(int j=m;j>=v[i];--j){
            dp[j] = max(dp[j],dp[j-v[i]]+w[i]);
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i) scanf("%d%d",&v[i],&w[i]);
    _01Knapsack();
    printf("%d\n",dp[m]);
    system("pause");
    return 0;
}
/*
5 6
1 2
2 4
3 4
4 5
5 6
*/
```



## 完全背包问题

**题目：[3. 完全背包问题 - AcWing题库](https://www.acwing.com/problem/content/3/)**

**问题：**给定一些物品装入背包，每个物品可以放入无限次，装入背包的最大价值的多少？假设背包容量为m，有n个物品，每个物品的体积为v[i]，价值为w[i]。

**ps:**也可以求最小价值

```c++
// 朴素思想
#include <bits/stdc++.h>
using namespace std;
#define maxN 1001     // 商品数量 
#define maxM 1001     // 背包容量
int v[maxN],w[maxN];
int dp[maxN][maxM];
int n,m;
void completeKnapsack(){
    for(int i=0;i<=m;++i) dp[0][i] = 0, dp[i][0] = 0;
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            for(int k=0;k<=(j/v[i]);++k){
                dp[i][j] = max(dp[i-1][j],dp[i-1][j-k*v[i]]+k*w[i]);
            }
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i) scanf("%d%d",&v[i],&w[i]);
    completeKnapsack();
    printf("%d\n",dp[n][m]);
    system("pause");
    return 0;
}
/*
5 6
1 2
2 4
3 4
4 5
5 6
*/
/*
12
*/
```

```c++
// 01背包滚动数组的朴素思想
#include <bits/stdc++.h>
using namespace std;
#define maxN 1001     // 商品数量 
#define maxM 1001     // 背包容量
int v[maxN],w[maxN];
int dp[maxM];
int n,m;
void completeKnapsack(){
    for(int i=0;i<=m;++i) dp[i] = 0;
    for(int i=1;i<=n;++i){
        for(int j=m;j>=0;--j){ // 注意需要倒序，因为是01背包思想
            for(int k=0;k<=(j/v[i]);++k){
                dp[j] = max(dp[j],dp[j-k*v[i]]+k*w[i]);
            }
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i) scanf("%d%d",&v[i],&w[i]);
    completeKnapsack();
    printf("%d\n",dp[m]);
    system("pause");
    return 0;
}
/*
5 6
1 2
2 4
3 4
4 5
5 6
*/
/*
12
*/
```

```c++
// 直接使用滚动数组(只有完全背包适用)
#include <bits/stdc++.h>
using namespace std;
#define maxN 1001     // 商品数量 
#define maxM 1001     // 背包容量
int v[maxN],w[maxN];
int dp[maxM];
int n,m;
void completeKnapsack(){
    for(int i=0;i<=m;++i) dp[i] = 0;  // 不放商品价值：0
    for(int i=1;i<=n;++i){
        for(int j=v[i];j<=m;++j){
            dp[j] = max(dp[j],dp[j-v[i]]+w[i]);
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i) scanf("%d%d",&v[i],&w[i]);
    completeKnapsack();
    printf("%d\n",dp[m]);
    system("pause");
    return 0;
}
/*
5 6
1 2
2 4
3 4
4 5
5 6
*/
/*
12
*/
```







## 多重背包问题

**（可以二进制思想优化）**

**题目：[4. 多重背包问题 I - AcWing题库](https://www.acwing.com/problem/content/4/)**

**问题：**给定一些物品装入背包，每个物品可以放入有限次，装入背包的最大价值的多少？假设背包容量为m，有n个物品，每个物品的体积为v[i]，价值为w[i]，次数为s[i]。

```c++
// 01背包滚动数组的朴素思想
#include <bits/stdc++.h>
using namespace std;
#define maxN 1001     // 商品数量 
#define maxM 1001     // 背包容量
int v[maxN],w[maxN],s[maxN];
int dp[maxM];
int n,m;
void multiKnapsack(){
    for(int i=0;i<=m;++i) dp[i] = 0;
    for(int i=1;i<=n;++i){
        for(int j=m;j>=v[i];--j){  // 注意倒序，01背包的思想
            for(int k=1;k<=(j/v[i]) && k<=s[i];++k){
                dp[j] = max(dp[j],dp[j-k*v[i]]+k*w[i]);
            }
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i) scanf("%d%d%d",&v[i],&w[i],&s[i]);
    multiKnapsack();
    printf("%d\n",dp[m]);
    system("pause");
    return 0;
}
/*
4 5
1 2 3
2 4 1
3 4 3
4 5 2
*/
/*
10
*/
```

**单调队列优化**

```c++
#include <bits/stdc++.h>
using namespace std ;
using ll = long long ;
const int M = 2e4+10 ;
int dp[M] , q[M] , g[M] ;
void solve(){
	int n , m ; cin >> n >> m ; 

	vector<int> v(n + 1) , w(n + 1) , s(n + 1) ;
	for(int i=1;i<=n;++i) cin >> v[i] >> w[i] >> s[i] ;

	//vector<int> dp(m + 1) , q(m + 1) , g(m + 1) ; 
	for(int i=1;i<=n;++i){
		memcpy(g,dp,sizeof dp) ;
		for(int j=0;j<v[i];++j){
			int head = 0 , tail = -1 ; 
			for(int k=j;k<=m;k+=v[i]){  // 单调队列的长度是s[i] + 1 
				if(head <= tail && (q[tail] - q[head] + v[i]) / v[i] >= s[i] + 1 ) head ++ ;
				while(head <= tail && g[q[tail]] - (q[tail] - j) / v[i] * w[i] <= g[k] - (k - j) / v[i] * w[i]) tail -- ;
				q[++tail] = k ;
				dp[k] = max(dp[k] , g[q[head]] + (k - q[head]) / v[i] * w[i]) ;
			}
		}
	}

	cout << dp[m] << endl ;
}

int main(){
	ios::sync_with_stdio(false) ; cin.tie(nullptr) ; cout.tie(nullptr) ;

	int t = 1 ; //cin >> t ;

	while(t --) solve() ;

	return 0 ;
}
```



## 背包恰好装满

```c++
// 滚动数组
int dp[m+1];
dp[0] = 0;
for(int i=1;i<=m;i++) dp[i]=INT_MIN;  // 初始化为INT_MIN
for(int i=1;i<=n;i++){
    for(int j=m;j>=0;j--){  // 可以写成 j>=v[i] 就不用写下面的if了
        if(j>=v[i]) dp[j] = max(dp[j],w[i]+dp[j-v[i]]);
    }
}
return dp[m];
```



## 二维背包问题

**问题：**对于一个背包，不仅仅有（v1）体积的限制，还有（v2）重量的限制（或者最多只能带M件物品的限制）

```c++
vector<vector<int>> dp(m1+1,vector<int>(m2+1,0));
for(int i=1;i<=n;i++){
    for(int j=m1;j>=v1[i];j--){  // 两种代价
        for(int k=m2;k>=v2[i];k--){
            dp[j][k] = max(dp[j][k],dp[j-v1[i]][k-v2[i]]+w[i]);
        }
    }
}
return dp[m1][m2];
```

## 分组背包

**题目：[9. 分组背包问题 - AcWing题库](https://www.acwing.com/problem/content/9/)**

```c++
#include <bits/stdc++.h>
using namespace std ;
using ll = long long ;

void solve(){
	int n , m ; cin >> n >> m ;

	vector<int> dp(m + 1) ;
	for(int i=1;i<=n;++i) {
		int s ; cin >> s ; vector<int> v(s + 1) , w(s + 1) ;
		for(int j=1;j<=s;++j) cin >> v[j] >> w[j] ;
		for(int j=m;j>=0;--j) for(int k=1;k<=s;++k) {
			if(j >= v[k]) dp[j] = max(dp[j] , dp[j - v[k]] + w[k]) ;
		}
	}

	cout << dp[m] << endl ;
}

int main(){
	ios::sync_with_stdio(false) ; cin.tie(nullptr) ; cout.tie(nullptr) ;

	int t = 1 ; //cin >> t ;

	while(t --) solve() ;

	return 0 ;
}
```



## 求最优方案

**题目：[12. 背包问题求具体方案 - AcWing题库](https://www.acwing.com/problem/content/description/12/)**

**解法：**以01背包为例，我们可以再用一个数组`G[i][j]`来记录方案，设 `G[i][j] = 0`表示计算 `dp[i][j]` 的值时是采用了max中的前一项(也即`dp[i−1][j]`)，`G[i][j] = 1` 表示采用了方程的后一项。即分别表示了两种策略: 未装入第 i 个物品及装了第 i 个物品。

```c++
// 朴素思想
#include <bits/stdc++.h>
using namespace std;
#define maxN 1002     // 商品数量 
#define maxM 1002     // 背包容量
int v[maxN],w[maxN];
int dp[maxN][maxM];  // 价值
int n,m;
vector<int> path;
void _01Knapsack(){
    for(int i=0;i<=m;++i) {
        dp[0][i] = 0;dp[i][0] = 0;
    }
    for(int i=n;i>=1;--i){
        for(int j=1;j<=m;++j){
            dp[i][j] = dp[i+1][j];
            if(j>=v[i]){
                int val = dp[i+1][j-v[i]]+w[i];
                if(dp[i][j] <= val){ 
                    dp[i][j] = val;
                }
            }
        }
    }
}

void track(){
    int i = 1,j = m;
    while(i<=n && j>=0){
        if(j>=v[i] && dp[i][j] == dp[i+1][j-v[i]]+w[i]){
            path.push_back(i);
            j -= v[i];
        }
        ++i;
    }
    for(int i=0;i<path.size();++i){
        printf("%d ",path[i]);
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i) scanf("%d%d",&v[i],&w[i]);
    _01Knapsack();
    track();
    system("pause");
    return 0;
}
/*
4 5
1 2
2 4
3 4
4 6
*/
/*
1 4
*/

```



## 组合个数问题

**问题：**可以到达总价值的组合数。

**题目：[11. 背包问题求方案数 - AcWing题库](https://www.acwing.com/problem/content/11/)**

```c++
// 朴素思想
#include <bits/stdc++.h>
using namespace std;
#define maxN 1001     // 商品数量 
#define maxM 1001     // 背包容量
#define mod 1000000007
int v[maxN],w[maxN];
int dp[maxN][maxM];  // 价值
int cnt[maxN][maxM];  // 方案数量
int n,m;
void _01Knapsack(){
    for(int i=0;i<=m;++i) {
        dp[0][i] = 0;dp[i][0] = 0;
        cnt[0][i] = 1; cnt[i][0] = 1;
    }
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            dp[i][j] = dp[i-1][j];
            cnt[i][j] = cnt[i-1][j];
            if(j>=v[i]){
                int val = dp[i-1][j-v[i]]+w[i];
                if(dp[i][j] < val){
                    dp[i][j] = val;
                    cnt[i][j] = cnt[i-1][j-v[i]];
                }else if(dp[i][j] == val){
                    cnt[i][j] = (cnt[i-1][j]+cnt[i-1][j-v[i]])%mod;
                }
            }
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i) scanf("%d%d",&v[i],&w[i]);
    _01Knapsack();
    printf("%d\n",cnt[n][m]);
    system("pause");
    return 0;
}
/*
4 5
1 2
2 4
3 4
4 6
*/
/*
2
*/
```

## 丢弃一个物品

**题目：[D-清楚姐姐学01背包(Hard Version)_2023牛客寒假算法基础集训营4 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/46812/D)**

**重点：前缀背包和后缀背包**

```c++
#include <bits/stdc++.h>
#define debug cout << "__LINE__" << __LINE__ < endl ;
#define int long long
using namespace std ;
using ll = long long ;

void solve(){
	int n , m ; cin >> n >> m ;

	vector<int> v(n + 1) , w(n + 1) ;
	for (int i = 1; i <= n; ++i)
	{
		cin >> v[i] >> w[i] ;
	}

	vector<vector<int>> dppix(n + 2 , vector<int>(m + 1)) ;
	vector<vector<int>> dppos(n + 2 , vector<int>(m + 1)) ;
	for (int i = 1; i <= n; ++i)
	{
		for(int j = m; j >= 0; --j)
		{
			dppix[i][j] = dppix[i-1][j] ;
			if(j >= v[i]) dppix[i][j] = max(dppix[i-1][j] , dppix[i-1][j - v[i]] + w[i]) ;
		}
	}
	for (int i = n; i >= 1; --i)
	{
		for(int j = m; j >= 0; --j)
		{
			dppos[i][j] = dppos[i+1][j] ;
			if(j >= v[i])dppos[i][j] = max(dppos[i+1][j] , dppos[i+1][j - v[i]] + w[i]) ;
		}
	}

	int MaxVal = dppix[n][m] ;

	for (int i = 1; i <= n; ++i)
	{
		int tp = 0 ; int V = m - v[i] ; int tp2 = 0 ;
		for(int j = 0; j <= m; ++j)
		{
			tp = max(dppix[i-1][j] + dppos[i+1][m - j] , tp) ;
			if(V >= j) tp2 = max(dppix[i-1][j] + dppos[i+1][V - j] , tp2) ;
		}
		if(MaxVal != tp) cout << 0 << endl ;
		else cout << MaxVal + 1 - w[i] - tp2 << endl ;
	}
}

signed main(){
	ios::sync_with_stdio(false) ; cin.tie(nullptr) ; cout.tie(nullptr) ;

	int t = 1 ; // cin >> t ;
	while( t -- )
    {
		solve() ;
	}

	return 0 ;
}
```

**题目：[P4141 消失之物 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4141)**

**重点：恢复原样**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 2e3+10 ;
int n , m ; int f[N] , w[N] , g[N] ; // g[i] 表示当删掉某一个物品时，容量为i的方案数。
int main()
{
	cin >> n >> m ;
    for(int i=1;i<=n;++i) cin >> w[i] ;
    f[0] = 1 ;
    for(int i=1;i<=n;++i) for(int j=m;j>=w[i];--j){
        f[j] = (f[j] + f[j - w[i]])%10 ;
    }
    for(int i=1;i<=n;++i){
        memcpy(g,f,sizeof f);
        for(int j=w[i];j<=m;++j)  // 必须要顺推，恢复到上一个状态，物品递推的顺序无所谓，可以看作最后一个物品
            g[j]-=g[j-w[i]] , g[j] = (g[j]+10)%10;
        for(int j=1;j<=m;++j) cout << g[j]  ; cout << endl ;
    }
	system("pause");
	return 0;
}
```



# 动态规划

## 切钢管

**题目：**给你一个prices数组，代表不同长度钢管的价格。给定一段长度为n的钢条，求切割钢条的方案，使收益最大

```C++
如:int price[] = {0,1,5,8,9,10,17,17,20,24,30}
   n = 10;
answer = 30;
```

```c++
class Solution {
public:
    int cutRod(int n, vector<int>& prices) {
        // dp[i] = max(dp[k]+dp[i-k]) k:[0...i/2]
        int* dp = new int[n+1];  // 长度为i的钢管能出售的最大价值
        memset(dp,0,sizeof(int)*(n+1));
        for(int i=1;i<=n;++i){
            dp[i] = prices[i];
            for(int k=0;k<=i/2;++k){
                dp[i] = max(dp[i],dp[k]+dp[i-k]);
            }
        }
        return dp[n];
    }
};
```



## 矩阵链乘法

**题目：**给定n个矩阵：`A0,A1,A2,…,An-1`，其中Ai与Ai+1是可乘的，`i=0,1，2…，n-1`。确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。输入数据为矩阵个数和每个矩阵规模，输出结果为计算矩阵连乘积的计算次序和最少数乘次数。

**矩阵相乘：**

```c++
 // 矩阵连乘积A1A2A3，3个矩阵的维数分别为10x100,100x5和5x50，
（（A1*A2）*A3）     数乘次数：10*100*5+10*5*50=7500
（A1*（A2*A3））     数乘次数：100*5*50+10*100*50=75000
```

**递归关系：**从连乘矩阵个数为2开始计算每次的最小乘次数`m[i][j]: m[0][1] m[1][2] m[2][3] m[3][4] m[4][5] //m[0][1]表示A0矩阵与A1矩阵的最小乘次数`

然后再计算再依次计算连乘矩阵个数为3:`m[0][2] m[1][3] m[2][4] m[3][5]`

连乘矩阵个数为4：`m[0][3] m[1][4] m[2][5]`

连乘矩阵个数为5：`m[0][4] m[1][5]`

连乘矩阵个数为6：`m[0][5]` //即最后我们要的结果

**状态转化方程：**`m[i][j]= min (m[i][k]+m[k+1][j] + Pi*Pk+1*Pj+1)`

​                          `k:[i...j-1]`

```c++
#include<bits/stdc++.h>
using namespace std;
 
class Solution{
public:
    int MatrixChain(vector<int>& P){
        // 对P数组的必要说明：
        /*
            矩阵的维数分别是 30x35,35x15,15x5,5x10,10x20,20x25
            int p[n+1] ={ 30,35,15,5,10,20,25};
        */
        int n = P.size()-1;  // 矩阵个数
        auto m = vector<vector<int>>(n,vector<int>(n));  // m[i][j]:代表矩阵A[i]...A[j]的最少次数
        auto s = vector<vector<int>>(n,vector<int>(n));  // 记录乘法优先次序(也就是K值)
        // 初始化
        for(int i=0;i<n;++i) m[i][i] = 0;
        // 填表
        for(int i=n-1;i>=0;--i){  // 倒序保证无后效性
            for(int j=i+1;j<n;++j){
                m[i][j] = INT32_MAX;
                for(int k=i;k<j;++k){
                    int temp = m[i][k]+m[k+1][j]+P[i]*P[k+1]*P[j+1];
                    if(m[i][j]>temp){
                        m[i][j] = temp;
                        s[i][j] = k;
                    }                    
                }
            }
        }
        
        function<void(int,int)> print = [&](int i, int j){
            if(i == j){
                cout<<"A"<<i;
                return;
            } 
            cout<<"(";
            print(i,s[i][j]);
            cout<<")(";
            print(s[i][j]+1,j);
            cout<<")";
        };
        print(0,n-1);  // 打印矩阵乘法次序

        cout<<endl;
        return m[0][n-1];
    }
};

int main()
{
    int p[7] ={30,35,15,5,10,20,25};
    vector<int> P(p,p+7);
    Solution S;
    cout<<S.MatrixChain(P)<<" "<<endl;
    system("pause");
    return 0;
}
```



## 最优二叉搜索树

**定义：**给定一个n个关键字的已排序的序列`K=<k 1 ,k 2 ,…,k n >`（ 不失一般性，设`k 1 <k 2 <…<k n` ），对每个关键字`k i` ，都有一个概率`p i` 表示其搜索频率。根据`k i`和`p i` 构建一个二叉搜索树T，每个`k i` 对应树中的一个结点。若搜索对象x等于某个`k i` ，则一定可以在T中找到结点k i ；若`x<k 1 或 x>k n` 或 `k i <x<k i+1 (1≤i<n)`, 则在T中将搜索失败。为此引入外部结点`d 0 ,d 1 ,…,d n` ，用来表示不在`K`中的值，称为伪结点。这里每个`d i` 代表一个区间， `d 0` 表示所有小于`k 1` 的值， `d n` 表示所有大于`k n` 的值，对于`i=1,2,…,n-1`，`d i` 表示所有在`k i 和k i+1` 之间的值。 同时每个`d i` 也有一个概率`qi` 表示搜索对象x恰好落入区间`d i` 的频率。

**搜索期望：**

![FSH](初学上课笔记.assets\FSH.png)

 **定义状态：**

```c++
// 假设有 n 个键值K[1...n] 虚建d[0...n]
e[n+2][n+1];  // e[i][j]代表包含d[i-1...j] k[i...j]的一棵树的最小搜索代价期望
w[n+2][n+1];  // w[i][j]包含d[i-1...j],k[i...j]的概率之和,w[i][i-1]只包含虚建d[i-1]
root[n+2][n+1];  // 记录r值，方便构建最优二叉搜索树
ans: e[1][n]
```

**状态转移方程：**

```c++
e[i][j] = min(e[i][j],e[i][r-1]+e[r+1][j]+w[i][j]);   // r: i ~ j; 
e[i][i-1] = q[i-1];
w[i][j] = w[i][j-1]+p[j]+q[j];
w[i][i-1] = q[i-1];
```

**代码实现：**

```c++
#include<bits/stdc++.h>
using namespace std;

class Solution{
public:
    double optimalBST(int n, vector<double>& p, vector<double>& q){
        auto e = vector<vector<double>>(n+2,vector<double>(n+1));  // e[i][j]代表包含d[i-1...j] k[i...j]的一棵树的最小搜索代价期望
        auto w = vector<vector<double>>(n+2,vector<double>(n+1));  // w[i][j]包含d[i-1...j],k[i...j]的概率之和,w[i][i-1]只包含虚建d[i-1]
        auto root = vector<vector<int>>(n+2,vector<int>(n+1)); // 记录r值，方便构建最优二叉搜索树
        // 初始化
        for(int i=1;i<=n+1;++i) e[i][i-1] = q[i-1],w[i][i-1] = q[i-1];
        // 填表
        for(int i=n;i>=1;--i){
            for(int j=i;j<=n;++j){
                e[i][j] = 1e9+7;
                w[i][j] = w[i][j-1]+p[j]+q[j];
                for(int r=i;r<=j;++r){
                    double temp = e[i][r-1]+e[r+1][j]+w[i][j];
                    if(e[i][j]>temp){  
                        e[i][j] = temp;  
                        root[i][j] = r;  
                    }
                }
            }
        }

        cout<<"--------------------------------------------"<<endl;
        cout << "各子树的根：" << endl;
        for (int i = 1;i <= n+1;++i)
        {
            for (int j = 1;j <= n;++j)
            {
                cout << root[i][j] << " ";
            }
            cout << endl;
        }
        cout << endl;
        cout<<"--------------------------------------------"<<endl;
        function<void(int,int,int)> printOptimalBST = [&](int i,int j,int r){
            int rootChild = root[i][j];//子树根节点
            if (rootChild == root[1][n]){
                //输出整棵树的根
                cout << "k" << rootChild << "是根" << endl;
                printOptimalBST(i,rootChild - 1,rootChild);
                printOptimalBST(rootChild + 1,j,rootChild);
                return;
            }
            if (j < i - 1)
                return;
            else if (j == i - 1){  //遇到虚拟键
                if (j < r)
                    cout << "d" << j << "是" << "k" << r << "的左孩子" << endl;
                else
                    cout << "d" << j << "是" << "k" << r << "的右孩子" << endl;
                return;
            }else{  //遇到内部结点
                if (rootChild < r)
                    cout << "k" << rootChild << "是" << "k" << r << "的左孩子" << endl;
                else
                    cout << "k" << rootChild << "是" << "k" << r << "的右孩子" << endl;
            }
            printOptimalBST(i,rootChild - 1,rootChild);
            printOptimalBST(rootChild + 1,j,rootChild);
        };
        printOptimalBST(1,n,-1);
        cout<<"--------------------------------------------"<<endl;

        return e[1][n];
    }
};


int main(){
    double pt[6] = {-1,0.15,0.1,0.05,0.1,0.2};
    double qt[6] = {0.05,0.1,0.05,0.05,0.05,0.1};
    vector<double> p (pt,pt+6);
    vector<double> q (qt,qt+6);
    Solution S;
    cout<<S.optimalBST(5,p,q)<<endl;
    system("pause");
    return 0;
}
```



## 最长公共子序列

**LCS定义：**最长公共子序列，英文缩写为LCS（Longest Common Subsequence）。其定义是，一个序列 S ，如果分别是两个或多个已知序列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。

**区别：**

**（1）字符子串：**指的是字符串中连续的n个字符，如abcdefg中，ab，cde，fg等都属于它的字串。

**（2）字符子序列**：指的是字符串中不一定连续但先后顺序一致的n个字符，即可以去掉字符串中的部分字符，但不可改变其前后顺序。如abcdefg中，acdg，bdf属于它的子序列，而bac，dbfg则不是，因为它们与字符串的字符顺序不一致。

   **(3)  公共子序列：**如果序列C既是序列A的子序列，同时也是序列B的子序列，则称它为序列A和序列B的公共子序列。如对序列 1,3,5,4,2,6,8,7和序列 1,4,8,6,7,5 来说，序列1,8,7是它们的一个公共子序列。

### **求最长公共子序列的长度**

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.size();
        int m = text2.size();
        // dp[i][j]代表text1[0...i]与text2[0...j]的最长公共子序列的长度
        auto dp = vector<vector<int>>(n,vector<int>(m));
        for(int i=0;i<n;++i){
            for(int j=0;j<m;++j){
                if(i>0 && j>0){
                    if(text1[i]==text2[j]) dp[i][j] = dp[i-1][j-1]+1;
                    else dp[i][j] = max(dp[i][j-1],dp[i-1][j]);
                }else if(i>0){  // i>0,j=0
                    if(text1[i]==text2[j]) dp[i][j] = 1;
                    else dp[i][j] = dp[i-1][j];
                }else if(j>0){ // i=0,j>0
                    if(text1[i]==text2[j]) dp[i][j] = 1;
                    else dp[i][j] = dp[i][j-1];
                }else {  // i=0,j=0
                    if(text1[i]==text2[j]) dp[i][j]=1;
                    else dp[i][j]=0;
                }
            }
        }
        return dp[n-1][m-1];
    }
};
```



### **求最长子序列**

若答案有多个，输出任意一个

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.size();
        int m = text2.size();
        // dp[i][j]代表text1[0...i]与text2[0...j]的最长公共子序列的长度
        auto dp = vector<vector<int>>(n,vector<int>(m));
        // path[i][j]=0代表由dp[i][j]由dp[i-1][j-1]得来
        // path[i][j]=-1代表由dp[i][j]由dp[i][j-1]得来
        // path[i][j]=1代表由dp[i][j]由dp[i-1][j]得来
        auto path = vector<vector<int>>(n,vector<int>(m));
        // 填表
        for(int i=0;i<n;++i){
            for(int j=0;j<m;++j){
                if(i>0 && j>0){
                    if(text1[i]==text2[j]) {
                        dp[i][j] = dp[i-1][j-1]+1;
                        path[i][j] = 0;
                    }else {
                        dp[i][j] = max(dp[i][j-1],dp[i-1][j]);
                        if(dp[i][j]==dp[i][j-1]) path[i][j] = -1;
                        else path[i][j] = 1;
                    }
                }else if(i>0){  // i>0,j=0
                    if(text1[i]==text2[j]) dp[i][j] = 1,path[i][j] = 0;
                    else dp[i][j] = dp[i-1][j],path[i][j] = 1;
                }else if(j>0){ // i=0,j>0
                    if(text1[i]==text2[j]) dp[i][j] = 1,path[i][j] = 0;
                    else dp[i][j] = dp[i][j-1],path[i][j] = -1;
                }else {  // i=0,j=0
                    if(text1[i]==text2[j]) dp[i][j]=1,path[i][j] = 0;
                    else dp[i][j]=0,path[i][j] = 1;
                }
            }
        }

        function<void(int,int)> PrintLCS = [&](int i,int j){
            if(i<0 || j<0) return;
            if (path[i][j] == 0){
                PrintLCS(i-1, j-1);
                cout<<text1[i];
            }else if (path[i][j] == 1)
                PrintLCS(i-1,j);
            else
                PrintLCS(i, j-1);
        };
        PrintLCS(n-1,m-1);
        cout<<endl;
        
        return dp[n-1][m-1];
    }
};
```

## Ltter-moving Game

[题目详情 - 1015 Letter-moving Game (pintia.cn)](https://pintia.cn/problem-sets/994805148990160896/exam/problems/994805151045369856)

**题目：**这是一个简单的穿插的移动字母游戏。游戏以 2 个字符串 S 和 T 开始，由小写英文字母组成。S 和 T 包含相同的字母，但顺序可能不同。换句话说，S 可以通过在字符串 T 中打乱字母来获得。在每一步，您都可以移动S 中的任意一个字母到它的开头或结尾。将 S 更改为 T 至少需要多少步？

**输入规范：**

每个输入文件包含一个测试用例。对于每种情况，第一行包含字符串 S，第二行包含字符串 T。它们仅由小写的英文字母组成，S可以通过打乱T的字母来获得。S 的长度不大于 1000。输出规格：

对于每种情况，在一行中打印将 S 更改为 T 的最少步骤数。

**示例输入：**

```in
iononmrogdg
goodmorning
```

**示例输出：**

```out
8
```

**示例解决方案：**

```c++
(0) starts from iononmrogdg
(1) Move the last g to the beginning: giononmrogd
(2) Move m to the end: giononrogdm
(3) Move the first o to the end: ginonrogdmo
(4) Move r to the end: ginonogdmor
(5) Move the first n to the end: gionogdmorn
(6) Move i to the end: gonogdmorni
(7) Move the first n to the end: googdmornin
(8) Move the second g to the end: goodmorning
```





## 四边形不等式优化区间DP

**适用的状态转换方程：** `dp[i][j]= min{dp[i][k]+dp[k+1][j]+w[i][j]} or dp[i][j]= max{dp[i][k]+dp[k+1][j]+w[i][j]} `

**数学知识：**

- 凸四边形不等式：`w[a][c]+w[b][d]<=w[b][c]+w[a][d]（a<b<c<d）`
- 区间包含关系单调: `w[b][c]<=w[a][d]（a<b<c<d）`
- 定理1：  如果w同时满足四边形不等式和决策单调性 ,则dp也满足四边形不等式
- 定理2：  若f满足四边形不等式，则决策s满足 `s[i][j-1]<=s[i][j]<=s[i+1][j]`
- 定理3： w为凸当且仅当`w[i][j]+w[i+1][j+1]<=w[i+1][j]+w[i][j+1]` 

**例题：**石子合并

​       在一个操场上摆放着一排 N 堆石子。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的得分。

试设计一个算法，计算出将 N 堆石子合并成一堆的最小得分。

**approach 1：未优化 O(n^3)**

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n;
    cin>>n;
    auto nums = vector<int>(n);
    for(int i=0;i<n;++i) cin>>nums[i];
    // dpMin[i][j]代表合并nums[i...j]的最小得分
    auto dpMin = vector<vector<int>>(n,vector<int>(n));
    // 辅助数组sum[i][j] :nums[i...j]的和
    auto sum = vector<vector<int>>(n,vector<int>(n));
    // 初始化
    for(int i=0;i<n;++i){
        dpMin[i][i] = 0;
        sum[i][i] = nums[i];
    }
    // 填表
    for(int i=n-1;i>=0;--i){
        for(int j=i+1;j<n;++j){
            dpMin[i][j] = INT_MAX;
            sum[i][j] = sum[i][j-1]+nums[j];
            for(int k=i;k<j;++k){
                int temp = dpMin[i][k]+dpMin[k+1][j]+sum[i][j];
                if(dpMin[i][j]>temp){
                    dpMin[i][j] = temp;
                }
            }
        }
    }
    cout<<dpMin[0][n-1]<<endl;
    system("pause");
    return 0;
}

```

**approach 2 : 优化版本O(n^2)**

```c++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n;
    cin>>n;
    auto nums = vector<int>(n);
    for(int i=0;i<n;++i) cin>>nums[i];
    // dpMin[i][j]代表合并nums[i...j]的最小得分
    auto dpMin = vector<vector<int>>(n,vector<int>(n));
    // 辅助数组sum[i][j] :nums[i...j]的和
    auto sum = vector<vector<int>>(n,vector<int>(n));
    auto s = vector<vector<int>>(n,vector<int>(n));
    // 初始化
    for(int i=0;i<n;++i){
        dpMin[i][i] = 0;
        sum[i][i] = nums[i];
        s[i][i] = i;
    }
    // 填表
    for(int i=n-1;i>=0;--i){
        for(int j=i+1;j<n;++j){
            dpMin[i][j] = INT_MAX;
            sum[i][j] = sum[i][j-1]+nums[j];
            for(int k=s[i][j-1];k<=s[i+1][j]&&k<j;++k){
                int temp = dpMin[i][k]+dpMin[k+1][j]+sum[i][j];
                if(dpMin[i][j]>temp){
                    dpMin[i][j] = temp;
                    s[i][j] = k;
                }
            }
        }
    }
    cout<<dpMin[0][n-1]<<endl;
    system("pause");
    return 0;
}

```

# 贪心算法

## 礼品分组

**题目：**输入一个有N个数字的数组，你要将它们分组（每组只能由两数组成），使各组两数之和（两数之和<=W）接近。输出满足上述条件的最小组数。

**输入：**

输入包含n+2行：
第1行包括一个整数w，为每组纪念品价格之和的上限。
第2行为一个整数n，表示购来的纪念品的总件数。
第3~n+2行每行包含一个正整数pi (5 <= pi <= w)，表示所对应纪念品的价格。

**输出：**

输出仅一行，包含一个整数，即最少的分组数目。

```c++
#include <bits/stdc++.h>
using namespace std;

class Solution{
public:
    int findMinOperation(int w,vector<int>& gift){
        sort(begin(gift),end(gift));
        int ans=0;
        int left=0,right=gift.size()-1;
        while(left<right){
            if(gift[left]+gift[right] <= w){
                ++ans;
                ++left;--right;
            }else {
                ++ans;
                --right;
            }
        }
        if(left==right) ++ans;
        return ans;
    }
};

int main(){
    int w,n;
    cin>>w>>n;
    int gift[n];
    for(int i=0;i<n;++i) cin>>gift[i];
    vector<int> Gift(gift,gift+n);
    Solution S;
    int ans = S.findMinOperation(w,Gift);
    cout<<ans<<endl;
    system("pause");
    return 0;
}

```



## 游玩次数最多

**题目：**你今天进入游乐场玩耍，可以随便畅玩所有项目，但是每个项目只在特定时间段才能玩耍，你需要如何安排才能使得游玩的项目个数最多。

**输入：**

第一行输入项目总数 n

后面依次输入每个项目的起始时间和结束时间

**输出：**

输出最多游玩项目的个数 

```C++
#include <bits/stdc++.h>
using namespace std;

class Solution{
public:
    int findMaxOperation(vector<vector<int>>& timeSche){
        sort(begin(timeSche),end(timeSche),[](vector<int>& v1,vector<int>& v2){
            if(v1[1]==v2[1]) return v1[0]<v2[0];
            else return v1[1]<v2[1];
        });  // 按结束时间降序排列
        int ans=1;
        int endTime=timeSche[0][1];
        for(int i=1;i<timeSche.size();++i){
            if(endTime<=timeSche[i][0]){
                ++ans;
                endTime = timeSche[i][1];
            }
        }
        return ans;
    }
};


int main(){
    int n;
    cin>>n;
    auto timeSche = vector<vector<int>>(n,vector<int>(2));
    for(int i=0;i<n;++i) cin>>timeSche[i][0]>>timeSche[i][1];
    Solution S;
    int ans = S.findMaxOperation(timeSche);
    cout<<ans<<endl;
    system("pause");
    return 0;
}

```



## 到达目的地油价总额最少

**题目：**有N+1个城市，0是起点，N是终点，开车从0 -> 1 - > 2…… -> N，车每走1个单位距离消耗1个单位的汽油。给出每个城市到下一个城市的距离D，以及当地的油价P，求走完整个旅途最少的花费。

**输入：**

第一行输入N

后面依次输入距离和价格

**输出：**

走完整个旅途的最少花费

```c++
#include <bits/stdc++.h>
using namespace std;
#define maxN 100006
#define int long long
int n;
int D[maxN],P[maxN];

signed main(){
    cin>>n;
    for(int i=0;i<n;++i) cin>>D[i]>>P[i];
    int moreMin=P[0];
    int distance=D[0];
    int ans=0;
    for(int i=1;i<n;++i){
        if(P[i]<moreMin){
            cout<<distance<<" "<<moreMin<<endl;
            ans += moreMin*distance;
            distance = 0;
            moreMin = P[i];
        }
        distance += D[i];
    }
    ans += moreMin*distance;
    cout<<ans<<endl;
    system("pause");
    return 0;
}
```



## 到达目的地取油次数最少

**题目：[871. 最低加油次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-refueling-stops/)**

```c++
class Solution {
public:
    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {
        int n = stations.size();
        int ans=0;
        if(n>0 && startFuel<stations[0][0]) return -1;  // 边界条件
        priority_queue<int,vector<int>,less<int>> heap;  // 最大堆
        int currFuel=startFuel;
        for(int i=0;i<n;++i){
            heap.push(stations[i][1]);
            while(i<n-1&& currFuel<stations[i+1][0] && !heap.empty()){  // 加油直到能到达下一个加油站为止
                currFuel += heap.top();
                heap.pop();
                ++ans;
            }
            if(i<n-1&&currFuel<stations[i+1][0]) return -1;  // 到达不了加油站
        }
        while(currFuel<target && !heap.empty()){
            currFuel += heap.top();
            heap.pop();
            ++ans;
        }
        if(currFuel<target) return -1;  // 到达不了最后的终点
        return ans;
    }
};
```



## 田忌赛马

**题目：**

**田忌赛马**
田忌和齐王赛马,两人各出n匹马,赢一场比赛得200两银子,输了赔200银子,平局不赔不赚.已知两人每匹马的速度,问田忌最多能赢多少银子.
多组测试数据,
每组数据的第一行是一个整数n。 (1<=n<=1000)
第二行包括n个整数既田忌每匹马的速度.
第三行包括n个整数既齐王每匹马的速度.
每匹马的速度不超过1000.
对于每组数据输出一行有一个整数代表田忌最多能赢多少银子
**Sample Input**

```c++
3
92 83 71
95 87 74
2
20 20
20 20
2
20 19
22 18
```

**Sample Output**

```c++
200
0
0
```

**代码实现：**

```c++
#include <bits/stdc++.h>
using namespace std;

  // 优先胜利，其次平局，最后失败
  // 尽可能的保存田忌的实力的同时赢得最多的比赛，或者输掉最少的比赛
  // 用实力相近的进行比赛，快的与快的比较，慢的与慢的比较
int main()
{
	while(1){
		int res=0;
		int n;
		cin>>n;
		if(n==0) return 0;
		vector<int> nums1(n);
		vector<int> nums2(n);
		for(int i=0;i<n;++i) cin>>nums1[i];
		for(int i=0;i<n;++i) cin>>nums2[i];
		sort(nums1.begin(),nums1.end(),greater<int>());
		sort(nums2.begin(),nums2.end(),greater<int>());
		int begin_1=0,end_1=n-1;
		int begin_2=0,end_2=n-1;
		for(int i=0;i<n;++i){
			if(nums1[begin_1]>nums2[begin_2]) {  // 最快的马  田忌最快的马就是用来赢齐王最快的马的，第一步贪心
				res += 200;
				begin_1++;
				begin_2++;
			}else if(nums1[end_1]>nums2[end_2]){  // 最慢的马  反正齐王最慢的马都要输的，不如拿田忌最慢的马来赢，第二步贪心，尽量要用最慢里面的较快马来对抗齐王的最快马，尽量达成平局
				res += 200;
				end_1--;
				end_2--;
			}else if(nums1[end_1]<nums2[begin_2]){  // 用慢马对抗快马  反正齐王最快的马都要赢的，不如拿田忌最慢的马来输
					res -= 200;
					end_1--;
					begin_2++;
			}else{   // 最慢的马和最快的马速度相同  
				end_1--;
				begin_2++;
			}
		}
		cout<<res<<endl;
	}
	system("pause");
	return 0;
}
```



## 哈夫曼编码

**引理1**：给定*W* = {*w*1, *w*2, *w*3...,*wn*} (*n* >= 2), 以此集合构建相应的哈夫曼树。令wi, wj 是W中权重最小的两个元素，则这两个数对应的结点是兄弟结点，且这两结点在二叉树中的深度不小于其它任何一个叶结点的深度。

**定理1：**哈夫曼树是最优的。

证明：用归纳法证明。

**基本情况:** 当 n=2 时, 哈夫曼树具有最小权重外部路径（EPW），因为树 仅有二种可能，有二个叶结点的二种哈夫曼树下的EPW是相同的。
**假设:** 设有哈夫曼树有 个叶子时，定理成立。
**推导:** 令T为有n （n>=2）个叶子的哈夫曼树。不失 一般性，设 w1 <= w2 <=... <=wn。令是w1 与w2的父结点。由引理1知, 在T中，不存在叶结点，其深度大于叶结点w1 与w2的深度。若存在深度大于w1, w2深度的结点，我们可以通过将之与w1, w2交换，由此得到更小的WPL。按如下方式得到到二叉树T'：以结点V'替换结点V, 其中V'的权重是w1+w2，则T'是相应于{w1+w2,w3,...,wn}的一棵哈夫曼树。根据归纳假设，T'具有最小权重外部路径，T是最优的（EPW最小）。在T'的结点V'上添加叶结点w1, w2，可得T，则T是具有最小权重外部路径的哈夫曼树。由此，我们由数学照片纳法证明了定理1. 

**代码实现：**

```c++
#include <bits/stdc++.h>
using namespace std;

struct HuffmanNode
{
    int weight;                        // 权重，出现的次数或者频率
    char ch;                           // 存储符号
    string code;                       // 存储该符号对应的编码
    int leftChild, rightChild, parent; // 左、右孩子，父结点
};

class HuffmanCode
{
public:
    HuffmanCode(string str);                          // 构造函数
    ~HuffmanCode();                                   // 析构函数
    void getMin(int &first, int &second, int parent); // 选取两个较小的元素
    void Merge(int first, int second, int parent);    // 合并
    void Encode();                                    // 编码:利用哈夫曼编码原理对数据进行加密
    void Decode(string str);                          // 解码
private:
    HuffmanNode *HuffmanTree; // 数组
    int leafSize;             // 统计不同字符的个数
};

// 构造函数
HuffmanCode::HuffmanCode(string str)
{
    int len = (int)str.size();          // 字符串的长度
    int arr[256], i;                    // 存储字符串各个字符的个数
    HuffmanTree = new HuffmanNode[256]; // 动态分配空间，最多128个字符，树的节点数最多255个

    // 1.初始化HuffmanTree数组
    for (i = 0; i < (2 * len - 1) && i<256; i++)   // 防止越界
    { // 叶子结点为len,则树最多有2*len-1个结点
        HuffmanTree[i].leftChild = HuffmanTree[i].rightChild = HuffmanTree[i].parent = -1;
        HuffmanTree[i].code = "";
    }

    // 2.统计输入的字符串的各个字符出现的个数
    memset(arr, 0, sizeof(arr)); // 清零
    for (i = 0; i < len; i++)    // 统计次数，下标是对应字符，arr[i]是对应字符出现的次数
        arr[str[i]]++;           // str[i] -> 转成对应的ASCII码，如'0'->48
    
    leafSize = 0;                // 出现不同字符的个数
    for (i = 0; i < 256; i++)
    {
        if (arr[i] != 0)
        { // 有出现的字符
            cout << "字符:" << (char)i << "次数为：" << arr[i] << endl;
            HuffmanTree[leafSize].ch = (char)i;    // 将数字转成对应的字符
            HuffmanTree[leafSize].weight = arr[i]; // 权重
            leafSize++;
        }
    }
    
    // 3.选取两个较小值合并
    int first, second; // 两个较小的结点
    for (i = leafSize; i < (2 * leafSize - 1); i++)
    {                             // 做leafSize-1趟
        getMin(first, second, i); // 选取两个较小的元素
        Merge(first, second, i);  // 合并
    }
}

// 析构函数
HuffmanCode::~HuffmanCode()
{
    delete[] HuffmanTree;
}

// 选取权值两个较小的元素
void HuffmanCode::getMin(int &first, int &second, int parent)
{
    double weight = 0;
    int i;

    // 找权重最小元素
    for (i = 0; i < parent; i++)
    {
        if (HuffmanTree[i].parent != -1) // 已选过，直接跳过
            continue;
        if (weight == 0)
        { // 第一次找到没选过的结点
            weight = HuffmanTree[i].weight;
            first = i;
        }
        else if (HuffmanTree[i].weight < weight)
        { // 权值更小
            weight = HuffmanTree[i].weight;
            first = i;
        }
    }
    // 找权重次小元素
    weight = 0;
    for (i = 0; i < parent; i++)
    {
        if (HuffmanTree[i].parent != -1 || i == first) // 已选过，直接跳过
            continue;
        if (weight == 0)
        { // 第一次找到没选过的结点
            weight = HuffmanTree[i].weight;
            second = i;
        }
        else if (HuffmanTree[i].weight < weight)
        { // 权值更小
            weight = HuffmanTree[i].weight;
            second = i;
        }
    }
}

// 合并
void HuffmanCode::Merge(int first, int second, int parent)
{
    HuffmanTree[first].parent = HuffmanTree[second].parent = parent;                     // 父结点
    HuffmanTree[parent].leftChild = first;                                               // 左孩子
    HuffmanTree[parent].rightChild = second;                                             // 右孩子
    HuffmanTree[parent].weight = HuffmanTree[first].weight + HuffmanTree[second].weight; // 权值
}

// 编码:利用哈夫曼编码原理对数据进行加密
void HuffmanCode::Encode()
{
    string code; // 存储符号的不定长二进制编码
    int i, j, k, parent;

    for (i = 0; i < leafSize; i++)
    { // 从叶子结点出发
        j = i;
        code = ""; // 初始化为空
        while (HuffmanTree[j].parent != -1)
        {                                           // 往上找到根结点
            parent = HuffmanTree[j].parent;         // 父结点
            if (j == HuffmanTree[parent].leftChild) // 如果是左孩子，则记为0
                code += "0";
            else // 右孩子，记为1
                code += "1";
            j = parent; // 上移到父结点
        }
        // 编码要倒过来：因为是从叶子往上走到根，而编码是要从根走到叶子结点
        reverse(begin(code),end(code));
        HuffmanTree[i].code = code;
        cout << "字符：" << HuffmanTree[i].ch << "的编码为：" << HuffmanTree[i].code << " ";
    }
}

// 解码
void HuffmanCode::Decode(string str)
{
    string decode, temp;       // decode保存整个解码, temp保存每一个解码
    int len = (int)str.size(); // 编码的长度
    int i, j;

    decode = temp = ""; // 初始化为空
    for (i = 0; i < len; i++)
    {
        temp += str[i]; // 加一个编码
        for (j = 0; j < leafSize; j++)
        {
            if (HuffmanTree[j].code == temp)
            {                                // 在叶子结点中找到对应的编码
                decode += HuffmanTree[j].ch; // 转成对应的字符
                temp = "";
                break;
            }
        }
        if (i == len - 1 && j == leafSize)
        { // 遍历完都没找到对应的编码
            cout << "解码出错！" << endl;
            return;
        }
    }
    cout << decode << endl;
}

int main()
{
    string str;

    cout << "请输入字符串进行编码：" << endl;
    cin >> str;          // 输入要加密的字符串
    HuffmanCode st(str); // 对象
    cout << "对字符串编码情况如下：" << endl;
    st.Encode(); // 编码
    cout << endl;
    cout << "请输入要解码的二进制编码:" << endl;
    cin >> str;
    cout << "解码如下：" << endl;
    st.Decode(str); // 解码

    system("pause");
    return 0;
}
```

# 线性表

## 顺序表

**Approach 1**

```c++
template<typename  E>
class List{
private:
	void operator= (const List& ){};
	List(const List&){};
public:
	List(){};
	virtual ~List(){};
	virtual void clear() = 0;
	virtual void insert (const E& item) = 0;
	virtual void append (const E& item) = 0;
	virtual E remove() = 0;
	virtual void moveToStart() = 0;
	virtual void moveToEnd() = 0;
	virtual void prev() = 0;
	virtual void next() = 0;
	virtual void moveToPos(int pos) = 0;
	virtual const E& getValue() const = 0;
	virtual int length() const = 0;
	virtual int currrPos() const = 0;
};

template<typename  E>
class AList:public List<E>{
private:
	int maxSize;
	int listSize;
	int curr;
	E* listArray;
public:
	AList(int maxSize){
		this->maxSize = maxSize;
		listSize = curr = 0;
		listArray = new E[maxSize]
	};
	~AList(){
		if(listArray != NULL){
			delete [] listArray;
			listArray = NULL;
		}
	};
	void clear(){
		delete[] listArray;
		listSize = curr = 0;
		listArray = new E[maxSize];
	}
	void insert (const E& item){
		Assert(listSize<maxSize,"List capacity exceeded");
		for(int i = listSize;i>curr;i--){
			listArray[i] = listArray[i-1];
		}
		listArray[curr] = item;
		listSize ++;
	}
	void append (const E& item){
		Assert(listSize<maxSize,"List capacity exceeded");
		listArray[listSize++] = item;
	}
	E remove(){
		Assert((curr>=0) && (curr < listSize), "No element");
		E it = listArray[curr];
		for(int i=curr; i<listSize-1; i++) 
		listArray[i] = listArray[i+1];
		listSize--; 
		return it;
	}
	void moveToStart(){curr = 0;}
	void moveToEnd(){curr = listSize-1;}
	void prev(){if(curr != 0) curr--;}
	void next(){if(curr < listSize) curr ++}
	void moveToPos(int pos){Assert((pos>=0)&&(pos<=listSize),"Pos out of range");curr = pos;}
	const E& getValue() const{
		Assert((curr>=0)&&(curr<listSize),"No current element");
		return listArray[curr];
	}
	int length() const{return listSize;}
	int currrPos() const{return curr;}
};

```



**Approach 2**

```c++
template<typename E>
class SqList:public List<E>{
private:
	E * data;
	int lenth;
	int MAXSIZE;
public:
	SqList(){
		this->MAXSIZE = 10000;
		this->data = new E[MAXSIZE];
		this->lenth = 0;
	}
	SqList(int lenth){
		this->MAXSIZE = static_cast<int>(lenth*1.3);
		this->data = new E[MAXSIZE];
		this->lenth = lenth;		
	}
	~SqList(){
		if(this->data != NULL){
			delete[] data;
			this->data = NULL;
		}
	}
	// 插入操作判定长度超出没有，下标是否合法
	void push_back(E data){
		if(lenth<MAXSIZE){
			this->data[lenth] = data;
			this->lenth++;
		}
		else{
			return;
		}
	}
	// 删除操作注意下标是否合法，链表是否为空
	void pop_back(){
		if(lenth <= 0) return;  // 无元素就直接返回
		else{
			this->lenth--;  // 逻辑尾删
		}
	}
	void push_front(E data){
		if(lenth<MAXSIZE){
			for(int i=lenth-1;i>=0;i--){
				this->data[i+1] = this->data[i];
			}
			this->data[0] = data;
			this->lenth++;
		}
		else{
			return;
		}
	}
	void pop_front(){
		if(lenth<=0) return;
		for(int i=0;i<lenth-1;i++){
			this->data[i] = this->data[i+1];
		}
		this->lenth--;
	}
	void insert(int pos,E data){
		if(lenth<MAXSIZE || pos>lenth || pos<0){
			for(int i=lenth-1;i>=pos;i--){
				this->data[i+1] = this->data[i];
			}
			this->data[pos] = data;
			this->lenth++;
		}
		else return;
	}
	void erase(int pos){
		if(lenth<=0) return;
		for(int i=pos;i<lenth-1;i++){
			this->data[i] = this->data[i+1];
		}
		this->lenth--;
	} 
	E getData(int pos)const {
		if(pos>=0&&pos<lenth){
			return this->data[pos];
		}
		else exit(0);  // 终止程序
	}
	E front()const {
		if(lenth <= 0){
			exit(0);
		}
		else{
			return this->data[0];
		}
	}
	E back()const {
		if(lenth <= 0){
			exit(0);
		}
		else{
			return this->data[lenth-1];
		}
	}
	bool empty() const{
		if(lenth == 0) return true;
		else return false;
	}
	int size() const{
		return this->lenth;
	}
	void clear() {
		lenth = 0;
	}
	int find(E data)const{  // 返回第一个找到的下标，未找到返回-1
		if(lenth<=0) return -1;
		else{
			for(int i=0;i<lenth;i++){
				if(this->data[i] == data){
					return i;
				}
			}
			return -1;
		}
	} 
	int capacity()const{
		return this->MAXSIZE;
	}
	SqList<E>& operator=(const SqList<E> & L){
		this->MAXSIZE = L.capacity();
		this->lenth = L.size();
		if(this->data != NULL){
			delete[] data;
			data = NULL;
		}
		this->data = new E[this->MAXSIZE];
		for(int i=0;i<this->lenth;i++){
			this->data[i] = L.getData(i);
		}
		return *this;
	}
	void print()const {
		for(int i=0;i<lenth;i++){
			cout<<this->data[i]<<" ";
		}
		cout<<endl;
	}
};
```



## 单链表

**简易版本**

```c++
#include <iostream>
using namespace std;

struct ListNode{
    int data;
    ListNode* next;
    ListNode(int _data=0):data(_data),next(NULL){}
};
ListNode* Init(){
    ListNode* H = new ListNode;  // 头节点，data域可以存储长度等信息
    return H;
}
void push_front(ListNode* H,int data){
    ListNode* temp = H->next;
    H->next = new ListNode(data);
    H->next->next = temp;
}
void pop_front(ListNode* H){
    if(H->next==NULL) return;
    ListNode* temp = H->next;
    H->next = temp->next;
    delete temp;
}
void visit(ListNode* H){
    for(ListNode* it=H->next;it!=NULL;it=it->next){
        printf("%d ",it->data);
    }
    printf("\n");
}

int main(){
    ListNode* H = Init();
    for(int i=0;i<=9;++i) push_front(H,i);
    visit(H);
    system("pause");
    return 0;
}
```

**节点构造**

```c++
template<typename E>
class Node{
public:
    E data;
    Node *next;
    Node(){
        next = NULL;
    }
};
```

**链表实现**

```c++
template<typename E>
class LinkList:public List<E>{
private:
    int lenth;
    Node<E> *H;
    Node<E> *R;
public:
    LinkList(){
        lenth = 0;
        H = new Node<E>;
        R = H;
    }
    ~LinkList(){
        Node<E> * p = H;
        while(H != NULL){
            H = H->next;
            delete p;
            p = H;
        }
    }
	void push_back(E data){
        R->next = new Node<E>;
        R = R->next;  // 指向尾节点
        R->data = data;
        lenth++;
    }
	void pop_back(){
        if(lenth <= 0) return;
        delete R;
        lenth--;
        R = H;
        for(int i = 0;i<lenth;i++){
            R = R->next;
        }
        R->next = NULL;
    }
	void push_front(E data){
        Node<E> * temp = H->next;
        H->next = new Node<E>;
        H->next->next = temp;
        H->next->data = data;
        lenth++;
    }
	void pop_front(){
        if(lenth <= 0) return;
        Node<E>* temp = H->next->next;
        delete H->next;
        H->next = temp;
        lenth--;
    }
	void insert(int pos,E data){
        if(pos<0||pos>=lenth||lenth<=0) exit(0);
        Node<E>* H_temp = H;
        for(int i = 0;i<pos;i++){
            H_temp = H_temp->next;
        }
        Node<E> * temp = H_temp->next;
        H_temp->next = new Node<E>;
        H_temp->next->next = temp;
        H_temp->next->data = data;
        lenth++;
    }
	void erase(int pos){
        if(pos<0||pos>=lenth||lenth<=0) return;
        Node<E>* H_temp = H;
        for(int i = 0;i<pos;i++){
            H_temp = H_temp->next;
        }
        Node<E>* temp = H_temp->next->next;
        delete H_temp->next;
        H_temp->next = temp;
        lenth--;
    }
	E getData(int pos) const{
        if(pos<0||pos>=lenth||lenth<=0) exit(0);
        Node<E>* H_temp = H;
        for(int i = 0;i<=pos;i++){
            H_temp = H_temp->next;
        }
        return H_temp->data;
    }
	E front() const{
        if(lenth<=0) exit(0);
        return H->next->data;
    }
	E back() const{
        if(lenth<=0) exit(0);
        return R->data;
    }
	bool empty() const{
        if(lenth<=0) return true;
        else return false;
    }
	int size() const{
        return lenth;
    }
	void clear(){
        Node<E> * p = H;
        while(H != NULL){
            H = H->next;
            delete p;
            p = H;
        }
        H = new Node<E>;
        R = H;
        lenth = 0;
    }
	int find(E data) const{
        if(lenth<=0)  return -1;
        int i=0;
        for(Node<E>* temp = H->next;temp != NULL;temp = temp->next,i++){
            if(temp->data == data) return i;
        }
        return -1;
    }
    Node<E>* getHead()const{
        return H;
    }
    Node<E>* getRetail()const{
        return R;
    }
    LinkList& operator=(const LinkList& L){
        this->clear();
        this->lenth = L.size();
        if(L.empty()) return *this;
        H->next = new Node<E>;
        Node<E>* H_temp = H->next;
        for(Node<E>* temp = L.getHead()->next;temp != NULL;temp = temp->next){
           H_temp->data = temp->data;
           if(temp->next == NULL) return *this;
           H_temp->next = new Node<E>;
           H_temp = H_temp->next;
        }
        return *this;
    }
    void print()const{
        if(lenth<=0) return;
        for(Node<E>* temp = H->next;temp != NULL;temp = temp->next){
            cout<<temp->data<<" ";
        }
        cout<<endl;
    }
};
```

## 双链表

```c++
struct Node{
    int val;
    Node* next;
    Node* prior;
    Node():next(NULL),prior(NULL){}
};
class DoubleList{
private:
	Node* H;
    int lenth;
public:
    DoubleList():lenth(0),H(NULL){}
};
```



## 循环列表

```c++
struct Node{
    int val;
    Node* next;
    Node* prior;
    Node():next(NULL),prior(NULL){}
};
class DoubleList{
private:
	Node* H;
    int lenth;
public:
    DoubleList():lenth(0),H(NULL){}
};
```

# 栈与队列

## 栈

### 面试题

![屏幕截图_20221208_151319](初学上课笔记.assets\屏幕截图_20221208_151319.png)

### 顺序表实现

**简易版本：**

```c++
#include <iostream>
using namespace std;
#define maxSize 1001

struct Stack{
    int tail;  // 栈的尾指针,指向最后一个元素
    int* data;
    Stack():tail(-1){data = new int[maxSize];}
    ~Stack(){if(data!=NULL){delete[] data;data = NULL;}}
};
int pop(Stack& S){
    if(S.tail==-1) return -1;
    return S.data[S.tail--];
}
void push(Stack& S,int data){
    S.data[++S.tail] = data;
}
int top(Stack& S){
    if(S.tail==-1) return -1;
    return S.data[S.tail];
}
int size(Stack& S){
    return S.tail+1;
}
int main(){
    Stack S;
    for(int i=0;i<=9;++i) push(S,i);
    cout<<size(S)<<endl;
    cout<<top(S)<<endl;
    for(int i=0;i<=9;++i) cout<<pop(S)<<" ";cout<<endl;
    system("pause");
    return 0;
}

```



**应用：**括号匹配，表达式的前缀后缀转换，进制转化

**实现：**

**注意：**top指针指向栈顶元素的上一个位置，base指针指向栈底元素

```c++
template<typename E>
class Stack{
private:
    int MAXSIZE;
    E *data;
    E *base,*p_top;
public:
    Stack(int MAXSIZE){
        this->MAXSIZE = MAXSIZE;
        this->data = new E[MAXSIZE];
        base = p_top = &(this->data[0]);
    };
    Stack(){
        MAXSIZE = 100;
        this->data = new E[MAXSIZE];
        base = p_top = &(this->data[0]);
    }
    ~Stack(){
        if(data != nullptr){
            delete[] data;
            data = nullptr; 
        }
    };
    void push(const E & data){
        if(p_top - base == MAXSIZE)  return;  // 栈满
        *(this->p_top) = data;
        p_top++;
    }
    void pop(){
        if(p_top == base ) return;  // 栈空
        p_top--;
    }
    void clear(){
        p_top = base;
    }
    E top()const{
        if(this->p_top == base) exit(0);
        return *(this->p_top-1);
    }
    bool empty()const{
        if(p_top == base) return true;
        return false;
    }
    int size()const{
        return p_top - base;
    }
    int getMAXSIZE()const {
        return MAXSIZE;
    }
    Stack& operator=(Stack& st){
        this->MAXSIZE = st.getMAXSIZE();
        if(this->data != nullptr){
            delete[] data;
            data = nullptr;
        }
        data = new E[MAXSIZE];
        base = p_top = &data[0];
        if(st.empty()) return *this;
        Stack temp;
        int lenth = st.size();
        for(int i=0;i<lenth;i++){
            temp.push(st.top());
            st.pop();
        }
        for(int i=0;i<lenth;i++){
            st.push(temp.top());
            this->push(temp.top());
            temp.pop();
        }
        return *this;
    }
};
```





### 链表实现

**注意：**节点的指针域存储前驱指针。top指针指向栈顶元素，base指针指向栈底元素。

**简易版本**

```c++
#include <iostream>
using namespace std;
struct node{
    int val;
    node* prior;
    node(int _val=0):val(_val),prior(NULL){}
};
struct Stack{
    node* tail;
    int size;
    Stack():tail(NULL),size(0){};
};
int pop(Stack& S){
    if(S.tail==NULL) return -1;
    S.size--;
    node* temp = S.tail;
    S.tail = S.tail->prior;
    int val = temp->val;
    temp->prior = NULL;
    delete temp;
    return val;
}
void push(Stack& S,int data){
    S.size++;
    node* temp = new node(data);
    temp->prior = S.tail;
    S.tail = temp;
}
int top(Stack& S){
    if(S.tail==NULL) return -1;
    return S.tail->val;
}
int size(Stack& S){
    return S.size;
}
int main(){
    Stack S;
    for(int i=0;i<=9;++i) push(S,i);
    cout<<size(S)<<endl;
    cout<<top(S)<<endl;
    for(int i=0;i<=9;++i) cout<<pop(S)<<" ";cout<<endl;
    system("pause");
    return 0;
}

```



## 队列

**注意：**用循环队列实现，留一个位置不填入数据，方便判断队空和队满的情况。

**应用：**八皇后，舞伴问题

**简易版本：**

```c++
#include <iostream>
using namespace std;
#define maxSize 1001

struct Queue{
    int* data;
    int fp,rp;  //fp指向第一个元素，rp指向最后一个元素的下一个
    Queue(){data = new int[maxSize];fp=0;rp=0;}
    ~Queue(){if(data!=NULL){delete[] data;data=NULL;}}
};
int front(Queue& Q){
    if(Q.rp==Q.fp) return -1;  // 队空
    return Q.data[Q.fp];
}
int back(Queue& Q){
    if(Q.rp==Q.fp) return -1;  // 队空
    if(Q.rp==0) return Q.data[maxSize-1];
    return Q.data[Q.rp-1];
}
void push(Queue& Q,int data){
    if((Q.rp+1)%maxSize==Q.fp) return;  // 队满
    Q.data[Q.rp] = data;
    Q.rp = (Q.rp+1)%maxSize;
}
int pop(Queue& Q){
    if(Q.rp==Q.fp) return -1;  // 队空
    int val = Q.data[Q.fp];
    Q.fp = (Q.fp+1)%maxSize;
    return val;
}
int size(Queue& Q){
    return (Q.rp-Q.fp+maxSize)%maxSize;
}

int main(){
    Queue Q;
    for(int i=0;i<=9;++i) push(Q,i);
    cout<<size(Q)<<endl;
    cout<<front(Q)<<endl;
    cout<<back(Q)<<endl;
    for(int i=0;i<=9;++i) cout<<pop(Q)<<" ";cout<<endl;
    system("pause");
    return 0;
}

```

**实现：**

```c++
template<typename E>
class Queue{
private:
    E * data;
    int p_front,rear;
    int MaxSize;
public:
    Queue(){
        MaxSize = 100;
        data = new E[MaxSize];
        p_front = rear = 0;
    }
    Queue(int MaxSize){
        this->MaxSize = MaxSize;
        data = new E[MaxSize];
        p_front = rear = 0;
    }
    ~Queue(){
        if(data != nullptr){
            delete[] data;
            data = nullptr;
        }
    }
    void push(const E& data){
        if((rear+1)%MaxSize == p_front) return ; // 队满
        this->data[rear] = data;
        rear = (rear+1)%MaxSize;
    }
    void pop(){
        if(rear == p_front) return;// 队空
        p_front = (p_front+1)%MaxSize;
    }
    E back()const {
        if(rear == p_front) exit(0);
        if(rear == 0) return this->data[MaxSize-1];
        return this->data[rear-1];
    }
    E front()const {
        if(rear == p_front) exit(0);
        return this->data[p_front];
    }
    bool empty()const {
        if(rear == p_front) return true;
        return false;
    }
    int size()const {
        return (rear-p_front+MaxSize)%MaxSize;
    }
    void clear(){
        rear = p_front;
    }
    int getMaxSize(){
        return MaxSize;
    }
    Queue& operator=(Queue& que){
        this->MaxSize = que.getMaxSize();
        if(data != nullptr){
            delete[] data;
            data = nullptr;
        }
        data = new E[MaxSize];
        p_front = rear = 0;
        if(que.empty()) return *this;
        Queue temp;
        while(!que.empty()){
            temp.push(que.front());
            que.pop();
        }
        while(!temp.empty()){
            que.push(temp.front());
            this->push(temp.front());
            temp.pop();
        }
        return *this;
    }
};
```

# 单调队列单调栈

**核心：及时移除无用数据的原则**

## 单调队列

**单调队列主要处理的是一个区间内的最大/小值**

**例题：[239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/)**

```c++
class Solution {
public:
    class MyDeque{
    public:
        deque<int> dq;
        void pop(int val){
            if(dq.front() == val) dq.pop_front();
        }
        void push(int val){
            while(dq.size() && dq.back() < val) dq.pop_back();
            dq.push_back(val);
        }
        int getMax(){
            return dq.front();
        }
    };
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MyDeque dq ; vector<int> ans ;
        for(int i=0;i<nums.size();++i){
            if(i < k-1) dq.push(nums[i]);
            else{
                dq.push(nums[i]);
                ans.push_back(dq.getMax()) ;
                dq.pop(nums[i-k+1]); 
            }
        }
        return ans;
    }
};
```

## 单调栈

**单调栈处理的是寻找以某个值为最小/大值的最大区间**

**参考：[贡献法+单调栈+三种实现版本（Python/Java/C++/Go） - 子数组的最小值之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-subarray-minimums/solution/gong-xian-fa-dan-diao-zhan-san-chong-shi-gxa5/)**

**模板题：[P5788 【模板】单调栈 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5788)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 3e6+10;
int ans[N] , n ,a[N] ;
class MyStack{  // 单调递减栈，存下标
public:
	stack<int> st;
	int size(){return st.size();}
	void pop(){st.pop();}
	int top(){return st.top();}
	void push(int idx){
		while(st.size() && a[st.top()] < a[idx]) {
			int id = st.top() ;  ans[id] = idx ;
			st.pop();
		}
		st.push(idx);
	}
};
int main(){
	cin >> n ; MyStack st; 
	for(int i=1;i<=n;++i){
		cin >> a[i] ;
		st.push(i);  
	}
	while(st.size()){
		int id = st.top() ; ans[id] = 0;
		st.pop();
	}
	for(int i=1;i<=n;++i) cout << ans[i] << " "; cout << endl ;
	system("pause");
}
```

**[907. 子数组的最小值之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-subarray-minimums/)**

```c++
class Solution {
public:
    int sumSubarrayMins(vector<int>& arr) {
        stack<int> st; int left[arr.size()] ,right[arr.size()] ;
        for(int i=0;i<arr.size();++i){
            while(st.size() && arr[st.top()] >= arr[i]) {  // 左边界强制大于等于arr[i]
                st.pop();
            }
            if(st.size()) left[i] = st.top();
            else left[i] = -1;
            st.push(i);
        }
        while(st.size()) st.pop();
        for(int i=0;i<arr.size();++i) cout << left[i] << " " ; cout << endl ;
        for(int i=0;i<arr.size();++i){
            while(st.size() && arr[st.top()] >= arr[i]){  // 右边界强制大于arr[i]
                right[st.top()] = i ; st.pop();
            }
            st.push(i);
        }
        while(st.size()) right[st.top()] = arr.size() , st.pop() ;
        for(int i=0;i<arr.size();++i) cout << right[i] << " " ; cout << endl ;
        const int P = 1e9+7; long long ans = 0LL;
        for(int i=0;i<arr.size();++i){.
            ans += ((long long)arr[i] * (long long)(i-left[i]) * (long long)(right[i]-i))%P ;
        }
        return ans%P;
    }
};
```

# 二叉树

## 理论知识

**树是递归定义**：树是由子树组成的

**完全二叉树：**一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。

**完全二叉树性质：**

1. 若父节点为i，则左孩子为2i，右孩子为2i+1.
2. 若子节点为i，则父节点为⌊i/2⌋.
3. N0 =  N2 + 1  叶子数 = 出度为2的数量 + 1
4. 层数：⌊log2(i)⌋ .底数为2 真数为i

## 模板

```c++
class Treap{
private:
    struct node{
        node* lc ; 
        node* rc ;
        int pri,val,siz;
        long long sum  ;
        node(int _val){
            lc = rc = nullptr ;
            pri = rand() ; val = _val ; siz = 1 ;
            sum = _val ;
        }
    } ;
    node* root ;
    int siz ;
public:
    Treap(){root = nullptr ; siz = 0 ;}
    void up(node* p){
        if(!p) return ;
        if(p->lc && p->rc) {
            p->sum = p->lc->sum + p->rc->sum + p->val ;
            p->siz = p->lc->siz + p->rc->siz + 1 ;
        } else if(p->lc){
            p->sum = p->lc->sum + p->val ;
            p->siz = p->lc->siz + 1 ;
        } else if(p->rc){
            p->sum = p->rc->sum + p->val ;
            p->siz = p->rc->siz + 1 ;
        } else {
            p->sum = p->val ;
            p->siz = 1 ;
        }
    }
    node* merge(node* x,node* y){
        if(!x) return y ;
        if(!y) return x ;
        if(x->pri > y->pri){
            x->rc = merge(x->rc , y) ;
            up(x) ;
            return x ;
        } else {
            y->lc = merge(x , y->lc) ;
            up(y) ;
            return y ;
        }
        return nullptr ;
    }

    void spilt(node* p,node*& x,node*& y,int val){
        if(!p){
            x = y = nullptr ; return ;
        }
        if(p->val <= val){
            x = p ; spilt(x->rc,x->rc,y,val) ; up(p) ; return ;
        } else {
            y = p ; spilt(y->lc,x,y->lc,val) ; up(p) ; return ;
        }
    }

    void add(int val) {
        siz ++ ;
        node* x ; node* y ;
        node* z = new node(val) ; 
        spilt(root,x,y,val) ;
        root = merge(merge(x,z),y) ;
        return ;
    }

    void del(int val) {
        siz -- ;
        node* x ; node* y ; node* z ;
        spilt(root,x,y,val) ;
        spilt(x,x,z,val-1) ;
        node* t = z ; 
        z = merge(z->lc,z->rc) ;
        delete t ;
        root = merge(merge(x,z),y) ;
        return ;
    }

    int size(){
        return siz ;
    }

    node* getK(node* p,int k){
        if(!p) return nullptr ;
        if(!p->lc) {
            if(k == 1) return p ;
            return getK(p->rc , k - 1) ;
        }
        if(p->lc->siz + 1 == k) return p ;
        else if(p->lc->siz >= k){
            return getK(p->lc , k) ;
        } else {
            return getK(p->rc , k - p->lc->siz - 1) ;
        }
    }

    void output(){
        function<void(node*)> output1 = [&](node* rt){
            if(rt == nullptr) return ;
            output1(rt->lc) ; 
            cout << rt->val << " " ;
            output1(rt->rc) ;
        } ;
        output1(root) ; cout << endl ;
    }
} ;
```



## 二叉树实现

### ADT

```c++
TreeNode(int _val):val(_val),left(NULL),right(NULL){}  
int getHeight(TreeNode* root);
int nodeSum(TreeNode* root);
int isLeaf(TreeNode* root);
int leafSum(TreeNode* root);
bool isSearchTree(TreeNode* root);
TreeNode* creatTreeByPreAndInorder(vector<int>& pre,vector<int> inorder);  // 中序遍历和前序遍历构造二叉树
TreeNode* creatTreeByPosAndInorder(vector<int>& pos,vector<int> inorder);  // 中序遍历和后序遍历构造二叉树
TreeNode* findFather(TreeNode* root,int _val);  // 返回val的父节点
TreeNode* insert(TreeNode* root,int _val);  // 返回根节点
TreeNode* erase(TreeNode* root,int _val);  // 返回根节点
void preTravel(TreeNode* root);  // 前序遍历
void inorderTravel(TreeNode* root);  //中序遍历
void posTravel(TreeNode* root);   //后序遍历
void levelTravel(TreeNode* root); // 层序遍历
```



### 节点实现

```c++
int val;
TreeNode* left;
TreeNode* right;
```

### 深度遍历

```c++
void preTravel(TreeNode* root){
    if(root==NULL) return;
    cout<<root->val<<" ";
    preTravel(root->left);
    preTravel(root->right);
}
void inorderTravel(TreeNode* root){
    if(root==NULL) return;
    inorderTravel(root->left);
    cout<<root->val<<" ";
    inorderTravel(root->right);
}
void posTravel(TreeNode* root){
    if(root==NULL) return;
    posTravel(root->left);
    posTravel(root->right);
    cout<<root->val<<" ";
}
```

### 深度遍历的非递归实现（stack实现）

```c++
void preTravel(TreeNode* p){  // DLR（先序遍历）
    stack<TreeNode*> st;
    while(!st.empty() || p){
        if(p){
            cout<<p->val<<" ";
            st.push(p);
            p = p->left;
        }
        else{
            p = st.top();
            st.pop();
            p = p->right;
        }
    }
}

void infTravel(TreeNode* p){  // LDR（中序遍历）
    stack<TreeNode*> st;
    while(!st.empty() || p){
        if(p){
            st.push(p);
            p = p->left;
        }
        else{
            p = st.top();
            cout<<p->val<<" ";
            st.pop();
            p = p->right;
        }
    }

}
// 二。     一。增加标记（两个栈）   三。对称。
void posTravel(TreeNode* p){  // LRD（后序遍历）
    stack<TreeNode*> st;
    while(!st.empty() || p){
        if(p){
            st.push(p);
            p = p->left;
        }
        else{
            p = st.top();
            p = p->right;
            if(p == NULL){
                TreeNode* temp;
                do{
                    temp = st.top();
                    st.pop();
                    cout<<temp->val<<" ";
                }while(!st.empty() && temp == st.top()->right);
            }
        }
    }
}
vector<int> v;
void posTravel(TreeNode* p){  // 对称
    stack<TreeNode*> st;
    while(!st.empty() || p){
        if(p){
            v.push_back(p->val);
            st.push(p);
            p = p->right;
        }
        else{
            p = st.top();
            st.pop();
            p = p->left;
        }
    }
    reverse(v.begin(),v.end());
}
```



### 广度遍历（queue实现）

```c++
void levelTravel(TreeNode* root){
    if(root == NULL) return;
    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        int cnt=q.size();
        for(int i=0;i<cnt;i++){
            if(q.front()->left != NULL)
                q.push(q.front()->left);
            if(q.front()->right != NULL)
                q.push(q.front()->right);
            cout<<q.front()->val<<" ";
            q.pop();
        }
        cout<<"# ";
    }
}
```



### 全部函数实现

```c++
#include <iostream>
#include <ctime>
#include <vector>
#include <queue>
using namespace std;
class TreeNode
{
public:
    int val;
    TreeNode* left;
    TreeNode* right;
public:
    TreeNode(int _val):val(_val),left(NULL),right(NULL){}  
    int getHeight(TreeNode* root);
    int nodeSum(TreeNode* root);
    int isLeaf(TreeNode* root);
    int leafSum(TreeNode* root);
    bool isSearchTree(TreeNode* root);
    TreeNode* creatTreeByPreAndInorder(vector<int>& pre,vector<int> inorder);  // 中序遍历和前序遍历构造二叉树
    TreeNode* creatTreeByPosAndInorder(vector<int>& pos,vector<int> inorder);  // 中序遍历和后序遍历构造二叉树
    TreeNode* findFather(TreeNode* root,int _val);  // 返回val的父节点
    TreeNode* insert(TreeNode* root,int _val);  // 返回根节点
    TreeNode* erase(TreeNode* root,int _val);  // 返回根节点
    void preTravel(TreeNode* root);  // 前序遍历
    void inorderTravel(TreeNode* root);  //中序遍历
    void posTravel(TreeNode* root);   //后序遍历
    void levelTravel(TreeNode* root); // 层序遍历
};
int getHeight(TreeNode* root){
    if(root==NULL) return 0;
    int L = getHeight(root->left);
    int R = getHeight(root->right); 
    return max(L,R)+1; 
}
int nodeSum(TreeNode* root){
    if(root==NULL) return 0;
    return nodeSum(root->left)+nodeSum(root->right)+1;
}
int isLeaf(TreeNode* root){
    if(root==NULL) return false;
    return (root->left==NULL && root->right==NULL);
}
int leafSum(TreeNode* root){
    if(root == NULL)return 0;
    if(root->left == NULL && root->right == NULL) return 1;
    return leafSum(root->left)+leafSum(root->right);
}
bool isSearchTree(TreeNode* root){
    class Solution {
        public:
        TreeNode* pre=NULL;
        bool tag = true;
        void inorder(TreeNode* root) {
            if(root==NULL) return;
            inorder(root->left);
            if(pre && pre->val >= root->val) tag = false;
            pre = root;
            inorder(root->right);
        }
    };
    Solution s;
    s.inorder(root);
    return s.tag;
}
TreeNode* creatTreeByPreAndInorder(vector<int>& pre,vector<int> inorder){
    class Solution {
        public:
        TreeNode* CreatTree(vector<int>& pre,int l1,int r1,vector<int>& ino,int l2,int r2){
            if((r1<l1) || (r2<l2)) return NULL;
            TreeNode* root = new TreeNode(pre[l1]);
            int mid = l2;
            while(pre[l1]!=ino[mid]) mid++;
            root->left = CreatTree(pre,l1+1,l1+mid-l2,ino,l2,mid-1);
            root->right = CreatTree(pre,l1+mid-l2+1,r1,ino,mid+1,r2);
            return root;
        }
    };
    Solution s;
    return s.CreatTree(pre,0,pre.size()-1,inorder,0,inorder.size()-1);
}
TreeNode* creatTreeByPosAndInorder(vector<int>& pos,vector<int> inorder){
    class Solution {
        public:
        TreeNode* CreatTree(vector<int>& pos,int l1,int r1,vector<int>& ino,int l2,int r2){
            if((r1<l1) || (r2<l2)) return NULL;
            TreeNode* root = new TreeNode(pos[r1]);
            int mid = l2;
            while(pos[r1]!=ino[mid]) mid++;
            root->left = CreatTree(pos,l1,l1+mid-l2-1,ino,l2,mid-1);
            root->right = CreatTree(pos,l1+mid-l2,r1-1,ino,mid+1,r2);
            return root;
        }
    };
    Solution s;
    return s.CreatTree(pos,0,pos.size()-1,inorder,0,inorder.size()-1);
}
TreeNode* findFather(TreeNode* root,int _val){
    if(root==NULL) return NULL;
    else if(root->left && root->left->val==_val) return root;
    else if(root->right && root->right->val==_val) return root;
    if(root->val > _val) return findFather(root->left,_val);
    else if(root->val < _val) return findFather(root->right,_val);
    return NULL;
}
TreeNode* insert(TreeNode* root,int _val){  // 二叉搜索树的插入规则，返回根节点
    if(root==NULL) return new TreeNode(_val);
    if(_val > root->val) root->right = insert(root->right,_val);
    if(_val < root->val) root->left = insert(root->left,_val);
    return root;
}
TreeNode* erase(TreeNode* root,int _val){  // 二叉搜索树的删除规则，返回根节点
    if(root==NULL) return NULL;
    if(root->val > _val) root->left = erase(root->left,_val);
    else if(root->val < _val) root->right = erase(root->right,_val);
    else{
        if(root->left==NULL) return root->right;
        if(root->right==NULL) return root->left;
        TreeNode* node = root->left;
        TreeNode* pre = root;
        while(node->right){
            pre = node;
            node = node->right;
        }
        root->val = node->val;
        if(pre->right->val==node->val) pre->right = node->left;
        else pre->left = node->left; 
    }
    return root;
}
void preTravel(TreeNode* root){
    if(root==NULL) return;
    cout<<root->val<<" ";
    preTravel(root->left);
    preTravel(root->right);
}
void inorderTravel(TreeNode* root){
    if(root==NULL) return;
    inorderTravel(root->left);
    cout<<root->val<<" ";
    inorderTravel(root->right);
}
void posTravel(TreeNode* root){
    if(root==NULL) return;
    posTravel(root->left);
    posTravel(root->right);
    cout<<root->val<<" ";
}
void levelTravel(TreeNode* root){
    queue<TreeNode*> q;
    TreeNode* temp = root;
    q.push(temp);
    while(!q.empty()){
        if(temp->left != NULL){
            q.push(temp->left);
        }
        if(temp->right != NULL){
            q.push(temp->right);
        }
        cout<<q.front()->val<<" ";
        q.pop();
        temp = q.front();
    }
}
int main(){
    
    system("pause");
    return 0;
}
```

## 补充：

### 后缀表达式转换成为二叉树

**注意：**父类共性函数区分子类

### 常见面试题：

![屏幕截图_20221208_111818](初学上课笔记.assets\屏幕截图_20221208_111818.png)

```c++
struct TreeNode{
    int val;
    TreeNode* lc;
    TreeNode* rc;
    TreeNode(int _data=0):val(_data),lc(NULL),rc(NULL){}
    ~TreeNode(){lc=NULL;rc=NULL;}
};
int getHeight(TreeNode* root){
    if(root==NULL) return 0;
    return max(getHeight(root->lc),getHeight(root->rc))+1;
}
int getLeaf(TreeNode* root){
    if(root==NULL) return 0;
    if(root->lc==NULL && root->rc==NULL) return 1;
    int s = 0;
    s += getLeaf(root->lc);
    s += getLeaf(root->rc);
    return s;
}
int getNode(TreeNode* root){
    if(root==NULL) return 0;
    int s = 0;
    s += getNode(root->lc);
    s += getNode(root->rc);
    return s+1;
}
int getKthNode(TreeNode* root,int k){
    // 非递归版本
    if(k==0 || root==NULL) return 0;
    queue<TreeNode*> Q;
    Q.push(root);
    while(!Q.empty()){
        int size = Q.size();
        --k;
        if(k==0) return size;
        for(int i=0;i<size;++i){
            TreeNode* temp= Q.front();Q.pop();
            if(temp->lc != NULL) Q.push(temp->lc);
            if(temp->rc != NULL) Q.push(temp->rc);
        }
    }
    return -1;
    // 递归版本
    /* if(k==0 || root==NULL) return 0;
    if(k==1) return 1;
    return getKthNode(root->lc,k-1)+getKthNode(root->rc,k-1); */
}

TreeNode* findMinAn(TreeNode* root,TreeNode* p,TreeNode* q){
    if(root==NULL || p==NULL || q==NULL) return NULL;
    if(root->val == p->val || root->val == q->val) return root;
    TreeNode* lc = findMinAn(root->lc,p,q);
    TreeNode* rc = findMinAn(root->rc,p,q);
    if(lc != NULL && rc != NULL) return root;
    else if(lc != NULL && rc == NULL) return lc;
    else if(lc == NULL && rc != NULL) return rc;
    else return NULL;
}
bool isCompleteBinTree(TreeNode* root){
    if(root==NULL) return true;
    queue<TreeNode*> Q;
    Q.push(root);
    while(!Q.empty()){
        TreeNode* temp= Q.front();
        Q.pop();
        if(temp == NULL) break;
        Q.push(temp->lc);
        Q.push(temp->rc);
    }
    while(!Q.empty()){
        if(Q.front()!=NULL) return false;
        Q.pop();
    }
    return true;
}
int diameterBinTree(TreeNode* root){
    int Max = 0;
    function<int(TreeNode*)> height = [&Max,&height](TreeNode* root){
        if(root==NULL) return 0;
        int lc = height(root->lc);
        int rc = height(root->rc);
        Max = max(Max,lc+rc);
        return max(lc,rc)+1;
    };
    height(root);
    return Max;
}
```



### 序列化二叉树 与反序列化二叉树

![v2-fbfd6c8251af9c9631c3429116a6fb08_r](初学上课笔记.assets\v2-fbfd6c8251af9c9631c3429116a6fb08_r.jpg)

**序列化方法：**将空节点用特殊的符号表示（#），然后遍历。

```c++
class Codec {
public:
    string seq="";  // 先序遍历的结果
    void DFS(TreeNode* root){  // 树转字符串
        if(root==NULL) {seq += "#,";return;}  // '#'代表一个NULL ','代表每个节点的分割
        seq += to_string(root->val);
        seq += ",";
        DFS(root->left);
        DFS(root->right);
    }
    vector<string> v;  // 存储“#”和“Val”  先序遍历存储的
    void  stringToVector(string s){  // 字符串转数组
        for(int i=0;i<s.size();i++){
            string temp="";
            while(s[i]!=','){
                temp.append(1,s[i]);
                i++;
            }
            v.push_back(temp);
        }
    }
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if(root==NULL) return "";
        DFS(root);
        cout<<seq<<endl;
        return seq;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if(data == "") return NULL;  // 空树直接返回；
        stringToVector(data);  // 字符串转数组
        TreeNode* root=new TreeNode(stoi(v[0]));  // 开辟根节点
        stack<TreeNode*> st;  // 栈顶为待插入节点的父节点，栈内为右子树还可以操作的节点
        st.push(root);
        for(int i=1;i<v.size();i++){
            if(v[i] == "#"){  // 如果遍历到空节点，一个#就会弹出一个节点
                while(i!=v.size()-1 && v[i+1]=="#"){  // 循环弹栈直到i指向数字的前一个#
                    st.pop();
                    i++;  // 指向下一个
                }
                if(i!=v.size()-1){  // 如果没到结尾，且此时i指向Val的前一个元素
                    st.top()->right = new TreeNode(stoi(v[i+1]));  // 开辟右子树
                    i++;  // 指向Val
                    TreeNode* temp1=st.top();  // 弹栈并且压入右子树
                    st.pop();
                    st.push(temp1->right);
                }
            }else{  // 如果遍历到数Val
                st.top()->left = new TreeNode(stoi(v[i]));
                cout<<v[i]<<endl;
                st.push(st.top()->left);
            }
        }
        return root;  // 返回根节点
    }
};
```



### 三叉链表

**增加一个指针域：**指向父节点的指针

### 线索二叉树

**空指针域数量：**n+1

**线索化：**将空指针域利用起来存放前驱指针或者后继指针

**空指针域 lchild：**存放前驱指针

**空指针域 rchild：**存放后继指针

**增设标志位tag：**

1. tag = 0  该位置是child
2. tag = 1 该位置是线索指针

**增设一个头节点：**

![77D56A2DBF43240A173E60DCDAE4C77E](初学上课笔记.assets\77D56A2DBF43240A173E60DCDAE4C77E.png)

## pbds作弊平衡树

```c++
#include<bits/stdc++.h>
#include<bits/extc++.h>

using namespace std ;
using namespace __gnu_pbds ;

typedef pair<int, int> pii ;

int main(){
    // 会去重
    tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> tr ;
    tr.insert(3) ;
    tr.insert(2) ;
    tr.insert(1) ;
    tr.insert(1) ;
    for(auto it = tr.begin(); it!=tr.end(); it++) {
        cout << *it << " ";
    } cout << endl ;
    // order_of_key(k) : 求比k小的数的个数 
    cout << "3的排名是：" << tr.order_of_key(3) << endl ;
    cout << "1的排名是：" << tr.order_of_key(1) << endl ;
    cout << "0的排名是：" << tr.order_of_key(0) << endl ;
    cout << "4的排名是：" << tr.order_of_key(4) << endl ;
    // find_by_order(k) : 根据上面的排名求数据
    cout << "第0小的值是：" << *tr.find_by_order(0) << endl ;
    cout << "第1小的值是：" << *tr.find_by_order(1) << endl ;
    cout << "第2小的值是：" << *tr.find_by_order(2) << endl ;
    cout << "第3小的值是：" << *tr.find_by_order(3) << endl ;
    cout << "第4小的值是：" << *tr.find_by_order(4) << endl ;
    
    cout << "第一个大于等于2的元素: " << *tr.lower_bound(2) << endl ;//返回第一个大于等于2的元素的迭代器
    cout << "第一个大于2的元素: " << *tr.upper_bound(2) << endl ;//返回第一个大于2的元素的迭代器

    system("pause") ;
    return 0 ;
}
```

```c++
#include<bits/stdc++.h>
#include<bits/extc++.h>

using namespace std ;
using namespace __gnu_pbds ;

struct node{
    int x, y ;
    bool operator<(const node& rhs) const{
        return tie(x, y) < tie(rhs.x, rhs.y) ;
    }
} ;

int main(){
    // 会去重
    tree<node, null_type, less<node>, rb_tree_tag, tree_order_statistics_node_update> tr ;
    tr.insert({1,2}) ;
    tr.insert({2,3}) ;
    tr.insert({3,4}) ;
    tr.insert({3,4}) ;
    for(auto it = tr.begin(); it!=tr.end(); it++) {
        cout << (*it).x << "|" << (*it).y << " ";
    }
    system("pause") ;
    return 0 ;
}
```



## 二叉搜索平衡树（AVL）

**测试：[1552. AVL树的根 - AcWing题库](https://www.acwing.com/problem/content/1554/)**

```c++
#include <bits/stdc++.h>
using namespace std;

typedef struct TreeNode{  
    int val,height;
    TreeNode* lc;
    TreeNode* rc;
    TreeNode(int _val=0):val(_val),height(1),lc(NULL),rc(NULL){};
}*BinTree;

int setHeight(TreeNode* root){
    if(root==NULL) return 0;
    return max(setHeight(root->lc),setHeight(root->rc))+1;
}
TreeNode* findFather(TreeNode* root,int val){
    if(root==NULL) return NULL;
    else if(root->lc && root->lc->val == val) return root;
    else if(root->rc && root->rc->val == val) return root;
    if(root->val > val) return findFather(root->lc,val);
    else if(root->val < val) return findFather(root->rc,val);
    return NULL;
}
int Height(TreeNode* root){
    if(root == NULL) return 0;
    return root->height;
}
TreeNode* leftRotation(TreeNode* A){
    TreeNode* C = A->rc;
    A->rc = C->lc;
    C->lc = A;
    C->height = setHeight(C);
    A->height = setHeight(A);
    return C;
}
TreeNode* rightRotation(TreeNode* A){
    TreeNode* B = A->lc;
    A->lc = B->rc;
    B->rc = A;
    B->height = setHeight(B);
    A->height = setHeight(A);
    return B;   
}
TreeNode* Adjust(TreeNode* root,TreeNode* node){  
    if(root == NULL) return root;
    if(root->val > node->val) root->lc = Adjust(root->lc,node);
    else if(root->val < node->val) root->rc = Adjust(root->rc,node);
    root->height = setHeight(root);
    if(Height(root->lc) - Height(root->rc) == 2){
        if(Height(root->lc->lc) < Height(root->lc->rc))
            root->lc = leftRotation(root->lc);
        root = rightRotation(root);
    }else if(Height(root->rc) - Height(root->lc) == 2){
        if(Height(root->rc->rc) < Height(root->rc->lc))
            root->rc = rightRotation(root->rc);
        root = leftRotation(root);
    }
    return root;
}
void insert(TreeNode* &root,int val){
    function<TreeNode*(TreeNode* &,TreeNode* &)> helper = [&helper](TreeNode* &root,TreeNode* &node){
        if(root==NULL) return node;
        else if(root->val >  node->val) root->lc = helper(root->lc,node);
        else if(root->val <= node->val) root->rc = helper(root->rc,node);
        return root;
    };
    TreeNode* node = new TreeNode(val);
    root = helper(root,node);
    root = Adjust(root,node);
}
void erase(TreeNode* &root,int val){
    function<TreeNode*(TreeNode* &,int)> helper = [&helper](TreeNode* &root,int val)->TreeNode*{
        if(root==NULL) return NULL;
        else if(root->val >  val) root->lc = helper(root->lc,val);
        else if(root->val <= val) root->rc = helper(root->rc,val);
        else{
            if(root->lc == NULL) return root->rc;
            if(root->rc == NULL) return root->lc;
            TreeNode* pre = root;
            TreeNode* node = root->lc;
            while(node->rc != NULL){
                pre = node;
                node = node->rc;
            }
            if(pre->rc == node) pre->rc = node->lc;
            else pre->lc = node->lc;
        }
        return root;
    };
    TreeNode* father = findFather(root,val);
    root = helper(root,val);
    root = Adjust(root,father);
}
int main(){
    int n;
    cin>>n;
    TreeNode* root=NULL;
    int temp;
    for(int i=0;i<n;++i){
        cin>>temp;
        insert(root,temp);
    }
    cout<<root->val<<endl;
    system("pause");
    return 0;
}
#include <bits/stdc++.h>
using namespace std;

typedef struct TreeNode{  
    int val,height;
    TreeNode* lc;
    TreeNode* rc;
    TreeNode(int _val=0):val(_val),height(1),lc(NULL),rc(NULL){};
}*BinTree;

int setHeight(TreeNode* root){
    if(root==NULL) return 0;
    return max(setHeight(root->lc),setHeight(root->rc))+1;
}
TreeNode* findFather(TreeNode* root,int val){
    if(root==NULL) return NULL;
    else if(root->lc && root->lc->val == val) return root;
    else if(root->rc && root->rc->val == val) return root;
    if(root->val > val) return findFather(root->lc,val);
    else if(root->val < val) return findFather(root->rc,val);
    return NULL;
}
int Height(TreeNode* root){
    if(root == NULL) return 0;
    return root->height;
}
TreeNode* leftRotation(TreeNode* A){
    TreeNode* C = A->rc;
    A->rc = C->lc;
    C->lc = A;
    C->height = setHeight(C);
    A->height = setHeight(A);
    return C;
}
TreeNode* rightRotation(TreeNode* A){
    TreeNode* B = A->lc;
    A->lc = B->rc;
    B->rc = A;
    B->height = setHeight(B);
    A->height = setHeight(A);
    return B;   
}
TreeNode* Adjust(TreeNode* root,TreeNode* node){  
    if(root == NULL) return root;
    if(root->val > node->val) root->lc = Adjust(root->lc,node);
    else if(root->val < node->val) root->rc = Adjust(root->rc,node);
    root->height = setHeight(root);
    if(Height(root->lc) - Height(root->rc) == 2){
        if(Height(root->lc->lc) < Height(root->lc->rc))
            root->lc = leftRotation(root->lc);
        root = rightRotation(root);
    }else if(Height(root->rc) - Height(root->lc) == 2){
        if(Height(root->rc->rc) < Height(root->rc->lc))
            root->rc = rightRotation(root->rc);
        root = leftRotation(root);
    }
    return root;
}
void insert(TreeNode* &root,int val){
    function<TreeNode*(TreeNode* &,TreeNode* &)> helper = [&helper](TreeNode* &root,TreeNode* &node){
        if(root==NULL) return node;
        else if(root->val >  node->val) root->lc = helper(root->lc,node);
        else if(root->val <= node->val) root->rc = helper(root->rc,node);
        return root;
    };
    TreeNode* node = new TreeNode(val);
    root = helper(root,node);
    root = Adjust(root,node);
}
void erase(TreeNode* &root,int val){
    function<TreeNode*(TreeNode* &,int)> helper = [&helper](TreeNode* &root,int val)->TreeNode*{
        if(root==NULL) return NULL;
        else if(root->val >  val) root->lc = helper(root->lc,val);
        else if(root->val <= val) root->rc = helper(root->rc,val);
        else{
            if(root->lc == NULL) return root->rc;
            if(root->rc == NULL) return root->lc;
            TreeNode* pre = root;
            TreeNode* node = root->lc;
            while(node->rc != NULL){
                pre = node;
                node = node->rc;
            }
            if(pre->rc == node) pre->rc = node->lc;
            else pre->lc = node->lc;
        }
        return root;
    };
    TreeNode* father = findFather(root,val);
    root = helper(root,val);
    root = Adjust(root,father);
}
int main(){
    int n;
    cin>>n;
    TreeNode* root=NULL;
    int temp;
    for(int i=0;i<n;++i){
        cin>>temp;
        insert(root,temp);
    }
    cout<<root->val<<endl;
    system("pause");
    return 0;
}

```



### 左旋

![左旋](初学上课笔记.assets\左旋.png)

**代码实现**

```c++
TreeNode* leftRotation(TreeNode* A){
    TreeNode* B = A->right;
    A->right = B->left;
    B->left = A;
    A->height = setHeight(A);
    B->height = setHeight(B);
    return B;
}
```



### 右旋

![右旋](初学上课笔记.assets\右旋.png)

**代码实现**

```c++
TreeNode* rightRotation(TreeNode* A){
    TreeNode* B = A->left;
    A->left = B->right;
    B->right = A;
    A->height = setHeight(A);
    B->height = setHeight(B);
    return B;
}
```

### AVL的平衡

```c++
TreeNode* Adjust(TreeNode* root,TreeNode* node){  
    if(node==NULL) return root;  // 删除节点是根节点
    if(node->val > root->val) root->right = Adjust(root->right,node);
    if(node->val < root->val) root->left = Adjust(root->left,node);
    root->height = setHeight(root);  // 更新所有祖先节点的高度，下面代码是找到最近的不平衡的节点
    if(getHeight(root->left) - getHeight(root->right) == 2){  // LL or LR
        if(getHeight(root->left->left) < getHeight(root->left->right))
            root->left = leftRotation(root->left);  // LR->LL
        root = rightRotation(root);  // LL
    }else if(getHeight(root->left) - getHeight(root->right) == -2){  // RR or RL
        if(getHeight(root->right->right) < getHeight(root->right->left))  
            root->right = rightRotation(root->right);  // RL->RR
        root = leftRotation(root);  // RR
    }
    return root;
}
```



### 节点的插入

**三种情况**

```c++
TreeNode* Ainsert(TreeNode* root,TreeNode* node){
    if(root==NULL) return node;
    if(node->val > root->val) root->right = Ainsert(root->right,node);
    if(node->val < root->val) root->left = Ainsert(root->left,node);
    return root;
}
TreeNode* insert(TreeNode* root,int _val){
    TreeNode* node = new TreeNode(_val);
    return Adjust(Ainsert(root,node),node); 
}
```



### 节点的删除

**分为四种情况：**叶子节点，有左子树而无右子树，有右子树而无左子树，既有左子树也有右子树

```c++
TreeNode* Aerase(TreeNode* root,int _val){
    if(root->val > _val) root->left = Aerase(root->left,_val);
    else if(root->val < _val) root->right = Aerase(root->right,_val);
    else{
        if(root->left==NULL) return root->right;
        if(root->right==NULL) return root->left;
        TreeNode* node = root->left;
        TreeNode* pre = root;
        while(node->right){
            pre = node;
            node = node->right;
        }
        root->val = node->val;
        if(pre->right->val==node->val) pre->right = node->left;
        else pre->left = node->left; 
    }
    return root;
}
TreeNode* erase(TreeNode* root,int _val){
    TreeNode* father = findFather(root,_val);
    return Adjust(Aerase(root,_val),father);
}
```



### 简易版本

```c++
#include <bits/stdc++.h>
using namespace std;

typedef struct TreeNode{ 
    int val,height;
    TreeNode* lc;
    TreeNode* rc;
    TreeNode(int _val=0):val(_val),height(1),lc(NULL),rc(NULL){};
}*BinTree;

int setHeight(TreeNode* root){
    if(root==NULL) return 0;
    return max(setHeight(root->lc),setHeight(root->rc))+1;
}
TreeNode* findFather(TreeNode* root,int val){
    if(root==NULL) return NULL;
    else if(root->lc && root->lc->val == val) return root;
    else if(root->rc && root->rc->val == val) return root;
    if(root->val > val) return findFather(root->lc,val);
    else if(root->val < val) return findFather(root->rc,val);
    return NULL;
}
int Height(TreeNode* root){
    if(root == NULL) return 0;
    return root->height;
}
TreeNode* leftRotation(TreeNode* A){
    TreeNode* C = A->rc;
    A->rc = C->lc;
    C->lc = A;
    C->height = setHeight(C);
    A->height = setHeight(A);
    return C;
}
TreeNode* rightRotation(TreeNode* A){
    TreeNode* B = A->lc;
    A->lc = B->rc;
    B->rc = A;
    B->height = setHeight(B);
    A->height = setHeight(A);
    return B;   
}
TreeNode* Adjust(TreeNode* root,TreeNode* node){  
    if(root == NULL) return root;
    if(root->val > node->val) root->lc = Adjust(root->lc,node);
    else if(root->val < node->val) root->rc = Adjust(root->rc,node);
    root->height = setHeight(root);
    if(Height(root->lc) - Height(root->rc) == 2){
        if(Height(root->lc->lc) < Height(root->lc->rc))
            root->lc = leftRotation(root->lc);
        root = rightRotation(root);
    }else if(Height(root->rc) - Height(root->lc) == 2){
        if(Height(root->rc->rc) < Height(root->rc->lc))
            root->rc = rightRotation(root->rc);
        root = leftRotation(root);
    }
    return root;
}
TreeNode* insert(TreeNode* root,int val){
    function<TreeNode*(TreeNode*,TreeNode*)> helper = [&helper](TreeNode* root,TreeNode* node){
        if(root==NULL) return node;
        else if(root->val >  node->val) root->lc = helper(root->lc,node);
        else if(root->val <= node->val) root->rc = helper(root->rc,node);
        return root;
    };
    TreeNode* node = new TreeNode(val);
    root = helper(root,node);
    root = Adjust(root,node);
    return root;
}
TreeNode* erase(TreeNode* root,int val){
    function<TreeNode*(TreeNode*,int)> helper = [&helper](TreeNode* root,int val)->TreeNode*{
        if(root==NULL) return NULL;
        else if(root->val >  val) root->lc = helper(root->lc,val);
        else if(root->val <= val) root->rc = helper(root->rc,val);
        else{
            if(root->lc == NULL) return root->rc;
            if(root->rc == NULL) return root->lc;
            TreeNode* pre = root;
            TreeNode* node = root->lc;
            while(node->rc != NULL){
                pre = node;
                node = node->rc;
            }
            if(pre->rc == node) pre->rc = node->lc;
            else pre->lc = node->lc;
        }
        return root;
    };
    TreeNode* father = findFather(root,val);
    root = helper(root,val);
    root = Adjust(root,father);
    return root;
}
int main(){
    int n;
    cin>>n;
    TreeNode* root=NULL;
    int temp;
    for(int i=0;i<n;++i){
        cin>>temp;
        root = insert(root,temp);
    }
    cout<<root->val<<endl;
    system("pause");
    return 0;
}

```



### 更优版本的实现

```c++
#include <iostream>
#include <ctime>
using namespace std;
class TreeNode
{
public:
    int val;
    int height;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int _val):val(_val),left(NULL),right(NULL){}  
    int getHeight(TreeNode* root);
    int setHeight(TreeNode* root);
    TreeNode* findFather(TreeNode* root,int _val);  // 返回val的父节点
    TreeNode* rightRotation(TreeNode* A);  // 返回根节点
    TreeNode* leftRotation(TreeNode* A);  // 返回根节点
    TreeNode* Adjust(TreeNode* root,TreeNode* node);  // // node为新插入的节点或删去节点的父节点，返回根节点
    TreeNode* Ainsert(TreeNode* root,TreeNode* node);  // 返回根节点
    TreeNode* insert(TreeNode* root,int _val);  // 返回根节点
    TreeNode* Aerase(TreeNode* root,int _val);  // 返回根节点
    TreeNode* erase(TreeNode* root,int _val);  // 返回根节点
    void preTravel(TreeNode* root);
};
int getHeight(TreeNode* root){
    if(root==NULL) return 0;
    return root->height;
}
int setHeight(TreeNode* root){
    if(root==NULL) return 0;
    int L = setHeight(root->left);
    int R = setHeight(root->right); 
    return max(L,R)+1; 
}
TreeNode* findFather(TreeNode* root,int _val){
    if(root==NULL) return NULL;
    else if(root->left && root->left->val==_val) return root;
    else if(root->right && root->right->val==_val) return root;
    if(root->val > _val) return findFather(root->left,_val);
    else if(root->val < _val) return findFather(root->right,_val);
    return NULL;
}
TreeNode* rightRotation(TreeNode* A){
    TreeNode* B = A->left;
    A->left = B->right;
    B->right = A;
    A->height = setHeight(A);
    B->height = setHeight(B);
    return B;
}
TreeNode* leftRotation(TreeNode* A){
    TreeNode* B = A->right;
    A->right = B->left;
    B->left = A;
    A->height = setHeight(A);
    B->height = setHeight(B);
    return B;
}
TreeNode* Adjust(TreeNode* root,TreeNode* node){// node是新加入的节点，或者删去节点的父节点
    if(node==NULL) return root;  // 删除节点是根节点
    if(node->val > root->val) root->right = Adjust(root->right,node);
    if(node->val < root->val) root->left = Adjust(root->left,node);
    root->height = setHeight(root);
    if(getHeight(root->left) - getHeight(root->right) == 2){  // LL or LR
        if(getHeight(root->left->left) < getHeight(root->left->right))
            root->left = leftRotation(root->left);  // LR->LL
        root = rightRotation(root);  // LL
    }else if(getHeight(root->left) - getHeight(root->right) == -2){  // RR or RL
        if(getHeight(root->right->right) < getHeight(root->right->left))  
            root->right = rightRotation(root->right);  // RL->RR
        root = leftRotation(root);  // RR
    }
    return root;
}
TreeNode* Ainsert(TreeNode* root,TreeNode* node){
    if(root==NULL){
        root = node;
        return root;
    }else if(root->val>node->val && root->left==NULL){
        root->left = node;
        return root;
    }else if(root->val<node->val && root->right==NULL){
        root->right = node;
        return root;
    }
    if(node->val > root->val) root->right = Ainsert(root->right,node);
    if(node->val < root->val) root->left = Ainsert(root->left,node);
    return root;
}
TreeNode* insert(TreeNode* root,int _val){
    TreeNode* node = new TreeNode(_val);
    return Adjust(Ainsert(root,node),node);
    
}
TreeNode* Aerase(TreeNode* root,int _val){
    if(root->val > _val) root->left = Aerase(root->left,_val);
    else if(root->val < _val) root->right = Aerase(root->right,_val);
    else{
        if(root->left==NULL) return root->right;
        if(root->right==NULL) return root->left;
        TreeNode* node = root->left;
        TreeNode* pre = root;
        while(node->right){
            pre = node;
            node = node->right;
        }
        root->val = node->val;
        if(pre->right->val==node->val) pre->right = node->left;
        else pre->left = node->left; 
    }
    return root;
}
TreeNode* erase(TreeNode* root,int _val){
    TreeNode* father = findFather(root,_val);
    return Adjust(Aerase(root,_val),father);
}
void preTravel(TreeNode* root){
    struct solution{
        int level=0;
        void preTravel_i(TreeNode* root){
            if(root==NULL){
                cout<<"* ";
                return;
            }
            cout<<root->val<<" ";
            preTravel_i(root->left);
            preTravel_i(root->right);
        }
    };
    solution s;
    s.preTravel_i(root);
    cout<<endl;
}
int main(){
    srand((unsigned)time(NULL));
    TreeNode* root=NULL;
    int n=0;

    for(int i=0;i<10;i++){
        root = insert(root,rand()%100+1);
    }
    preTravel(root);
    // for(int i=0;i<n;i++){
    //     root = erase(root,i);
    // }
    // preTravel(root);
    system("pause");
    return 0;
}
```

## 无旋Treap（HFQ Treap，分裂树）

**[P3369 【模板】普通平衡树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3369)**

```c++
#include <bits/stdc++.h>
#define lc(x) tr[x].lc
#define rc(x) tr[x].rc
#define val(x) tr[x].val
#define pri(x) tr[x].pri
#define siz(x) tr[x].siz
using namespace std;
const int N = 100001;
int idx , root , n ; 
struct node{int lc,rc,pri,val,siz;} tr[N] ;
int newnode(int val){tr[++idx] = {0,0,rand(),val,1};return idx;}
void pushup(int p) {tr[p].siz = tr[lc(p)].siz + tr[rc(p)].siz + 1;}
void spilt(int p,int& x,int& y,int val){
    if(!p) {x = y = 0 ; return ;}
    if(val(p) <= val){
        x = p ; spilt(rc(x),rc(x),y,val) ; pushup(x) ; return ;
    } else {
        y = p ; spilt(lc(y),x,lc(y),val) ; pushup(y) ; return ; 
    }
}
int merge(int x,int y){
    if(!x || !y) return x + y ;
    if(pri(x) > pri(y)) {
        rc(x) = merge(rc(x),y) ; pushup(x) ; return x ;
    } else {
        lc(y) = merge(x,lc(y)) ; pushup(y) ; return y ;
    }
}
void insert(int val){
    int x , y , z ; z = newnode(val) ;
    spilt(root , x , y , val) ;
    root = merge(merge(x,z),y) ;
}
void del(int val){
    int x , y , z ; 
    spilt(root , x , z , val) ; spilt(x , x , y , val-1) ;
    y = merge(lc(y),rc(y)) ; root = merge(merge(x,y),z) ;
}
int get_k(int p , int k){
    if(!p) return 0 ;
    if(k <= siz(lc(p))) return get_k(lc(p),k) ;
    if(k == siz(lc(p)) + 1) return p ;
    return get_k(rc(p),k - siz(lc(p)) - 1) ;
}
int get_pre(int val){
    int x , y ; 
    spilt(root , x , y , val-1) ;
    int  p = get_k(x,siz(x)) ; if(!p) cout << "不存在前驱" << endl ;
    int val_t = val(p) ; root = merge(x,y) ; return val_t ;
}
int get_nex(int val){
    int x , y ; 
    spilt(root , x , y , val) ;
    int  p = get_k(y,1) ; if(!p) cout << "不存在后继" << endl ;
    int val_t = val(p) ; root = merge(x,y) ; return val_t ;
}
int get_rank(int val){
    int x , y ; spilt(root,x,y,val-1) ;
    int rank_t = siz(x) + 1 ; root = merge(x,y) ; return rank_t ;
}
int get_val(int rank){
    int p = get_k(root , rank) ; return val(p) ;
}
int size() {
    return siz(root) ;
}
int main() {
	cin>>n;
 	while(n--){
		int op,key;
		cin>>op>>key;
		if(op==1){
			insert(key);
		}else if(op==2){
			del(key);
		}else if(op==3){
			cout<<get_rank(key)<<endl;
		}else if(op==4){
			cout<<get_val(key)<<endl;
		}else if(op==5){
			cout<<get_pre(key)<<endl;
		}else if(op==6){
			cout<<get_nex(key)<<endl;
		}
	}
	system("pause");
	return 0;
}
```

## Splay树

**模板题目：[P3369 【模板】普通平衡树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3369)**

```C++
#include <bits/stdc++.h>
#define lc(x) tr[x].s[0]
#define rc(x) tr[x].s[1]
#define size(x) tr[x].size
#define par(x) tr[x].p
#define val(x) tr[x].v
#define cnt(x) tr[x].cnt
using namespace std;
const int N = 1e5+1;
const int inf = 1e9;
struct node {
    int s[2];
    int p,v,cnt,size;
} tr[N];
int root,idx;
void pushup(int x){
    size(x) = size(lc(x)) + size(rc(x)) + cnt(x) ;
}
void rotate(int x){
    int y = par(x), z = par(y);
    int k = rc(y) == x;
    tr[y].s[k] = tr[x].s[k^1]; par(tr[x].s[k^1]) = y;
    tr[x].s[k^1] = y ; par(y) = x;
    tr[z].s[tr[z].s[1]==y] = x; par(x) = z;
    pushup(x);pushup(y);
}
// 直线型先转y再转x，折线形转两次x
void splay(int x,int k){  // 旋转到k下面 
    while(par(x) != k) {
        int y = par(x),z = par(y);
        if(z != k) 
            (lc(y)==x)^(lc(z)==y) ? rotate(x) : rotate(y) ;
        rotate(x);
    }
    if(k==0) root = x;
}
void find(int v){  // 找到v的节点，并旋转在根
    int x = root;
    while(tr[x].s[v > val(x)] && v != val(x)) {
        x = tr[x].s[v > val(x)];
    }
    splay(x,0);
}
int getpre(int v){ // 返回编号
    find(v);
    int x = root;
    if(val(x) < v) return x;
    x = lc(x);
    while(rc(x)) x = rc(x);
    return x;
}
int getsuc(int v){  // 返回编号
    find(v);
    int x = root;
    if(val(x) > v) return x;
    x = rc(x);
    while(lc(x)) x = lc(x);
    return x;
}
void del(int v){
    int pre = getpre(v);
    int suc = getsuc(v);
    splay(pre,0);splay(suc,pre);
    int del = lc(suc);
    if(cnt(del) > 1) cnt(del)-- , splay(del,0);
    else lc(suc) = 0,splay(suc,0);
}
void insert(int v){
    int x = root;
    while(tr[x].s[v > val(x)] && v != val(x)){
        x = tr[x].s[v > val(x)];
    }
    if(v == val(x)) cnt(x)++ ,splay(x,0);
    else {
        tr[x].s[v > val(x)] = ++idx;
        val(idx) = v ;par(idx) = x; cnt(idx) = size(idx) = 1 ;
        splay(idx,0);
    }
}
int getrank(int v){  // 有两个哨兵的存在
    find(v);
    return size(lc(root));
}
int getval(int r){
    int x = root;
    while(true){
        if(size(lc(x)) + cnt(x) < r){
            r -= size(lc(x)) + cnt(x);
            x = rc(x);
        } else {
            if(size(lc(x)) >= r) x = lc(x);
            else break;
        }
    }
    splay(x,0);
    return val(x);
}
int main(){
    insert(inf);insert(-inf);
    int n,op,x;
    cin >> n ;
    while(n--) {
        cin >> op >> x;
        if(op==1) insert(x);
        else if(op==2) del(x);
        else if(op==3) cout << getrank(x) << endl ;
        else if(op==4) cout << getval(x+1) << endl ;
        else if(op==5) cout << val(getpre(x)) << endl ;
        else if(op==6) cout << val(getsuc(x)) << endl;
    }
    system("pause");
}
```

## STL骚做法（时间还tm这么快）

**模板题目：[P3369 【模板】普通平衡树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3369)**

```c++
#include <bits/stdc++.h>
#define be v.begin()
#define en v.end()
using namespace std ;
/*------------------分割线-----------------*/
// lower_bound 查找大于等于x的第一个元素
// upper_bound 查找大于x的第一个元素
vector<int> v ;
void insert(int val){
    v.insert(upper_bound(be,en,val),val) ;
}
void del(int val){
    v.erase(lower_bound(be,en,val)) ;
}
int get_rank(int val){
    return lower_bound(be,en,val) - be + 1 ;
}
int get_val(int k){
    return v[k-1] ;
}
int get_pre(int val){
    return *--lower_bound(be,en,val) ;
}
int get_nex(int val){
    return *upper_bound(be,en,val) ;
}
/*------------------分割线-----------------*/
int main(){
    int n, op, val; cin >> n;
    while (n--) {
        cin >> op >> val;
        switch (op) {
        case (1): insert(val) ; break ;
        case (2): del(val) ; break ;
        case (3): cout << get_rank(val) << endl ; break ;
        case (4): cout << get_val(val) << endl ; break ;
        case (5): cout << get_pre(val) << endl ; break ;
        case (6): cout << get_nex(val) << endl ; break ;
        }
    }
    system("pause") ;
}
```



## 可持久化平衡树

**模板题目：[P3835 【模板】可持久化平衡树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3835)**

```c++
#include <bits/stdc++.h>
#define lc(x) tr[x].ch[0]
#define rc(x) tr[x].ch[1]
#define val(x) tr[x].val
#define pri(x) tr[x].priority
#define siz(x) tr[x].size
using namespace std;
const int inf = 0x7fffffff;
const int N = 5e5+1;
struct node{
    int ch[2];
    int priority;
    int val;
    int size;
}tr[N*50];
int root[N],idx;
void newnode(int &x,int v){
    x = ++idx;
    val(x) = v;
    siz(x) = 1;
    pri(x) = rand();
}
void pushup(int p) {
    siz(p) = siz(lc(p)) + siz(rc(p)) + 1;
}
// 唯一变化就是spilt需要开新点
void spilt(int p,int v,int &x,int &y){
    if(!p) {x=y=0;return;}
    if(val(p) <= v) {
        x = ++idx; tr[x] = tr[p] ;
        spilt(rc(x),v,rc(x),y);
        pushup(x);
    } else {
        y = ++idx; tr[y] = tr[p];
        spilt(lc(y),v,x,lc(y));
        pushup(y);
    }
}
int merge(int x,int y){
    if(!x || !y) return x+y;
    if(pri(x) < pri(y)) {
        rc(x) = merge(rc(x),y);
        pushup(x);return x;
    } else {
        lc(y) = merge(x,lc(y));
        pushup(y);return y;
    }
}
void insert(int& root,int v){
    int x,y,z;
    newnode(z,v);
    spilt(root,v,x,y);
    root = merge(merge(x,z),y);
}
void del(int& root,int v){
    int x,y,z;
    spilt(root,v,x,y);
    spilt(x,v-1,x,z);
    z = merge(lc(z),rc(z));
    root = merge(merge(x,z),y);
}
int getrank(int& root,int v){
    int x,y;
    spilt(root,v-1,x,y);
    int rank = siz(x) + 1;
    root = merge(x,y);
    return rank;
}
int getval(int &root,int r){
    if(r == siz(lc(root))+1 ) return val(root);
    else if(r <= siz(lc(root)) ) return getval(lc(root),r);
    else return getval(rc(root),r-siz(lc(root))-1);
}
int getpre(int &root,int v){
    int x,y,ans;
    spilt(root,v-1,x,y);
    if(!x) return -inf;
    ans = getval(x,siz(x));
    root = merge(x,y);
    return ans;
}
int getnex(int &root,int v){
    int x,y,ans;
    spilt(root,v,x,y);
    if(!y) return inf;
    ans = getval(y,1);
    root = merge(x,y);
    return ans;
}
int main(){
  int n,ver,op,v;
  scanf("%d",&n);
  for(int i=1;i<=n;++i){
    scanf("%d%d%d",&ver,&op,&v);
    root[i]=root[ver];
    if(op==1)insert(root[i],v);
    else if(op==2)del(root[i],v);
    else if(op==3)printf("%d\n",getrank(root[i],v));
    else if(op==4)printf("%d\n",getval(root[i],v));
    else if(op==5)printf("%d\n",getpre(root[i],v));
    else printf("%d\n",getnex(root[i],v));
  }
  system("pause");
}
```

## 文艺平衡树

**模板题目：[P3391 【模板】文艺平衡树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3391)**

```c++
// Splay树版本
#include <bits/stdc++.h>
#define lc(x) tr[x].s[0]
#define rc(x) tr[x].s[1]
#define size(x) tr[x].size
#define par(x) tr[x].p
#define val(x) tr[x].v
#define cnt(x) tr[x].cnt
#define lz(x) tr[x].lz

using namespace std;
const int N = 1e5+1,inf = 1e9 ;

struct node{
    int s[2];
    int p,v,cnt,size,lz;
} tr[N] ;
int root,idx;

int n,m;

void pushdown(int x){
    if(!lz(x)) return ;
    swap(lc(x),rc(x));
    lz(lc(x)) ^= 1;
    lz(rc(x)) ^= 1;
    lz(x) = 0;
}
void pushup(int x){
    size(x) = size(lc(x)) + size(rc(x)) + cnt(x) ; 
}
void rotate(int x){
    int y = par(x); int z = par(y) ;
    pushdown(y);pushdown(x);
    int k = rc(y) == x ;  // k = 1 
    tr[y].s[k] = tr[x].s[k^1] ; par(tr[x].s[k^1]) = y;
    tr[x].s[k^1] = y ; par(y) = x;
    tr[z].s[y == rc(z)] = x; par(x) = z;
    pushup(y);pushup(x); 
}
void splay(int x,int k){
    while(par(x) != k) {
        int y = par(x); int z = par(y);
        if(z != k) 
            (lc(y)==x)^(lc(z)==y) ? rotate(x):rotate(y);
        rotate(x);
    }
    if(k==0) root = x;
}
void insert(int v) {
    int x = root ;
    while(tr[x].s[v > val(x)] && v != val(x)) 
        x = tr[x].s[v > val(x)];
    if(v == val(x)) cnt(x)++, splay(x,0);
    else {
        tr[x].s[v > val(x)] = ++idx;
        par(idx)=x;val(idx)=v;size(idx)=cnt(idx)=1;
        splay(idx,0);
    }
}
int get_k(int r){
    int x = root;
    while(true){
        pushdown(x);
        if(size(lc(x)) + cnt(x) < r){
            r -= size(lc(x)) + cnt(x);
            x = rc(x);
        } else if(size(lc(x)) >= r) x = lc(x);
        else return x;
    }
}
void output(int x){
    pushdown(x);
    if(lc(x)) output(lc(x));
    if(val(x) > -inf && val(x) < inf) cout << val(x) << " ";
    if(rc(x)) output(rc(x));
}
signed main(){
    insert(-inf);insert(inf);
    //ios::sync_with_stdio(false);cin.tie(nullptr);
    cin >> n >> m ;
    for(int i=1;i<=n;++i) insert(i) ;
    while(m--){
        int l,r;
        cin >> l >> r ;
        l = get_k(l); 
        r = get_k(r+2) ;
        splay(l,0);
        splay(r,l);
        lz(lc(r)) ^= 1;
    } 
    output(root) ;
    system("pause");
}
```

```c++
// FHQ Treap
#include <bits/stdc++.h>
#define int long long 
#define lc(x) tr[x].s[0]
#define rc(x) tr[x].s[1]
#define size(x) tr[x].size
#define val(x) tr[x].val
#define pri(x) tr[x].priority
#define lz(x) tr[x].lz
using namespace std;
const int N = 1e5+1,inf = 1e18;
struct node{
    int s[2],val,priority,size,lz;
} tr[N] ;
int root,idx,n,m;
void pushup(int x){
    size(x) = size(lc(x)) + size(rc(x)) + 1;
}
void pushdown(int x){
    if(!lz(x)) return;
    swap(lc(x),rc(x));
    lz(lc(x)) ^= 1;
    lz(rc(x)) ^= 1;
    lz(x) = 0;
}
int newnode(int v){
    ++idx;
    size(idx)=1;pri(idx)=rand();val(idx)=v;
    return idx;
}
void spilt(int p,int k,int &x,int &y){
    if(!p){x=y=0;return;}
    pushdown(p);
    if(size(lc(p)) + 1 <= k){
        x = p ;
        spilt(rc(x),k - size(lc(p)) - 1,rc(x),y);
    } else {
        y = p;
        spilt(lc(y),k,x,lc(y));
    }
    pushup(p);
}
int merge(int x,int y){
    if(!x || !y) return x+y;
    if(pri(x) < pri(y)) {
        pushdown(x);
        rc(x) = merge(rc(x),y);
        pushup(x);return x;
    }else{
        pushdown(y);
        lc(y) = merge(x,lc(y));
        pushup(y);return y;
    }
}
void output(int x){
    if(!x) return;
    pushdown(x);
    output(lc(x));
    cout << val(x) << " " ;
    output(rc(x));
    pushup(x);
}
signed main(){
    cin >> n >> m ;
    for(int i=1;i<=n;++i) root = merge(root,newnode(i)) ;
    while(m--){
        int l,r;
        cin >> l >> r ;
        int x,y,z;
        spilt(root,r,x,y);
        spilt(x,l-1,x,z);
        lz(z) ^= 1;
        root = merge(merge(x,z),y);
    } 
    output(root) ;
    system("pause");
}
```

## 树套树（二逼平衡树）

**题目：[P3380 【模板】二逼平衡树（树套树） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3380)**

```c++
#include <bits/stdc++.h>
#define lc(x) tr[x].ch[0]
#define rc(x) tr[x].ch[1]
#define val(x) tr[x].val
#define pri(x) tr[x].pri
#define siz(x) tr[x].siz
#define ls (p << 1)
#define rs (p << 1 | 1)
using namespace std ;
const int N = 5e4+10 , inf = INT_MAX ;
int nums[N] , n , m ;
namespace Treap{
    struct node{int ch[2],siz,pri,val;} tr[N*40] ;
    int root[N << 2] , idx ;  // 计数平衡树
    inline void pushup(int p){tr[p].siz = tr[lc(p)].siz + tr[rc(p)].siz + 1 ;}
    inline void spilt(int p,int& x,int& y,int val){
        if(!p) {x = y = 0 ; return ;}
        if(tr[p].val <= val) {
            x = p ; spilt(rc(x),rc(x),y,val) ; pushup(x) ; return ;
        } else {
            y = p ; spilt(lc(y),x,lc(y),val) ; pushup(y) ; return ;
        }
    }
    inline int merge(int x,int y){
        if(!x || !y) return x + y ;
        if(tr[x].pri > tr[y].pri) {
            rc(x) = merge(rc(x),y) ; pushup(x) ; return x ;
        } else {
            lc(y) = merge(x,lc(y)) ; pushup(y) ; return y ;
        }
    }
    inline void insert(int& root,int val){
        int x , y , z ; tr[++idx] = {0,0,1,rand(),val} ; z = idx ;
        spilt(root , x , y , val) ; 
        root = merge(merge(x , z) , y) ;
    }
    inline void del(int& root,int val){
        int x , y , z ;
        spilt(root , x , y , val) ; spilt(x , x , z , val-1) ;
        z = merge(lc(z),rc(z)) ; root = merge(merge(x , z) , y) ;
    }
    inline int get_k(int p , int k){
        if(!p) return 0 ;
        if(k <= siz(lc(p))) return get_k(lc(p),k) ;
        if(k == siz(lc(p)) + 1) return p ;
        return get_k(rc(p),k - siz(lc(p)) - 1) ;
    }
    inline int get_pre(int& root,int val){
        int x , y , val_t ; 
        spilt(root , x , y , val-1) ;
        int p = get_k(x,siz(x)) ; 
        val_t = val(p) ;
        if(!p) val_t = -inf ;
        root = merge(x,y) ; return val_t ;
    }
    inline int get_nex(int& root,int val){
        int x , y , val_t; 
        spilt(root , x , y , val) ;
        int p = get_k(y,1) ; 
        val_t = val(p) ;
        if(!p) val_t = inf ;
        root = merge(x,y) ; return val_t ;
    }
    inline int get_rank(int& root,int val){
        int x , y ; spilt(root,x,y,val-1) ;
        int rank_t = siz(x) + 1 ; root = merge(x,y) ; return rank_t ;
    }
    inline int get_val(int& root,int rank){
        int p = get_k(root , rank) ; return val(p) ;
    }
}
namespace Seg{
    struct node{int l,r;} tr[N << 2] ;
    inline void build(int p,int l,int r){  // build(1,1,n) ;
        tr[p] = {l,r} ; for(int i=l;i<=r;++i) Treap::insert(Treap::root[p],nums[i]);
        if(l == r) return ;
        int m = l + r >> 1 ;
        build(ls , l , m) ; build(rs , m + 1 , r) ; 
    }
    inline int get_rank(int p,int x,int y,int val){  // get_rank(1,x,y,val) + 1
        if(x <= tr[p].l && y >= tr[p].r) return Treap::get_rank(Treap::root[p],val) - 1;
        int m = tr[p].l + tr[p].r >> 1 ; int res = 0 ;
        if(x <= m) res += get_rank(ls,x,y,val) ;
        if(y > m) res += get_rank(rs,x,y,val) ;
        return res ;
    }
    inline int get_val(int p,int x,int y,int rank){  // get_val(1,x,y,rank)
        int l = 0 , r = 1e8 , ans ;
        while(l <= r){
            int m = l + r >> 1 ;
            if(rank >= get_rank(1,x,y,m) + 1) l = m +1 , ans = m ;
            else r = m - 1 ;
        } 
        return ans ;
    }
    inline void modify(int p,int pos,int val){  // modify(1,pos,val) , nums[pos] = val ;
        Treap::del(Treap::root[p],nums[pos]) ; Treap::insert(Treap::root[p],val) ;
        if(tr[p].l == tr[p].r) return ;
        int m = tr[p].l + tr[p].r >> 1 ;
        if(pos <= m) modify(ls,pos,val) ;
        else modify(rs,pos,val) ;
    }
    inline int get_pre(int p,int x,int y,int val){  // get_pre(1,x,y,val)
        if(x <= tr[p].l && y >= tr[p].r) return Treap::get_pre(Treap::root[p],val);
        int m = tr[p].l + tr[p].r >> 1 , res = -inf;
        if(x <= m) res = max(res , get_pre(ls,x,y,val)) ;
        if(y > m) res = max(res , get_pre(rs,x,y,val)) ;
        return res ;
    }
    inline int get_nex(int p,int x,int y,int val){  // get_nex(1,x,y,val)
        if(x <= tr[p].l && y >= tr[p].r) return Treap::get_nex(Treap::root[p],val);
        int m = tr[p].l + tr[p].r >> 1 , res = inf;
        if(x <= m) res = min(res , get_nex(ls,x,y,val)) ;
        if(y > m) res = min(res , get_nex(rs,x,y,val)) ;
        return res ;
    }
}
int main(){
    cin >> n >> m ; 
    for(int i=1;i<=n;++i) scanf("%d",&nums[i]) ; Seg::build(1,1,n) ;
    int op , x , y , z ;
    while(m--){
        scanf("%d",&op) ;
        switch(op){
            case 1 :
                scanf("%d%d%d",&x,&y,&z) ;
                printf("%d\n",Seg::get_rank(1,x,y,z) + 1) ;
                break ;
            case 2 :
                scanf("%d%d%d",&x,&y,&z) ;
                printf("%d\n",Seg::get_val(1,x,y,z)) ;
                break ;
            case 3 :
                scanf("%d%d",&x,&y) ;
                Seg::modify(1,x,y) ; nums[x] = y ;
                break ;
            case 4 :
                scanf("%d%d%d",&x,&y,&z) ;
                printf("%d\n",Seg::get_pre(1,x,y,z)) ;
                break ;
            case 5 :
                scanf("%d%d%d",&x,&y,&z) ;
                printf("%d\n",Seg::get_nex(1,x,y,z)) ;
                break ;
        }
    }
    system("pause") ;
}
```



# 堆

**模板题：[P3378 【模板】堆 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3378)**

```c++
#include <bits/stdc++.h>
#define int long long
#define lc (p<<1)
#define rc (p<<1|1)
#define fa (x>>1)
using namespace std ; 
const int N = 1e6+10 ;
int data[N] , tail ; 
void pushdown(int p){
    while(lc <= tail){
        if(rc <= tail && data[rc] < data[p] && data[rc] <= data[lc]) swap(data[rc] , data[p]) , p = rc ;
        else if(data[lc] < data[p] && data[lc] <= data[rc]) swap(data[lc],data[p]) , p = lc;
        else break ;
    }
}
void pushup(int x){
    while(fa && data[fa] > data[x]) swap(data[fa],data[x]) , x = fa ; 
}
void push(int val){
    data[++tail] = val ;
    pushup(tail) ; 
}
void pop(){
    if(tail) data[1] = data[tail--] , pushdown(1) ;
}
int top(){
    return data[1] ;
}
signed main(){
    int n , op , x ; cin >> n ; while(n--){
        cin >> op ; 
        if(op == 1) cin >> x , push(x) ;
        else if(op == 2) cout << top() << endl ;
        else pop() ;
    }
    system("pause") ;
}
```



## 理论知识

**堆的物理结构是数组，虚幻结构是一颗完全二叉树**

**最大堆：**父节点的值大于等于子节点的值，根节点是最大值。

**最小堆：**父节点的值小于等于子节点的值，根节点是最小值。

**完全二叉树：**一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。

**完全二叉树性质：**

1. 若父节点为i，则左孩子为2i，右孩子为2i+1。
2. 若子节点为i，则父节点为⌊i/2⌋。
3. N0 =  N2 + 1 ，叶子数 = 出度为2的数量 + 1
4. 层数：⌊log2(i)⌋。底数为2 真数为i，根节点层数为0。

## 简易版本

```c++
#include <bits/stdc++.h>
#define int long long
#define lc (p<<1)
#define rc (p<<1|1)
#define fa (x>>1)
using namespace std ; 
const int N = 1e6+10 ;
int data[N] , tail ; 
void pushdown(int p){
    while(lc <= tail){
        if(rc <= tail && data[rc] < data[p] && data[rc] <= data[lc]) swap(data[rc] , data[p]) , p = rc ;
        else if(data[lc] < data[p] && data[lc] <= data[rc]) swap(data[lc],data[p]) , p = lc;
        else break ;
    }
}
void pushup(int x){
    while(fa && data[fa] > data[x]) swap(data[fa],data[x]) , x = fa ; 
}
void push(int val){
    data[++tail] = val ;
    pushup(tail) ; 
}
void pop(){
    if(tail) data[1] = data[tail--] , pushdown(1) ;
}
int top(){
    return data[1] ;
}
signed main(){
    int n , op , x ; cin >> n ; while(n--){
        cin >> op ; 
        if(op == 1) cin >> x , push(x) ;
        else if(op == 2) cout << top() << endl ;
        else pop() ;
    }
    system("pause") ;
}
```



## siftdown 的更广泛写法

**函数siftdown假设`heap[s+1..m] `已经是堆，将`heap[s..m] `调整为以`heap[s] `为根的大根堆。**

```c++
void siftdown(int s,int m){  // 最小值下沉
    int parent=s;
    int child=2*parent;  //左孩子
    while(child<=m){
        if(child+1<=m&&val[child]<val[child+1]){
            child++;  // 右孩子
        }
        if(val[parent]<val[child]){
            int key  = val[parent];
            val[parent]=val[child];
            val[child]=key;
            parent=child;
        }
        child=child*2;
    }
}
```



## **最大堆**

```c++
class maxHeap{
public:
    int tail;  // 尾指针，指向最后一个元素的下标
    int* val;  // 数据数组
    int capacity;
protected:
    void siftup(int p);  // 最大值上升
    void siftdown(int p);  // 最小值下降
public:
    maxHeap(int DEFAULTSIZE=100);
    maxHeap(int* arr,int n);
    ~maxHeap();
    void AdjustToMaxHeap();  // 第二种方法调整成为最大堆
    void insert(int _val);  // 插入一个元素
    void erase();  // 删除堆顶元素
    int getTop();  // 取出堆顶的元素，最大值
};
maxHeap::maxHeap(int DEFAULTSIZE){
    tail = 0;  // 0代表堆空
    capacity = DEFAULTSIZE;
    val = new int[DEFAULTSIZE+1]{0};  // 开辟堆空间,1~maxsie
}
maxHeap::maxHeap(int* arr,int n){
    tail = n;
    capacity = n+1;
    val = new int[n+1];
    memcpy(val+1,arr,sizeof(int)*n);
    heap.AdjustToMaxHeap();
}
maxHeap::~maxHeap(){
    if(val!=NULL){
        delete[] val;
        val = NULL;
    }
}
void maxHeap::siftup(int p){
    while(p>1){
        if(val[p]>val[p/2]){
            swap(val[p],val[p/2]);
            p = p/2;
        }else break;
    }
}
void maxHeap::siftdown(int p){
    while((2*p+1)<=tail){
        if(val[p]<val[2*p+1] && val[2*p]<=val[2*p+1]){
            swap(val[p],val[2*p+1]);
            p = 2*p+1;
        }else if(val[p]<val[2*p] && val[2*p]>=val[2*p+1]){
            swap(val[p],val[2*p]);
            p = 2*p;
        }else break;
    }
    if(2*p<=tail && val[p]<val[2*p]){
        swap(val[p],val[2*p]);
        p = 2*p;
    }
}  
void maxHeap::AdjustToMaxHeap(){
    for(int p=tail/2;p>0;p--) siftdown(p);
}
void maxHeap::insert(int _val){
    if(tail >= capacity) return;  // 堆满返回
    val[++tail] = _val;
    siftup(tail);
}
void maxHeap::erase(){
    if(tail == 0) return;  // 堆空返回
    val[1] = val[tail--];
    siftdown(1);
} 
int maxHeap::getTop(){
    if(tail == 0) exit(0);  // 堆空报错
    return val[1];
}
```



## 最小堆

```c++
class minHeap{
public:
    int tail;  // 尾指针，指向最后一个元素的下标
    int* val;  // 数据数组
    int capacity;
protected:
    void siftup(int p);  // 最小值上升
    void siftdown(int p);  // 最大值下降
public:
    minHeap(int DEFAULTSIZE=100);
    minHeap(int* arr,int n);
    ~minHeap();
    void AdjustToMinHeap();  // 第二种方法调整成为最小堆
    void insert(int _val);  // 插入一个元素
    void erase();  // 删除堆顶元素
    int getTop();  // 取出堆顶的元素，最小值
};
minHeap::minHeap(int DEFAULTSIZE){
    tail = 0;  // 0代表堆空
    capacity = DEFAULTSIZE;
    val = new int[DEFAULTSIZE+1]{0};  // 开辟堆空间,1~maxsie
}
minHeap::minHeap(int* arr,int n){
    tail = n;
    capacity = n+1;
    val = new int[n+1];
    memcpy(val+1,arr,sizeof(int)*n);
    this->AdjustToMinHeap();
}
minHeap::~minHeap(){
    if(val!=NULL){
        delete[] val;
        val = NULL;
    }
}
void minHeap::siftup(int p){
    while(p>1){
        if(val[p]<val[p/2]){
            swap(val[p],val[p/2]);
            p = p/2;
        }else break;
    }
}
void minHeap::siftdown(int p){
    while((2*p+1)<=tail){
        if(val[p]>val[2*p+1] && val[2*p]>=val[2*p+1]){
            swap(val[p],val[2*p+1]);
            p = 2*p+1;
        }else if(val[p]>val[2*p] && val[2*p]<=val[2*p+1]){
            swap(val[p],val[2*p]);
            p = 2*p;
        }else break;
    }
    if(2*p<=tail && val[p]>val[2*p]){
        swap(val[p],val[2*p]);
        p = 2*p;
    }
}  
void minHeap::insert(int _val){
    if(tail >= capacity) return;  // 堆满返回
    val[++tail] = _val;
    siftup(tail);
}
void minHeap::erase(){
    if(tail == 0) return;  // 堆空返回
    val[1] = val[tail--];
    siftdown(1);
} 
int minHeap::getTop(){
    if(tail == 0) exit(0);  // 堆空报错
    return val[1];
}
void minHeap::AdjustToMinHeap(){
    for(int p=tail/2;p>0;p--) siftdown(p);
}
```



## 堆的应用

### 合并n个升序或降序序列

![屏幕截图 2022-11-02 183153](初学上课笔记.assets\屏幕截图 2022-11-02 183153.png)

**方法一：**顺序合并（两两合并）

​		可以用哈夫曼树进行优化

**方法二：**同步合并

![屏幕截图 2022-11-02 183522](初学上课笔记.assets\屏幕截图 2022-11-02 183522.png)

### 堆排序

```c++
void HeapSort(int* arr,int n){  // 升序
    maxHeap heap(arr,n);
    int idx=n-1;
    int Max=0;
    for(int i=1;i<=n;i++){
        Max = heap.getTop();
        heap.erase();
        arr[idx--] = Max;
    }
}
void HeapSort(int* arr,int n){  // 降序
    minHeap heap(arr,n);
    int idx=n-1;
    int Min=0;
    for(int i=1;i<=n;i++){
        Min = heap.getTop();
        heap.erase();
        arr[idx--] = Min;
    }
}
```



### 装箱问题（Leetcode 1772）

![装箱问题](初学上课笔记.assets\装箱问题.png)

![屏幕截图 2022-11-02 114814](初学上课笔记.assets\屏幕截图 2022-11-02 114814.png)

![屏幕截图 2022-11-02 114940](初学上课笔记.assets\屏幕截图 2022-11-02 114940.png)



## 左偏树

**可以合并的堆**

**参考：**

[【算法学习】左偏树_pengwill97的博客-CSDN博客_左偏树](https://blog.csdn.net/pengwill97/article/details/82874235)

[(4条消息) 算法详解——左偏树_wang3312362136的博客-CSDN博客_左偏树](https://blog.csdn.net/wang3312362136/article/details/80615874)

1. 节点的左子节点的距离不小于右子节点的距离。
2. 节点的距离等于它的右子节点距离加一。

**例题：**

[P3377 【模板】左偏树（可并堆） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3377)

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+7;
const int inf = INT_MAX;
int rc[N],lc[N],dis[N],fa[N],val[N];
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
int merge(int x , int y){
    if(!x || !y) return x + y ;
    if(val[x] > val[y] || (val[x]==val[y] && x>y)) swap(x , y) ;
    rc[x] = merge(rc[x],y) ;
    if(dis[lc[x]] < dis[rc[x]]) swap(lc[x],rc[x]) ;
    dis[x] = dis[rc[x]] + 1 ;
    return x ;
}
void op1(int x,int y){
    if(val[x] == -inf || val[y] == -inf) return ;
    x = find(x) , y = find(y) ;
    if(x == y) return ;
    fa[x] = fa[y] = merge(x , y) ; 
}
void op2(int x){
    if(val[x] == -inf) {cout << -1 << endl;return;}
    x = find(x) ; cout << val[x] << endl ;
    fa[lc[x]] = fa[rc[x]] = fa[x] = merge(lc[x],rc[x]) ;
    val[x] = -inf ;
}
int main(){
    int n , m ; cin >> n >> m ; 
    for(int i=1;i<=n;++i) {cin>>val[i];fa[i]=i;}
    while(m--){
        int op ,x ,y ; cin >> op ;
        if(op == 1) cin >> x >> y , op1(x , y) ;
        else cin >> x , op2(x) ;
    }
}
```

# 树与森林

## 树的储存结构

### 1、双亲表示法

![屏幕截图 2022-10-05 125248](初学上课笔记.assets\屏幕截图 2022-10-05 125248.png)

```c++
template<class E>
struct Node{
    E val;
    int index;  // 双亲的下标
};

template<class E>
class TreeNode
{
template<class E1>friend ostream& operator<<(ostream& cout, const TreeNode<E1>& p);
private:
    Node<E>* root;  // 数组
    int v; // 节点数量
public:
    TreeNode(int _v):v(_v){
        root = new Node<E>[v];
    }
    ~TreeNode(){
        if(root != NULL){
            delete[] root;
            root = NULL;
        }
    }
    // 构造树
    void creatTree(){
        for(int i=0;i<v;i++){
            cin>>root[i].val>>root[i].index;
        }
    }
    
};
// 输出树的结构
template<class E>
ostream& operator<<(ostream& cout, const TreeNode<E>& p){
    cout<<"---------------------------------"<<endl;
    for(int i=0;i<p.v;i++){
        cout<<p.root[i].val<<"  "<<p.root[i].index<<endl;
    }
    cout<<"---------------------------------";
    return cout;
}
```



### 2、孩子链表(邻接链表)

![屏幕截图 2022-10-05 125544](初学上课笔记.assets\屏幕截图 2022-10-05 125544.png)

```c++
struct Child{
    int index;
    Child* next;
    Child():next(NULL){}
};
template<class E>
struct Node{
    E val;
  	Child* firstChild;
    Node():firstChild(NULL){}
};
template<class E>
class TreeNode{
private:
    Node<E>* root;
    int v;
public:
    TreeNode(int _v):v(_v){
        root = new Node<E>[v];
    }
    ~TreeNode(){
        if(root != NULL){
            delete [] root;
            root = NULL;
        }
    }
    void creatTree(){
        for(int i=0;i<v;i++){
            cout<<"键入第"<<i<<"个val:";
            cin>>root[i].val;
            cout<<"键入子节点下标，键入-1结束:";
            int temp;
            cin>>temp;
            Child * H = root[i].firstChild;
            while(temp != -1){
                H = new Child;
                H->index = temp;
                H = H->next;
                cin>>temp;
            }
        }
    }
};struct Child{
    int index;
    Child* next;
};
typedef struct Node{
    E val;
  	Child* firstChild;
} *TreeNodes;
```



### 3、孩子兄弟表示法

**实现：**用二叉链表实现，链表中的两个指针域分别指向第一个孩子的节点和下一个兄弟节点

![屏幕截图 2022-10-05 125920](初学上课笔记.assets\屏幕截图 2022-10-05 125920.png)



## 树与二叉树的转换

### 树转化成为二叉树

![屏幕截图 2022-10-05 130116](初学上课笔记.assets\屏幕截图 2022-10-05 130116.png)

### 二叉树转化为树

![屏幕截图 2022-10-05 130338](初学上课笔记.assets\屏幕截图 2022-10-05 130338.png)

## 森林与二叉树的转化

### 森林转化为二叉树

![屏幕截图 2022-10-05 130822](初学上课笔记.assets\屏幕截图 2022-10-05 130822.png)

### 二叉树转化为森林

![屏幕截图 2022-10-05 130935](初学上课笔记.assets\屏幕截图 2022-10-05 130935.png)

## 树与森林的遍历

### 树的遍历

![屏幕截图 2022-10-05 131324](初学上课笔记.assets\屏幕截图 2022-10-05 131324.png)

### 森林的遍历

#### 中序遍历

![屏幕截图 2022-10-05 133621](初学上课笔记.assets\屏幕截图 2022-10-05 133621.png)

#### 先序遍历

![屏幕截图 2022-10-05 133653](初学上课笔记.assets\屏幕截图 2022-10-05 133653.png)

# 哈夫曼树

## 基础知识

**树的路径长度（TL）：**跟到每个结点的路径长度之和。

> ​    完全二叉树是路径长度最短的。

**节点的带权路径长度：**根到节点的节点长度与该点的权的积。

**树的带权路径长度（WPL）：**树zhong所有叶子节点的带权路径长度之和。

**哈夫曼树：**WPL最短的树。

**引理1**：给定*W* = {*w*1, *w*2, *w*3...,*wn*} (*n* >= 2), 以此集合构建相应的哈夫曼树。令wi, wj 是W中权重最小的两个元素，则这两个数对应的结点是兄弟结点，且这两结点在二叉树中的深度不小于其它任何一个叶结点的深度。

**定理1：**哈夫曼树是最优的。

证明：用归纳法证明。

**基本情况:** 当 n=2 时, 哈夫曼树具有最小权重外部路径（WPL），因为树 仅有二种可能，有二个叶结点的二种哈夫曼树下的WPL是相同的。
**假设:** 设有哈夫曼树有 个叶子时，定理成立。
**推导:** 令T为有n （n>=2）个叶子的哈夫曼树。不失 一般性，设 w1 <= w2 <=... <=wn。令是w1 与w2的父结点。由引理1知, 在T中，不存在叶结点，其深度大于叶结点w1 与w2的深度。若存在深度大于w1, w2深度的结点，我们可以通过将之与w1, w2交换，由此得到更小的WPL。按如下方式得到到二叉树T'：以结点V'替换结点V, 其中V'的权重是w1+w2，则T'是相应于{w1+w2,w3,...,wn}的一棵哈夫曼树。根据归纳假设，T'具有最小权重外部路径，T是最优的（EPW最小）。在T'的结点V'上添加叶结点w1, w2，可得T，则T是具有最小权重外部路径的哈夫曼树。由此，我们由数学照片纳法证明了定理1. 

## 哈夫曼树的构造方法

![屏幕截图 2022-10-05 134439](初学上课笔记.assets\屏幕截图 2022-10-05 134439.png)

![屏幕截图 2022-10-05 134648](初学上课笔记.assets\屏幕截图 2022-10-05 134648.png)

## 哈夫曼树的应用（哈夫曼编码）

![屏幕截图 2022-10-05 135528](初学上课笔记.assets\屏幕截图 2022-10-05 135528.png)

## 哈夫曼编码

**代码实现：**

```c++
#include <bits/stdc++.h>
using namespace std;

struct HuffmanNode
{
    int weight;                        // 权重，出现的次数或者频率
    char ch;                           // 存储符号
    string code;                       // 存储该符号对应的编码
    int leftChild, rightChild, parent; // 左、右孩子，父结点
};

class HuffmanCode
{
public:
    HuffmanCode(string str);                          // 构造函数
    ~HuffmanCode();                                   // 析构函数
    void getMin(int &first, int &second, int parent); // 选取两个较小的元素
    void Merge(int first, int second, int parent);    // 合并
    void Encode();                                    // 编码:利用哈夫曼编码原理对数据进行加密
    void Decode(string str);                          // 解码
private:
    HuffmanNode *HuffmanTree; // 数组
    int leafSize;             // 统计不同字符的个数
};

// 构造函数
HuffmanCode::HuffmanCode(string str)
{
    int len = (int)str.size();          // 字符串的长度
    int arr[256], i;                    // 存储字符串各个字符的个数
    HuffmanTree = new HuffmanNode[256]; // 动态分配空间，最多128个字符，树的节点数最多255个

    // 1.初始化HuffmanTree数组
    for (i = 0; i < (2 * len - 1) && i<256; i++)   // 防止越界
    { // 叶子结点为len,则树最多有2*len-1个结点
        HuffmanTree[i].leftChild = HuffmanTree[i].rightChild = HuffmanTree[i].parent = -1;
        HuffmanTree[i].code = "";
    }

    // 2.统计输入的字符串的各个字符出现的个数
    memset(arr, 0, sizeof(arr)); // 清零
    for (i = 0; i < len; i++)    // 统计次数，下标是对应字符，arr[i]是对应字符出现的次数
        arr[str[i]]++;           // str[i] -> 转成对应的ASCII码，如'0'->48
    
    leafSize = 0;                // 出现不同字符的个数
    for (i = 0; i < 256; i++)
    {
        if (arr[i] != 0)
        { // 有出现的字符
            cout << "字符:" << (char)i << "次数为：" << arr[i] << endl;
            HuffmanTree[leafSize].ch = (char)i;    // 将数字转成对应的字符
            HuffmanTree[leafSize].weight = arr[i]; // 权重
            leafSize++;
        }
    }
    
    // 3.选取两个较小值合并
    int first, second; // 两个较小的结点
    for (i = leafSize; i < (2 * leafSize - 1); i++)
    {                             // 做leafSize-1趟
        getMin(first, second, i); // 选取两个较小的元素
        Merge(first, second, i);  // 合并
    }
}

// 析构函数
HuffmanCode::~HuffmanCode()
{
    delete[] HuffmanTree;
}

// 选取权值两个较小的元素
void HuffmanCode::getMin(int &first, int &second, int parent)
{
    double weight = 0;
    int i;

    // 找权重最小元素
    for (i = 0; i < parent; i++)
    {
        if (HuffmanTree[i].parent != -1) // 已选过，直接跳过
            continue;
        if (weight == 0)
        { // 第一次找到没选过的结点
            weight = HuffmanTree[i].weight;
            first = i;
        }
        else if (HuffmanTree[i].weight < weight)
        { // 权值更小
            weight = HuffmanTree[i].weight;
            first = i;
        }
    }
    // 找权重次小元素
    weight = 0;
    for (i = 0; i < parent; i++)
    {
        if (HuffmanTree[i].parent != -1 || i == first) // 已选过，直接跳过
            continue;
        if (weight == 0)
        { // 第一次找到没选过的结点
            weight = HuffmanTree[i].weight;
            second = i;
        }
        else if (HuffmanTree[i].weight < weight)
        { // 权值更小
            weight = HuffmanTree[i].weight;
            second = i;
        }
    }
}

// 合并
void HuffmanCode::Merge(int first, int second, int parent)
{
    HuffmanTree[first].parent = HuffmanTree[second].parent = parent;                     // 父结点
    HuffmanTree[parent].leftChild = first;                                               // 左孩子
    HuffmanTree[parent].rightChild = second;                                             // 右孩子
    HuffmanTree[parent].weight = HuffmanTree[first].weight + HuffmanTree[second].weight; // 权值
}

// 编码:利用哈夫曼编码原理对数据进行加密
void HuffmanCode::Encode()
{
    string code; // 存储符号的不定长二进制编码
    int i, j, k, parent;

    for (i = 0; i < leafSize; i++)
    { // 从叶子结点出发
        j = i;
        code = ""; // 初始化为空
        while (HuffmanTree[j].parent != -1)
        {                                           // 往上找到根结点
            parent = HuffmanTree[j].parent;         // 父结点
            if (j == HuffmanTree[parent].leftChild) // 如果是左孩子，则记为0
                code += "0";
            else // 右孩子，记为1
                code += "1";
            j = parent; // 上移到父结点
        }
        // 编码要倒过来：因为是从叶子往上走到根，而编码是要从根走到叶子结点
        reverse(begin(code),end(code));
        HuffmanTree[i].code = code;
        cout << "字符：" << HuffmanTree[i].ch << "的编码为：" << HuffmanTree[i].code << " ";
    }
}

// 解码
void HuffmanCode::Decode(string str)
{
    string decode, temp;       // decode保存整个解码, temp保存每一个解码
    int len = (int)str.size(); // 编码的长度
    int i, j;

    decode = temp = ""; // 初始化为空
    for (i = 0; i < len; i++)
    {
        temp += str[i]; // 加一个编码
        for (j = 0; j < leafSize; j++)
        {
            if (HuffmanTree[j].code == temp)
            {                                // 在叶子结点中找到对应的编码
                decode += HuffmanTree[j].ch; // 转成对应的字符
                temp = "";
                break;
            }
        }
        if (i == len - 1 && j == leafSize)
        { // 遍历完都没找到对应的编码
            cout << "解码出错！" << endl;
            return;
        }
    }
    cout << decode << endl;
}

int main()
{
    string str;

    cout << "请输入字符串进行编码：" << endl;
    cin >> str;          // 输入要加密的字符串
    HuffmanCode st(str); // 对象
    cout << "对字符串编码情况如下：" << endl;
    st.Encode(); // 编码
    cout << endl;
    cout << "请输入要解码的二进制编码:" << endl;
    cin >> str;
    cout << "解码如下：" << endl;
    st.Decode(str); // 解码

    system("pause");
    return 0;
}
```

# 图

## 理论知识

[图算法笔记（1）- 图论基本概念 - 力扣（LeetCode）](https://leetcode.cn/circle/article/LIfzOm/)

**定义：**Graph = （Vertex，Edge）

**完全图：**1、有向图：n(n-1)      2、无向图：n(n-1)/2

**网：**边带权的图

**顶点的度（TD）：**1、出度（ID）   2、入度（OD）

**路径长度：**路径上边的数目（权值之和）。

**简单路径（回路）：**除路径起点和终点可以相同外，其余顶点均不相同的路径。

**连通图（强连通图）：**![屏幕截图 2022-10-05 141817](初学上课笔记.assets\屏幕截图 2022-10-05 141817.png)

**连通分量：**

![屏幕截图 2022-10-05 141924](初学上课笔记.assets\屏幕截图 2022-10-05 141924.png)

**极小连通子图与生成树：**

![屏幕截图 2022-10-05 142030](初学上课笔记.assets\屏幕截图 2022-10-05 142030.png)

## 图的存储结构

[图的几种存储方式（补充链式前向星）](https://blog.csdn.net/weixin_43721423/article/details/86681572)

[链式前向星](https://www.luogu.com.cn/blog/2018--haha/solution-p3371)

### 简易版本

```c++
// 图的存储
/*链式前向星*/
struct edge{
    int to,next,weight;
}edges[maxM];
int head[maxN];
int tot;
void addedge(int s,int e,int w){
    edges[++tot].to = e;
    edges[tot].weight = w;
    edges[tot].next = head[s];
    head[s] = tot; 
}
void visit(int u){
    for(int i=head[u];i;i=edges[i].next){
        int v = edges[i].to;
        /*do something to (u,v)*/
    }
}
/*邻接表*/
struct edge{
    int weight;
    int to;
    edge* next;
    edge(int _to=0,int _weight=1):to(_to),weight(_weight),next(NULL){};
};
struct vex{
    int val;
    edge* first;
    vex(int v=0):val(v),first(NULL){};
} vexs[maxN];
void addedge(int s,int e,int v,int w){
    vexs[s].val = v;
    edge* temp = vexs[s].first;
    vexs[s].first = new edge(e,w);
    vexs[s].first->next = temp;
}
void visit(int u){
    for(edge* it=vexs[u].first;it;it=it->next){
        int v = it->to;
        /*do something to (u,v)*/
    }
}
```



### 链式前向星

**模板：**

```c++
struct edge{
    int to;  // 这一条边的终点
    int next;  // 下一条边的下标
    int weight;  // 权重
};
int head[maxN];
edge edges[maxM];
int idx;
void addEdge(int start,int end,int weight){  // 加边
    edges[++idx].to = end;
    edges[idx].weight = weight;
    edges[idx].next = head[start];
    head[start] = idx;  // 更新head
}

void visit(int u){  // 遍历u节点的所有边
    for(int i=head[u];i!=0;i=edges[i].next){
        cout<<"( "<<u<<" , "<<edges[i].to<<" , "<<edges[i].weight<<" )"<<endl;
    }
}
```



### 邻接矩阵

```c++
class AMG{
public:
    vector<int> vertax;   // 储存节点
    vector<vector<int>> matrix;   // 储存边的信息
    int e,v;  // 节点的数量
    ~AMG(int _v);
};
AMG::~AMG(int _v){
    this->v = _v;
    this->vertax.resize(_v);
    this->matrix.resize(_v,vector<int>(_v));
}
```

**无(有)向图:**

![屏幕截图 2022-10-05 144012](初学上课笔记.assets\屏幕截图 2022-10-05 144012.png)

**性质：**

1. 无向图的邻接矩阵是对称的。
2. 无向图顶点i的度是第i行的1的个数。
3. 有向图第i行含义：出度边。
4. 有向图第i列含义：入度边。

**网（有权图）：**

![屏幕截图 2022-10-05 144621](初学上课笔记.assets\屏幕截图 2022-10-05 144621.png)



### 邻接表

```c++
const int maxN = 10001;
struct edge{
	int to;
	edge* next;
	edge(int _to):to(_to),next(NULL){}
};
struct vex{
	int val;
	edge* first;
	vex():first(NULL){};
} vexs[maxN];
void addedge(int s,int e){
	vexs[s].val = s;
	edge* temp = vexs[s].first;
	vexs[s].first = new edge(e);
	vexs[s].first->next = temp;
}
void visie(int u){
    for(edge* it=vexs[u].first;it!=NULL;it=it->next){
        int v = it->to;
        cout<<v<<" ";
    } 
}

```

**无向图**

![](初学上课笔记.assets\屏幕截图 2022-10-05 145318.png)

**有向图（两种）**

![屏幕截图 2022-10-05 145512](初学上课笔记.assets\屏幕截图 2022-10-05 145512.png)



### 邻接多重表

**意义：**解决无向图边储存了两次的问题

![屏幕截图 2022-10-05 153407](初学上课笔记.assets\屏幕截图 2022-10-05 153407.png)

### 十字链表

**意义：**解决有向图求节点入度和出度困难的问题

![屏幕截图 2022-10-05 153041](初学上课笔记.assets\屏幕截图 2022-10-05 153041.png)

## 图的遍历

### 简易版本

```c++
/*深度搜索*/
int visited[maxN];
int d[maxN],f[maxN],pai[maxN],tim;
void dfs(int s){
    pai[s] = -1;
    function<void(int)> dfs_visit = [&](int u){
        if(visited[u]==1) return;
        visited[u] = 1;
        /*do something to u*/
        tim += 1; d[u] = tim;
        for(int i=head[u];i;i=edges[i].next){
            int v = edges[u].to;
            if(visited[v]==1) continue;
            dfs_visit(v);
            pai[v] = u; 
        }
        tim += 1; f[u] = tim;
    };
    dfs_visit(s);
}
/*广度搜索*/
int visited[maxN];
int d[maxN],pai[maxN];
void bfs(int s){
    if(visited[s]==1) return;
    queue<int> Q;
    Q.push(s); pai[s] = -1;
    while(!Q.empty()){
        int size = Q.size();
        for(int i=0;i<size;++i){
            int u = Q.front();Q.pop();
            visited[u] = 1;
            /*do something to u*/
            for(int j=head[u];j;j=edges[j].next){
                int v = edges[u].to;
                if(visited[v]==1) continue;
                Q.push(v);
                d[v] = d[u] + 1;
                pai[v] = u;
            }
        }
    }
}
```



### 注意

以下遍历仅仅针对强连通分量，如需遍历整个图，需要修改小部分代码

### 广度遍历（BFS）

**广度优先树：**广度优先遍历生成的树

**输出：**

```C++
d[v] = 根节点到 v 的最短路径的长度
pai[v] = u , u是v在树上的前驱节点，可以判断树边和回边
```

**代码实现：**

```c++
#include <bits/stdc++.h>
using namespace std;

/*
graph[i][0]储存每个节点的val
graph[i][1...end]储存相邻节点的下标
*/
void bfs(vector<vector<int>>& graph, int s){  // 传入s节点的下标，从s节点开始遍历
    int v = graph.size();  // 节点个数
    vector<string> color(v,"white");  // 是否发现和访问
    int d[v],pai[v];  // 输出结果
    memset(d,255,sizeof(d));  // 初始化为-1
    memset(pai,255,sizeof(pai));  // 初始化为-1
    color[s] = "gray";  // 初始化
    d[s] = 0;
    pai[s] = INT_MIN;
    queue<int> Q;  // 初始化
    Q.push(s);
    while(!Q.empty()){  // 遍历
        int u = Q.front();
        Q.pop();
        for(int i=1;i<graph[u].size();++i){
            int v = graph[u][i];
            if(color[v] == "white"){
                color[v] = "gray";
                d[v] = d[u] +1;
                pai[v] = u;
                Q.push(v);
            }
        }
        //cout<<graph[u][0]<<" ";
        /*do something*/
        color[u] = "black";
    }
}

int main()
{
    vector<vector<int>> graph(9,vector<int>(1));
    for(int i=0;i<9;++i) graph[i][0] = i;
    graph[0].push_back(1);graph[0].push_back(2);graph[0].push_back(5);graph[0].push_back(8);
    graph[1].push_back(0);graph[1].push_back(3);
    graph[2].push_back(0);graph[2].push_back(8);
    graph[3].push_back(1);graph[3].push_back(4);graph[3].push_back(6);
    graph[4].push_back(3);graph[4].push_back(5);
    graph[5].push_back(0);graph[5].push_back(4);graph[5].push_back(6);graph[5].push_back(7);
    graph[6].push_back(3);graph[6].push_back(5);
    graph[7].push_back(5);
    graph[8].push_back(0);graph[8].push_back(2);
    bfs(graph,1);
    system("pause");
    return 0;
}
```

![屏幕截图_20221125_191718](初学上课笔记.assets\屏幕截图_20221125_191718.png)

### 深度遍历（DFS）

**深度优先树：**深度优先遍历生成的树

**输出：**

```c++
// 2个时间戳
d[v] = discovery time;
f[v] = finishing time;
// 前驱节点
pai[v] = u , u是v在树上的前驱节点
```

**DFS在原始图中引入了边之间的一个重要区别：**

![屏幕截图_20221125_201429](初学上课笔记.assets\屏幕截图_20221125_201429.png)

**注：**

1、广度优先遍历不存在 Forward edge ，因为不会回溯

2、无向图不存在 Forward edge 和 Cross edge 

3、一个Back edge 代表一个回路

**代码实现：**

```c++
#include <bits/stdc++.h>
using namespace std;

/*
graph[i][0]储存每个节点的val
graph[i][1...end]储存相邻节点的下标
*/
void dfs(vector<vector<int>>& graph, int s){  // 传入s节点的下标，从s节点开始遍历
    int v = graph.size();  // 节点个数
    int time = 0;  // 时间戳
    vector<string> color(v,"white");  // 是否发现和访问
    int d[v],f[v],pai[v];  // 输出结果
    memset(d,255,sizeof(d));  // 初始化为-1
    memset(f,255,sizeof(f));  // 初始化为-1
    memset(pai,255,sizeof(pai));  // 初始化为-1
    color[s] = "gray";  // 初始化
    d[s] = 0;
    pai[s] = INT_MIN;
    function<void(int)> dfs_visit = [&](int u){
        color[u] = "gray";
        cout<<char(graph[u][0]+'A')<<" ";
        /*do someting*/
        time = time+1;
        d[u] = time;
        for(int i=1;i<graph[u].size();++i){
            if(color[graph[u][i]]=="white"){
                pai[graph[u][i]] = u;
                dfs_visit(graph[u][i]);
            }
        }
        color[u] = "black";
        time = time+1;
        f[u] = time;
    };
    dfs_visit(s);
}

int main()
{
    vector<vector<int>> graph(9,vector<int>(1));
    for(int i=0;i<9;++i) graph[i][0] = i;
    graph[0].push_back(1);graph[0].push_back(2);graph[0].push_back(5);graph[0].push_back(8);
    graph[1].push_back(0);graph[1].push_back(3);
    graph[2].push_back(0);graph[2].push_back(8);
    graph[3].push_back(1);graph[3].push_back(4);graph[3].push_back(6);
    graph[4].push_back(3);graph[4].push_back(5);
    graph[5].push_back(0);graph[5].push_back(4);graph[5].push_back(6);graph[5].push_back(7);
    graph[6].push_back(3);graph[6].push_back(5);
    graph[7].push_back(5);
    graph[8].push_back(0);graph[8].push_back(2);
    dfs(graph,0);
    system("pause");
    return 0;
}
```

### 双向广度遍历

### A-star 算法

![屏幕截图_20221220_205318](初学上课笔记.assets\屏幕截图_20221220_205318.png)

**模板题目：[P2483 【模板】k 短路 / [SDOI2010\] 魔法猪学院 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2483)**

```c++
#include <bits/stdc++.h>
#define cin(x) cin >> x 
#define cout(x) cout << x 
using namespace std ;
const int N = 5e3+10 , M = 2e6+10 , inf = 1e9 ; 
/*-------------分割线---------------*/
int n , m ;
double E ; 
/*-------------分割线---------------*/
int h1[N] , h2[N] , idx ;
struct qwq{int to,ne;double w;} e1[M],e2[M] ;
void add(int u,int v,double w){
    e1[++idx] = {v,h1[u],w} ; h1[u] = idx ; // 正图
    e2[idx]   = {u,h2[v],w} ; h2[v] = idx ; // 反图
}
/*-------------分割线---------------*/
int vis[N] ; double dis[N] ;
struct dij{
    int v ; double dis ; 
    bool operator<(const dij& e) const {return dis > e.dis ;}
};
void dijkstra(int s){
    memset(vis,0,sizeof(vis)) ;
    fill(dis+1,dis+1+n,inf) ; dis[s] = 0 ;
    priority_queue<dij> q ; q.push({s,dis[s]}) ;
    while(q.size()){
        int u = q.top().v ; q.pop() ;
        if(vis[u]) continue ; vis[u] = 1 ;
        for(int i=h2[u];i;i=e2[i].ne){
            int v = e2[i].to ; double w = e2[i].w ;
            if(dis[v] > dis[u] + w ){
                dis[v] = dis[u] + w ;
                q.push({v,dis[v]}) ;
            }
        } 
    }
}
/*-------------分割线---------------*/
struct ast{
    int v ; double d , priority ; 
    ast(int _v,double _d):v(_v),d(_d),priority(dis[v]+d){}
    bool operator<(const ast& e) const {return priority > e.priority;}
} ;
int cnt ;
void a_star(int s){
    priority_queue<ast> q ;
    q.push({s,0}) ; 
    while(q.size()){
        ast u = q.top() ; q.pop() ;
        if(u.v == n) {
            if(E >= u.d) cnt++ , E -= u.d;
            else {cout(cnt) ; return ;}
        }
        for(int i=h1[u.v];i;i=e1[i].ne){
            int v = e1[i].to ; double w = e1[i].w ;
            q.push({v,u.d+w}) ; 
        }
    }
}
/*-------------分割线---------------*/
void read(){
    cin(n) ; cin(m) ; cin(E) ;
    int u , v ; double w ;
    for(int i=1 ; i <= m ; i ++) cin >> u >> v >> w , add(u , v , w) ;
}
/*-------------分割线---------------*/
int main(){
    read() ;
    dijkstra(n) ;
    a_star(1) ;
    system("pause");
}
```

### 迭代加深

**参考：[浅谈迭代加深搜索 - Seaway-Fu - 博客园 (cnblogs.com)](https://www.cnblogs.com/fusiwei/p/12236592.html)**

## 扩展知识

![屏幕截图_20230101_182717](初学上课笔记.assets\屏幕截图_20230101_182717.png)

### **无向图的割点和桥**

![屏幕截图_20221125_204652](初学上课笔记.assets\屏幕截图_20221125_204652.png)

![屏幕截图_20221125_204657](初学上课笔记.assets\屏幕截图_20221125_204657.png)

**DFS搜索树：**

![屏幕截图_20221125_204849](初学上课笔记.assets\屏幕截图_20221125_204849.png)

**求图的割点和桥（Tarjan算法）：**

![屏幕截图_20221126_111311](初学上课笔记.assets\屏幕截图_20221126_111311.png)

**关键数据结构：**

![屏幕截图_20221125_205203](初学上课笔记.assets\屏幕截图_20221125_205203.png)

**DFS树：**

![屏幕截图_20221125_205326](初学上课笔记.assets\屏幕截图_20221125_205326.png)

**割点：[P3388 【模板】割点（割顶） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3388)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 2e4+10 , M = 1e6+10 ;
int h[N] , tot ; struct edge{int to,ne;} e[M] ;
void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
int n , m , ans ;
int dfn[N] , low[N] , tim , cut[N] , root ; 
void tarjan(int u){
    dfn[u] = low[u] = ++ tim ; int child = 0 ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ; 
        if(!dfn[v]) {
            tarjan(v) , low[u] = min(low[u],low[v]) ;
            if(low[v] >= dfn[u]){  // 判断割点是一条边一条边的判断，判断这条边对应的那一片连通块是不是不可以没有u，记住，一条边对应一片连通块
                child ++ ; 
                if(u != root || child >= 2) cut[u] = 1 ; // 可能重复赋值
            }
        }
        else low[u] = min(low[u] , dfn[v]) ;
    }
}
int main(){
    cin >> n >> m ; int u , v ; 
    for(int i=1;i<=m;++i) cin >> u >> v , add(u,v) , add(v,u) ;
    for(int i=1;i<=n;++i) if(!dfn[i]) root = i , tarjan(i) ;
    for(int i=1;i<=n;++i) if(cut[i]) ans++ ;
    cout << ans << endl ;
    for(int i=1;i<=n;++i) if(cut[i]) cout << i << " " ;
    system("pause");
}

```

**[1568. 使陆地分离的最少天数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-days-to-disconnect-island/)**

```c++
class Solution {
public:
    int dx[5] = {0,-1,1,0,0} ;
    int dy[5] = {0,0,0,-1,1} ;
    int n , m ;
    int id(int x,int y){return x * m + y ;}
    int minDays(vector<vector<int>>& grid) 
    {
        n = grid.size() ; m = grid[0].size() ; bool isExistSoild = false ;
        int idx = -1 ; vector<vector<int>> adj(n * m); int root = -1 ;
        for (int i = 0; i < n; ++i)
        {
            for(int j = 0; j < m; ++j)
            {
                if(grid[i][j] == 0) continue ;
                isExistSoild = true ;
                for (int k = 1; k <= 4; ++k)
                {
                    int x = i + dx[k] , y = j + dy[k] ;
                    if(x < 0 || x >= n || y < 0 || y >= m) continue ;
                    if(grid[x][y] == 0) continue ;
                    adj[id(i,j)].push_back(id(x,y)) ;
                    root = id(i,j) ;
                }
            }
        }

        bool ok = false ; vector<int> vis(n * m) ;
        function<void(int)> dfs = [&](int u)
        {  
            vis[u] = 1 ; 
            for(auto v : adj[u])
            {
                if(vis[v]) continue ;
                dfs(v) ;
            }
        } ;

        for (int i = 0; i < n; ++i)
        {
            for(int j = 0; j < m; ++j)
            {
                
                if(grid[i][j] == 0 || vis[id(i,j)]) continue ;
                if(ok) return 0 ;
                dfs(id(i,j)) ; ok = true ;
            }
        }

        vector<int> dfn(n * m) , low(n * m) ; int tim = 0 ; ok = false ;
        function<void(int)> tarjan = [&](int u)
        {
            dfn[u] = low[u] = ++ tim ; int child = 0 ; 
            for(auto v : adj[u])
            {
                if(!dfn[v])
                {
                    tarjan(v) ;
                    low[u] = min(low[u] , low[v]) ;
                    if(low[v] >= dfn[u])
                    {
                        child ++ ;
                        if(u != root || child > 1) ok = true ;
                    }
                }
                else
                {
                    low[u] = min(low[u] , dfn[v]) ;
                }
            }
        } ;

        if(root != -1) tarjan(root) ;
        else if(isExistSoild) return 1 ;
        else return 0 ;

        if(ok) return 1 ;
        else return 2 ;
    }
};
```

**割边：[P1656 炸铁路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1656)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 2e4+10 , M = 1e6+10 ;
int h[N] , tot = 1 ; // 无向图成对出现，方便判断反边
int n , m , ans ;
struct edge{int to,ne;} e[M] ;
void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
int d[N] , low[N] , tim ; struct node{int u,v;}; vector<node> bri ;
void tarjan(int u,int idx_edge){  // 第二个参数记录边的编号
    d[u] = low[u] = ++tim ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(!d[v]){
            tarjan(v,i) ;
            low[u] = min(low[u],low[v]) ;
            if(low[v] > d[u]) bri.push_back({u,v}) ;
        }else if(i != (idx_edge^1)){  // 不能用反边来更新时间戳
            low[u] = min(low[u],d[v]) ;
        }
    }
}
int main(){
    cin >> n >> m ; int u , v ; 
    for(int i=1;i<=m;++i) cin >> u >> v , add(u,v) , add(v,u) ;
    for(int i=1;i<=n;++i) if(!d[i]) tarjan(i,h[i]) ;
    sort(bri.begin(),bri.end(),[](auto& e1,auto& e2){return e1.u==e2.u?e1.v<e2.v:e1.u<e2.u;});
    for(int i=0;i<bri.size();++i) cout << bri[i].u << " " << bri[i].v << endl ;
    system("pause");
}

```

[1192. 查找集群内的关键连接 - 力扣（LeetCode）](https://leetcode.cn/problems/critical-connections-in-a-network/)

```c++
class Solution {
public:
    vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {
        vector<vector<int>> brige ;
        
        vector<vector<int>> adj(n) ;
        for(auto& e : connections)
        {
            adj[e[0]].push_back(e[1]) ; 
            adj[e[1]].push_back(e[0]) ;
        }

        vector<int> dfn(n) , low(n) ; int tim = 0 ; 
        function<void(int,int)> tarjan = [&](int u,int father)
        {
            dfn[u] = low[u] = ++ tim ; 
            for(auto v : adj[u]){
                if(!dfn[v])
                {
                    tarjan(v , u) ;
                    low[u] = min(low[u] , low[v]) ;
                    if(low[v] > dfn[u]) brige.push_back({u , v}) ;
                }
                else if(v != father) 
                {
                    low[u] = min(low[u],dfn[v]) ;
                }
            }
        } ;
        tarjan(0 , -1) ;

        return brige ;
    }
};
```



### 有向图的强连通分量（SCC）

**定义：**有向图的极大强连通子图称为强连通分量（Strongly connected components）

**作用：**缩点，得来的图：DAG

**性质：**

1、有向图可以通过缩点DAG，出度与入度为0 的数量的最大值就是改图转化为一个强连通图的最少边数

2、强连通分量都存在一条能只经过每个点一次的环（就是个圈）

![屏幕截图_20221126_113736](初学上课笔记.assets\屏幕截图_20221126_113736.png)

**求有向图的强连通分量：Kosaraju算法**

[Kosaraju 算法 - SHHHS - 博客园 (cnblogs.com)](https://www.cnblogs.com/shadowland/p/5876307.html)

**算法思想：**Kosaraju算法的解释和实现都比较简单，为了找到[强连通](https://baike.baidu.com/item/强连通/1131406?fromModule=lemma_inlink)分支，首先对图G运行DFS，计算出各顶点完成搜索的时间f；然后计算图的逆图GT，对逆图也进行DFS搜索，但是这里搜索时顶点的访问次序不是按照顶点标号的大小，而是按照各顶点f值由大到小的顺序；逆图DFS所得到的森林即对应连通区域。

**算法伪代码：**

1. 对原图G进行[深度优先遍历](https://baike.baidu.com/item/深度优先遍历/9796166?fromModule=lemma_inlink)，记录每个节点的离开时间num[i]
2. 选择具有最晚离开时间的顶点，对反图GT进行[遍历](https://baike.baidu.com/item/遍历/9796023?fromModule=lemma_inlink)，对能够遍历到的顶点进行染色，这些顶点构成一个[强连通分量](https://baike.baidu.com/item/强连通分量/7448759?fromModule=lemma_inlink)
3. 如果还有顶点没有染色，继续步骤2，否则算法结束

**求有向图的强连通分量：Tarjan算法**

![屏幕截图_20221130_103703](初学上课笔记.assets\屏幕截图_20221130_103703.png)

![屏幕截图_20221130_103942](初学上课笔记.assets\屏幕截图_20221130_103942.png)

![屏幕截图_20221130_104046](初学上课笔记.assets\屏幕截图_20221130_104046.png)

**模板例题：[P2863 [USACO06JAN\]The Cow Prom S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2863)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4+10 , M = 1e6+10 ;
int h[N] , tot ; int n , m , ans ;
struct edge{int to,ne;} e[M] ;
void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
int scc[N] , siz[N] , cnt ;
int instk[N] ; stack<int> stk ;
int dfn[N] , low[N] , tim ;
void tarjan(int u){
    dfn[u] = low[u] = ++tim ;
    stk.push(u) ; instk[u] = 1 ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(!dfn[v]){
            tarjan(v) ;
            low[u] = min(low[u],low[v]) ;
        } else if(instk[v]) {  // v已经访问，且在栈中（表示v是祖先节点或者左子树的节点（Back edge or Cross edge）），因为back edge 一定有环，cross edge 可能有环
            low[u] = min(low[u],dfn[v]) ;
        }
    }
    if(dfn[u] == low[u]) {
        int v ; ++cnt ;
        do{
            v = stk.top() ; stk.pop() ; instk[v] = 0;
            scc[v] = cnt ; siz[cnt]++ ; 
        } while(v!=u) ;
        if(siz[cnt] > 1) ans ++ ;
    }
}
int main(){
    cin >> n >> m ; int u , v ; 
    for(int i=1;i<=m;++i) cin >> u >> v , add(u,v);
    for(int i=1;i<=n;++i) if(!dfn[i]) tarjan(i) ;
    cout << ans << endl ;
    system("pause");
}

```

[P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e4+10 , M = 2e5+10 ;
int h[N] , tot = 1 ; struct qwq{int to,ne;} e[M] ;
void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}  // 旧图
int hscc[N] , totscc = 1 ; struct qwqscc{int to,ne;} escc[M] ;
void addscc(int u,int v){escc[++totscc]={v,hscc[u]};hscc[u]=totscc;}  // 新图
int n , m , ans ; int w[N] ; int a , b ,c ;  // 全局变量
int cnt , scc[N] , siz[N] , dfn[N] , tim , low[N] , instk[N] ; stack<int> st ;  // tarjan所需数组和变量
void tarjan(int u){
    dfn[u] = low[u] = ++ tim ; st.push(u) ; instk[u] = 1 ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(!dfn[v]) tarjan(v) , low[u] = min(low[u],low[v]) ;
        else if(instk[v]) low[u] = min(low[u],dfn[v]) ;
    }
    if(low[u] == dfn[u]){
        int v ; cnt ++ ;
        do{
            v = st.top() ; st.pop() ; instk[v] = 0 ;
            scc[v] = cnt ; siz[cnt] += w[v] ;
        }while(v != u) ;
    }
}
int ind[N] ; int f[N] ; // 到该点能获得的最大权值和
void topo(){  // 缩点后做拓扑排序为了动态规划
    queue<int> q ; 
    for(int i=1;i<=cnt;++i) if(!ind[i]) q.push(i) , f[i] = siz[i] ;
    while(q.size()) {
        int u = q.front() ; q.pop() ;
        for(int i=hscc[u];i;i=escc[i].ne) {
            int v = escc[i].to ;
            f[v] = max(f[v] , f[u] + siz[v]) ;
            if(!--ind[v]) q.push(v) ;
        }
    }
    for(int i=1;i<=cnt;++i) ans = max(ans,f[i]) ;
}
int main(){
    cin >> n >> m ;
    for(int i=1;i<=n;++i) cin >> w[i] ;
    for(int i=1;i<=m;++i) cin >> a >> b , add(a,b) ;
    for(int i=1;i<=n;++i) if(!dfn[i]) tarjan(i) ; 
    for(int u=1;u<=n;++u) {  //缩点新图
        for(int i=h[u];i;i=e[i].ne) {
            int v = e[i].to ; 
            if(scc[u] != scc[v]) addscc(scc[u],scc[v]) , ind[scc[v]] ++ ;
        }
    }
    topo() ;
    cout << ans << endl ;
    system("pause") ;
}
```



### 最近公共祖先（LCA）

**模板题目：[P3379 【模板】最近公共祖先（LCA） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3379)**

**tarjan算法（离线）：**一个熊孩子Link从一棵[有根树](https://www.zhihu.com/search?q=有根树&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A267513879})的最左边最底下的结点灌岩浆，Link表示很讨厌这种倒着长的树。
岩浆会不断的注入，直到注满整个树…
如果岩浆灌满了一棵子树，Link发现树的另一边有一棵更深的子树，Link会先去将那棵子树灌满。
岩浆只有在迫不得已的情况下才会向上升高，找到一个新的子树继续注入。
机(yu)智(chun)的Link发现了找LCA的好方法，即如果两个结点都被岩浆烧掉时，他们的LCA即为那棵子树上岩浆最高的位置。

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 5e6+10 , M = 5e6+10 ;
struct node{int v,i;};
int n , m , root , fa[N] , ans[N] , vis[N] ; vector<node> query[M] ;
int h[N] , tot = 1 ;
struct edge{int to,ne;} e[N+10] ;
void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
void Tarjan_LCA(int u){
    vis[u] = 1 ; 
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(vis[v]) continue ;
        Tarjan_LCA(v) ;
        fa[v] = u ;
    }
    for(auto& x : query[u] ){
        int i = x.i , v = x.v ;
        if(vis[v]) ans[i] = find(v) ;  
    }
}
int main(){
    cin >> n >> m >> root ; int u , v ;
    for(int i=1;i<=n;++i) fa[i] = i ;
    for(int i=1;i<n;++i) cin >> u >> v , add(u , v) , add(v , u);
    for(int i=1;i<=m;++i) cin >> u >> v , query[u].push_back({v,i}) , query[v].push_back({u,i}) ;
    Tarjan_LCA(root) ;
    for(int i=1;i<=m;++i) cout << ans[i] << endl ;
    system("pause") ;
}
```

**倍增算法：**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 5e5+10 , M = 5e6+10 ;
struct node{int v,i;};
int n , m , root , fa[N][21] , d[N] ;
int h[N] , tot = 1 ;
struct edge{int to,ne;} e[M] ;
void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
void dfs(int u,int father){
    d[u] = d[father] + 1 ;
    fa[u][0] = father ;
    for(int i=1;i<=20;++i) fa[u][i] = fa[fa[u][i-1]][i-1] ;
    for(int i=h[u];i;i=e[i].ne) if(e[i].to != father) dfs(e[i].to,u);
}
int LCA(int u,int v){
    if(d[u] < d[v]) swap(u,v) ;
    for(int i=20;i>=0;--i) if(d[fa[u][i]] >= d[v]) u = fa[u][i] ;  // 跳到同一层
    if(u == v) return v ;  // 特判u或v就是最近公共祖先节点
    for(int i=20;i>=0;--i) if(fa[u][i] != fa[v][i]) u = fa[u][i] , v = fa[v][i] ;  // 跳到祖先节点的下一层
    return fa[u][0] ;  // 再跳一层就是最近的公共祖先节点
}
int main(){
    ios::sync_with_stdio(0) ; cin.tie(nullptr) ; cout.tie(nullptr) ;
    cin >> n >> m >> root ; int u , v ;
    for(int i=1;i<n;++i) cin >> u >> v , add(u , v) , add(v , u);
    dfs(root , 0) ;
    for(int i=1;i<=m;++i) cin >> u >> v , cout << LCA(u , v) << endl ;
    system("pause") ;
}
```

### Tarjan EDCC(边双连通分量缩点)

```c++
#include <bits/stdc++.h>
using namespace std ; 
const int N = 1e4+10 , M = 1e6+10 , inf = 0x7fffffff ;
int h[N] , tot = 1 ; int n , m ;
struct edge{int to,ne;}e[M];
void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
int edcc[N] , siz[N] , bri[M] , cnt ;
int d[N] , low[N] , tim ; stack<int> s ; 
void tarjan(int u,int in_edge){  // tarjan(u,h[u]) ;
    d[u] = low[u] = ++tim ; s.push(u) ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(!d[v]){
            tarjan(v,i) ;
            low[u] = min(low[u],low[v]) ;
            if(low[v] > d[u]) bri[i] = bri[i^1] = 1 ;
        } else if(i != (in_edge^1)){
            low[u] = min(low[u],d[v]) ;
        }
    }
    if(low[u] == d[u]) {
        int v ; cnt++ ;
        do{
            v = s.top() ; s.pop() ;
            edcc[v] = cnt ; siz[cnt]++ ;
        }while(v != u) ;
    }
}
int main(){
    cin >> n >> m ; int u , v ; 
    for(int i=1;i<=m;++i) cin >> u >> v , add(u , v) , add(v , u) ;
    for(int i=1;i<=n;++i) if(!d[i]) tarjan(i,h[i]) ;
    system("pause");
}
```

### Tarjan VDCC （点双连通分量缩点）

[(5条消息) 点双连通分量&边双联通分量详解_Hypoc_的博客-CSDN博客_点双连通分量](https://blog.csdn.net/a_forever_dream/article/details/103019013)

[LCP 54. 夺回据点 - 力扣（LeetCode）](https://leetcode.cn/problems/s5kipK/)

```c++
#include <bits/stdc++.h>
using namespace std ; 
const int N = 1e4+10 , M = 1e6+10 , inf = 0x7fffffff ;
int h[N] , tot = 1 , root ; int n , m ;
struct edge{int to,ne;}e[M]; vector<int> ne[N] ; // 新图 
void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
int cut[N] , id[N] , cnt , num ; vector<int> vdcc[N] ;
int d[N] , low[N] , tim ; stack<int> s ; 
void tarjan(int u){  
    d[u] = low[u] = ++tim ; s.push(u) ;
    if(h[u] == 0) {vdcc[++cnt].push_back(u) ; return ;}  // 孤立点特判
    int child = 0;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(!d[v]){
            tarjan(v) ;
            low[u] = min(low[u],low[v]) ;
            if(low[v] >= d[u]){
                child++ ; 
                if(u != root || child > 1){
                    cut[u] = 1 ;
                }
                int x ; cnt++ ;
                do{
                    x = s.top() ; s.pop() ;
                    vdcc[cnt].push_back(x) ;
                }while(x != v) ;
                vdcc[cnt].push_back(u) ;
            }
        } else{
            low[u] = min(low[u],d[v]) ;
        }
    }
    
}
int main(){
    cin >> n >> m ; int u , v ; 
    for(int i=1;i<=m;++i) cin >> u >> v , add(u , v) , add(v , u) ;
    for(int i=1;i<=n;++i) if(!d[i]) root = i , tarjan(i) ;
    num = cnt ; for(int i=1;i<=n;++i) if(cut[i]) id[i] = ++num ;  // 对割点额外编号
    for(int i=1;i<=cnt;++i) for(int j=0;j<vdcc[i].size();++j) {
        int x = vdcc[i][j] ; 
        if(cut[x]){  // 通过割点来构建树，新图
            ne[i].push_back(id[x]) ;
            ne[id[x]].push_back(i) ;
        }
    }
    system("pause");
}
```



### 树链剖分

**概念：**

1、重儿子：父结点所有儿子中节点数目最多的儿子

2、轻儿子：其他儿子

3、重边：父节点和重儿子连成的边

4、轻边：父节点和轻儿子连成的边

5、重链：由多条重边连接而成的路径（一个节点也是重链）

**性质：**

1、一棵多叉树都可以被分成若干重链。

2、轻儿子一定是每条重链的顶点

3、任意一条路径被切分成不超过 logn 条链

**数组：**

```c++
fa[u] ; // 存u的父节点
d[u] ;   // 存u的深度
son[u] ;  // 存u的重儿子
siz[u] ;  // 存u为根的子树的节点数
top[u] ;  // 存u所在重链的顶点
```

**求LCA：**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 5e5+10 , M = 5e6+10 ;
struct node{int v,i;};
int n , m , root , fa[N] , d[N] , son[N] , siz[N] , top[N] ;
int h[N] , tot = 1 ;
struct edge{int to,ne;} e[M] ;
void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
void dfs1(int u,int father){  // dfs1(root , 0)
    fa[u] = father ; d[u] = d[father] + 1 ; siz[u] = 1 ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(v == father) continue ;
        dfs1(v,u) ;
        siz[u] += siz[v] ;
        if(siz[son[u]] < siz[v]) son[u] = v ;
    }
}
void dfs2(int u,int tp){  // dfs2(root , root) ;
    top[u] = tp ;
    if(!son[u]) return ;  // 无重儿子返回 （叶子节点）
    dfs2(son[u],tp) ;  // 搜重儿子
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(v == fa[u] || v == son[u]) continue ;
        dfs2(v,v) ;  // 搜轻儿子
    }
}
int LCA(int u,int v){
    while(top[u] != top[v]) {
        if(d[top[u]] < d[top[v]]) swap(u , v) ;
        u = fa[top[u]] ;
    }
    return d[u] < d[v] ? u : v ;
}
int main(){
    ios::sync_with_stdio(0) ; cin.tie(nullptr) ; cout.tie(nullptr) ;
    cin >> n >> m >> root ; int u , v ;
    for(int i=1;i<n;++i) cin >> u >> v , add(u , v) , add(v , u);
    dfs1(root , 0) ; dfs2(root , root) ;
    for(int i=1;i<=m;++i) cin >> u >> v , cout << LCA(u , v) << endl ;
    system("pause") ;
}
```

### 树链剖分与线段树

**模板例题：[P3384 【模板】轻重链剖分/树链剖分 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3384)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 2e5 + 10 , M = 2e6 + 10 ; 
int w[N] , nw[N] , id[N] , idx ;  int n , m , root , P ;
int h[N] , tot ; struct qwq{int to,ne;} e[M] ; void adde(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
namespace SegTree {
    #define lc (p << 1)
    #define rc (p << 1 | 1)
    #define sum(x) tr[x].sum
    #define add(x) tr[x].add
    struct node{int sum,add;} tr[N << 2] ;
    void pushup(int p){sum(p) = (sum(lc) + sum(rc))%P ;}
    void pushdown(int p,int l,int r){
        if(!add(p)) return ; int m = l + r >> 1 ;
        sum(lc) = (sum(lc) + (m - l + 1) * add(p))%P ; 
        sum(rc) = (sum(rc) + (r - m) * add(p))%P ; 
        add(lc) = (add(lc) + add(p))%P ; add(rc) = (add(rc) + add(p))%P ; add(p) = 0 ;
    }
    void build(int p,int l,int r) {
        tr[p] = {nw[l],0} ;
        if(l == r) return ;
        int m = l + r >> 1 ;
        build(lc,l,m) ; build(rc,m+1,r) ;
        pushup(p) ;
    }
    int query(int p,int l,int r,int x,int y) {
        if(x <= l && y >= r) return sum(p) ;
        pushdown(p,l,r) ;
        int m = l + r >> 1 ; int res = 0 ;
        if(x <= m) res = (res + query(lc,l,m,x,y))%P ;
        if(y >= m+1) res = (res + query(rc,m+1,r,x,y))%P ;
        pushup(p) ;
        return res ;
    }
    void updata(int p,int l,int r,int x,int y,int k) {
        if(x <= l && y >= r) {
            sum(p) = (sum(p) + (r - l + 1) * k)%P ;
            add(p) = (add(p) + k)%P ; return ;
        }
        pushdown(p,l,r) ;
        int m = l + r >> 1 ;
        if(x <= m) updata(lc,l,m,x,y,k) ;
        if(y >= m+1) updata(rc,m+1,r,x,y,k) ;
        pushup(p) ;
    }
}
namespace TreeLink {
    int dep[N] , fa[N] , siz[N] , son[N] , top[N] ;
    void dfs1(int u,int father){  // 处理 dep fa son siz
        fa[u] = father ; dep[u] = dep[father] + 1 ; siz[u] = 1 ;
        for(int i=h[u];i;i=e[i].ne) {
            int v = e[i].to ; 
            if(v == father) continue ;
            dfs1(v,u) ; siz[u] += siz[v] ;
            if(siz[son[u]] < siz[v]) son[u] = v ;
        }
    }
    void dfs2(int u,int tp){ // 处理 top 和 nw 和 id
        top[u] = tp ; id[u] = ++ idx ; nw[id[u]] = w[u] ;
        if(!son[u]) return ;
        dfs2(son[u],tp) ;
        for(int i=h[u];i;i=e[i].ne) {
            int v = e[i].to ; 
            if(v == fa[u] || v == son[u]) continue ;
            dfs2(v,v) ;
        }
    }
    void updata1(int u,int v,int k) {  // 1 更新u到v
        while(top[u] != top[v]) {
            if(dep[top[u]] < dep[top[v]]) swap(u,v) ;
            SegTree::updata(1,1,n,id[top[u]],id[u],k) ;
            u = fa[top[u]] ;
        }
        if(dep[u] < dep[v]) swap(u,v) ;
        SegTree::updata(1,1,n,id[v],id[u],k) ;
    }
    void updata2(int u,int k){  // 3 更新子树u的
        SegTree::updata(1,1,n,id[u],id[u]+siz[u]-1,k) ;
    }
    int query1(int u,int v){  // 2 查询u到v的
        int ans = 0 ;
        while(top[u] != top[v]) {
            if(dep[top[u]] < dep[top[v]]) swap(u,v) ;
            ans = (ans + SegTree::query(1,1,n,id[top[u]],id[u]))%P ;
            u = fa[top[u]] ;
        }
        if(dep[u] < dep[v]) swap(u,v) ;
        ans = (ans + SegTree::query(1,1,n,id[v],id[u]))%P ;
        return ans ;
    }
    int query2(int u){  // 4 查询子树u的
       return SegTree::query(1,1,n,id[u],id[u]+siz[u]-1) % P ; 
    }
}
int main(){
    cin >> n >> m >> root >> P ; for(int i=1;i<=n;++i) cin >> w[i] ;
    int u , v ; for(int i=1;i<n;++i) cin >> u >> v , adde(u,v) , adde(v,u) ; 
    TreeLink::dfs1(root,0) ; TreeLink::dfs2(root,root) ; SegTree::build(1,1,n) ;
    while(m--){    
        int op , x , y , k ;
        cin >> op ;
        if(op==1){
            cin >> x >> y >> k ; TreeLink::updata1(x , y , k) ;
        }else if(op==2){
            cin >> x >> y ; cout << TreeLink::query1(x , y) << endl ;
        }else if(op==3){
            cin >> x >> k ; TreeLink::updata2(x , k) ;
        }else if(op==4){
            cin >> x ; cout << TreeLink::query2(x) << endl ;
        }
    }
    system("pause") ;
}
```

### 欧拉回路

对于无孤立结点的图 G，如果存在一条路经过图中**所有边一次且仅一次，**该路就称**为欧拉路**。如果存在一条回路，经过图中每条边一次且仅一次，该回路称为**欧拉回路。**具有**欧拉回路的图称为欧拉图**。

给定有向图 G，通过图中每边一次且仅一次的一条**单向路（回路）**，**称作单向欧拉路（回路）**。

**性质：**

**无向图欧拉路的条件：**当且仅当无向图 GG 是连通的，且有零个或两个奇数度结点，GG 具有一条欧拉路。

**无向图欧拉回路的条件：**当且仅当无向图 GG 是连通的，且所有结点度数全为偶数时，GG 具有一条欧拉回路。

**有向图欧拉路的条件：**当且仅当有向图 GG 是连通的，且除两个结点外，每个结点的入度等于出度，同时在这两个结点中，一个结点的入度比出度大一，另一个结点的入度比出度小一，GG 具有一条单向欧拉路。

**有向图欧拉回路的条件：**当且仅当有向图 GG 是连通的，且每个结点入度等于出度，GG 具有一条单向欧拉回路。

**求法：**

Hierholzer 算法如下：

我们从节点 uu 开始，任意地经过还未经过的边，直到我们「无路可走」。此时我们一定回到了节点 uu，这是因为所有节点的入度和出度都相等。

回到节点 uu 之后，我们得到了一条从 uu 开始到 uu 结束的回路，这条回路上仍然有些节点有未经过的出边。我么从某个这样的节点 vv 开始，继续得到一条从 vv 开始到 vv 结束的回路，再嵌入之前的回路中，即
`u→⋯→v→⋯→u`

变为
`u→⋯→v→⋯→v→⋯→u`

以此类推，直到没有节点有未经过的出边，此时我们就找到了一条欧拉回路。

**例题：[753. 破解保险箱 - 力扣（LeetCode）](https://leetcode.cn/problems/cracking-the-safe/)**

## 遍历的应用

### 最小生成树

**例题：[1584. 连接所有点的最小费用 - 力扣（LeetCode）](https://leetcode.cn/problems/min-cost-to-connect-all-points/submissions/)**

```c++
// Kruskal
struct edge{
    int start;
    int end;
    int weight;    
};

class Solution {
public:
    int minCostConnectPoints(vector<vector<int>>& points) {
        int res=0;
        vector<edge> edges;
        for(int i=0;i<points.size();++i){
            for(int j=0;j<points.size();++j){
                edges.push_back({i,j,abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])});
            }
        }
        sort(edges.begin(),edges.end(),[](edge& e1,edge& e2){
            return e1.weight < e2.weight;
        });
        UF uf(points.size());
        for(int i=0;i<edges.size();++i){
            if(uf.connected(edges[i].start,edges[i].end)) continue;
            res += edges[i].weight;
            uf.Union(edges[i].start,edges[i].end);
        }
        return res;
    }
};
```

```c++
// Prim
class Solution {
public:
    int minCostConnectPoints(vector<vector<int>>& points) {
        int n = points.size();
        int res = 0;
        //  将points转化成邻接矩阵, 这一步可有可无
        vector<vector<int> > matrix(n, vector<int>(n));
        for (int i = 0; i < n; i++) 
            for (int j = 0; j < n; j++) 
                matrix[i][j] = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]);
        vector<int> minCost(n,INT_MAX);
        vector<bool> visited(n,0);
        // 初始点
        visited[0] = 1;
        for(int i=0;i<n;++i){
            if(visited[i]) continue;
            minCost[i] = matrix[0][i];
        }
        // 其他n-1个点
        for(int i=1;i<n;++i){
            int minIndex = -1;
            int minVal = INT_MAX;
            for(int j=0;j<n;++j){  
                if(minCost[j] < minVal && visited[j]==0){
                    minVal = minCost[j];
                    minIndex = j;
                }
            }
            res += minVal;
            visited[minIndex] = 1;
            minCost[minIndex] = -1;
            // 更新minCost
            for(int j=0;j<n;++j){
                if(visited[j]==0 && minCost[j] > matrix[minIndex][j]){
                    minCost[j] = matrix[minIndex][j];
                }
            }
        }
        return res;
    }
};

```

**例题：[1489. 找到最小生成树里的关键边和伪关键边 - 力扣（LeetCode）](https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/submissions/)**

```c++
typedef struct {
    int start;
    int end;
    int weight;
    int index; 
}edge,*pEdge; 

class Solution {
public:
    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {
        vector<vector<int>> ans(2);
        vector<edge> Edges;
        for(int i=0;i<edges.size();++i){
            Edges.push_back({edges[i][0],edges[i][1],edges[i][2],i});
        }
        sort(Edges.begin(),Edges.end(),[](edge& e1,edge& e2){return e1.weight<e2.weight;});
        // for(int i=0;i<Edges.size();++i){
        //     cout<<Edges[i].weight<<" ";
        // }
        // cout<<endl;
        UF uf(n);
        int MST=0;
        for(int i=0;i<Edges.size();++i){
            if(uf.connected(Edges[i].start,Edges[i].end)) continue;
            uf.Union(Edges[i].start,Edges[i].end);
            MST += Edges[i].weight;
        }
        cout<<MST<<" ";
        for(int i=0;i<Edges.size();++i){
            // 判定是否是关键边
            uf.clear();
            int val = 0;
            for(int j=0;j<Edges.size();++j){
                if(i==j || uf.connected(Edges[j].start,Edges[j].end)) continue;
                uf.Union(Edges[j].start,Edges[j].end);
                val += Edges[j].weight;
            }
            if((val>MST && uf.count()==1) || (uf.count()>1)) {
                ans[0].push_back(Edges[i].index);
                continue;
            }
            // 判定是否是伪关键边
            val = 0;
            uf.clear();
            uf.Union(Edges[i].start,Edges[i].end);
            val += Edges[i].weight;
            for(int j=0;j<Edges.size();++j){
                if(uf.connected(Edges[j].start,Edges[j].end)) continue;
                uf.Union(Edges[j].start,Edges[j].end);
                val += Edges[j].weight;
            }
            if(val==MST && uf.count()==1) {
                ans[1].push_back(Edges[i].index);
                continue;
            }
        }
        return ans;
    }
};
```



#### 基础知识

**定义：**

​     给定一个无向网络，在该网的所有生成树中，使得各边权值之和最小的那颗生成树称为该网络的最小生成树，也称最小代价生成树。

**MST性质：**

![屏幕截图 2022-10-05 154744](初学上课笔记.assets\屏幕截图 2022-10-05 154744.png)

#### Prim（普里姆）算法（O(n^2)） 稠密图

**用matrix[] []**

![屏幕截图 2022-10-05 155108](初学上课笔记.assets\屏幕截图 2022-10-05 155108.png)

![屏幕截图_20221210_112847](初学上课笔记.assets\屏幕截图_20221210_112847.png)

```c++
#include <bits/stdc++.h>
using namespace std ;
typedef long long ll ;
const int N = 1e5+10 , M = 1e6+10 , inf = 0x7fffffff ;
int n , m , s = 1 , dis[N] , vis[N] , res ;
int h[N] , tot ;
struct edge{int to,w,ne;} e[M] ;
void add(int u,int v,int w){
    e[++tot] = {v,w,h[u]} ; h[u] = tot ;
}
bool prim(){
    for(int i=0;i<=n;++i) dis[i] = inf ; 
    dis[s] = 0 ; int cnt = 0 ;
    for(int i=1;i<=n;++i){
        int u = 0 ;
        for(int j=1;j<=n;++j){
            if(vis[j]) continue ;
            if(dis[u] > dis[j]) u = j ;
        }
        vis[u] = 1 ; res += dis[u] ;
        if(dis[u]!=inf) cnt++ ;
        for(int j=h[u];j;j=e[j].ne){
            int v = e[j].to , w = e[j].w ;
            if(vis[v]) continue ;
            if(dis[v] > w) dis[v] = w ;
        }
    }
    return cnt==n;
}
int main(){
    cin >> n >> m ; int u , v , w ;
    for(int i=1;i<=m;++i) cin >> u >> v >> w , add(u,v,w) , add(v,u,w);
    if(prim()) cout << res << endl ;
    else cout << "orz" << endl ; 
    system("pause") ;
}
```

```c++
// 堆优化版本
#include <bits/stdc++.h>
using namespace std ;
typedef long long ll ;
const int N = 1e5+10 , M = 1e6+10 , inf = 0x7fffffff ;
int n , m , s = 1 , dis[N] , vis[N] , res ;
int h[N] , tot ;
struct edge{int to,w,ne;} e[M] ;
void add(int u,int v,int w){
    e[++tot] = {v,w,h[u]} ; h[u] = tot ;
}
struct node{
    int v,dis;
    bool operator<(const node& e) const {return dis > e.dis;}  
};
bool prim(){
    int cnt = 0 ; fill(dis+1,dis+1+n,inf) ; dis[s] = 0 ; memset(vis,0,sizeof(vis)) ;
    priority_queue<node> q ; q.push({s,dis[s]}) ;
    while(q.size()){
        node u = q.top() ; q.pop() ;
        if(vis[u.v]) continue ;
        vis[u.v] = 1 ; cnt ++ ; res += u.dis ;
        for(int i=h[u.v];i;i=e[i].ne){
            int v = e[i].to , w = e[i].w ;
            if(dis[v] > w) dis[v] = w , q.push({v,dis[v]}) ;
        }
    }
    return cnt == n ;  // 判断是否联通
}
int main(){
    cin >> n >> m ; int u , v , w ;
    for(int i=1;i<=m;++i) cin >> u >> v >> w , add(u,v,w) , add(v,u,w);
    if(prim()) cout << res << endl ;
    else cout << "orz" << endl ; 
    system("pause") ;
}
```



#### Kruskal算法（O(eloge)） 稀疏图

**用Edges[m]**

![屏幕截图 2022-10-05 155429](初学上课笔记.assets\屏幕截图 2022-10-05 155429.png)

**判断回路：**初始状态下，为连通网中的各个顶点配置不同的标记。对于一个新边，如果它两端顶点的标记不同，就不会构成环路，可以组成最小生成树。一旦新边被选择，需要将它的两个顶点以及和它直接相连的所有已选边两端的顶点改为相同的标记；反之，如果新边两端顶点的标记相同，就表示会构成环路。（并查集）

**代码实现：**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4+10 , M = 2e5+10 ;
struct edge{int u,v,w;} e[M] ;
int fa[N] , n , m , res , cnt ;
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
int main(){
    cin >> n >> m ; for(int i=1;i<=n;++i) fa[i] = i; cnt = n ;
    for(int i=1;i<=m;++i) cin >> e[i].u >> e[i].v >> e[i].w ;
    sort(e+1,e+1+m,[&](auto& e1,auto& e2){return e1.w < e2.w;});
    for(int i=1;i<=m;++i){
        int u = e[i].u , v = e[i].v , w = e[i].w ;
        int fu = find(u) , fv = find(v) ;
        if(fu == fv) continue ;
        fa[fu] = fv ; cnt--; res += w ;
        if(cnt == 1) break ;
    }
    if(cnt == 1) cout << res << endl ;
    else cout << "orz" << endl ;
    system("pause");
}
```

### 最短路径

[单源最短路径](https://www.cnblogs.com/bcoier/p/10363284.html)

[最短路径问题---SPFA算法详解_](https://blog.csdn.net/qq_35644234/article/details/61614581)

#### Dijkstra算法模板（LG P3371）

**缺点：边权不能为负数[原因](https://blog.csdn.net/Kprogram/article/details/81220702)**

[P3371 【模板】单源最短路径（弱化版）)](https://www.luogu.com.cn/problem/P3371)

```c++
#include <bits/stdc++.h>
using namespace std ;
typedef long long ll ;
const int N = 1e5+10 , M = 1e6+10 , inf = 0x7fffffff ;
int n , m , s ,dis[N] , vis[N] ;
int h[N] , tot ;
struct edge{int to,w,ne;} e[M] ;
void add(int u,int v,int w){
    e[++tot] = {v,w,h[u]} ; h[u] = tot ;
}
void dijkstra(){
    for(int i=0;i<=n;++i) dis[i] = inf ; memset(vis,0,sizeof(vis)) ;
    dis[s] = 0 ;
    for(int i=1;i<=n;++i){
        int u = 0 ;
        for(int j=1;j<=n;++j) {
            if(vis[j]) continue ;
            if(dis[u] > dis[j]) u = j ;
        }
        vis[u] = 1; 
        for(int j=h[u];j;j=e[j].ne) {
            int v = e[j].to , w = e[j].w ;
            if(vis[v]) continue ;
            if(dis[v] > w + dis[u]) dis[v] = w + dis[u]; 
        }
    }
}
int main(){
    cin >> n >> m >> s ; int u , v , w ;
    for(int i=1;i<=m;++i) cin >> u >> v >> w , add(u,v,w) ;
    dijkstra() ; for(int i=1;i<=n;++i) cout << dis[i] << " " ; 
    system("pause") ;
}
```

#### Dijkstra算法模板堆优化（LG P4779）

[P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)

```c++
#include <bits/stdc++.h>
using namespace std ;
typedef long long ll ;
const int N = 1e5+10 , M = 1e6+10 , inf = 0x7fffffff ;
int n , m , s ,dis[N] , vis[N] ;
int h[N] , tot ;
struct edge{int to,w,ne;} e[M] ;
void add(int u,int v,int w){
    e[++tot] = {v,w,h[u]} ; h[u] = tot ;
}
struct node{
    int dis,pos ;
    bool operator<(const node& x) const {return dis > x.dis;}
};
void dijkstra(){
    for(int i=1;i<=n;++i) dis[i] = inf ; dis[s] = 0 ; memset(vis,0,sizeof(vis)) ;
    priority_queue<node> q; q.push({dis[s],s}) ;
    while(q.size()){
        int u = q.top().pos ; q.pop() ;
        if(vis[u]) continue ; vis[u] = 1 ;
        for(int i=h[u];i;i=e[i].ne){
            int v = e[i].to , w = e[i].w ;
            if(dis[v] > dis[u] + w) dis[v] = dis[u] + w , q.push({dis[v],v}) ;  
        }
    }
}
int main(){
    cin >> n >> m >> s ; int u , v , w ;
    for(int i=1;i<=m;++i) cin >> u >> v >> w , add(u,v,w) ;
    dijkstra() ; for(int i=1;i<=n;++i) cout << dis[i] << " " ; 
    system("pause") ;
}
```

#### SPFA算法模板（不稳定，慎用）（LG P3371）

[P3371 【模板】单源最短路径（弱化版）)](https://www.luogu.com.cn/problem/P3371)

```c++
#include <bits/stdc++.h>
using namespace std ;
typedef long long ll ;
const int N = 1e5+10 , M = 1e6+10 , inf = 0x7fffffff ;
int n , m , s ,dis[N] , inq[N] ;
int h[N] , tot ;
struct edge{int to,w,ne;} e[M] ;
void add(int u,int v,int w){
    e[++tot] = {v,w,h[u]} ; h[u] = tot ;
}
void spfa(){
    for(int i=1;i<=n;++i) dis[i] = inf ; dis[s] = 0 ; memset(inq,0,sizeof(inq));
    queue<int> q ; q.push(s) ; inq[s] = 1 ;
    while(q.size()) {
        int u = q.front() ; q.pop() ; inq[u] = 0 ;
        for(int i=h[u];i;i=e[i].ne){
            int v = e[i].to , w = e[i].w ;
            if(dis[v] > dis[u] + w){
                dis[v] = dis[u] + w ;
                if(inq[v]) continue ;
                inq[v] = 1; q.push(v) ;
            }
        }
    }
}
int main(){
    cin >> n >> m >> s ; int u , v , w ;
    for(int i=1;i<=m;++i) cin >> u >> v >> w , add(u,v,w) ;
    spfa() ; for(int i=1;i<=n;++i) cout << dis[i] << " " ; 
    system("pause") ;
}
```

#### 判定负环模板（LG P3385）

[P3385 【模板】负环 ](https://www.luogu.com.cn/problem/P3385)

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e3+1;
const int M = 2*3e3+2;
const int inf = 0x7fffffff;
int n,m,s=1;
int h[N],tot,dis[N],inq[N],cnt[N];
struct edge{
    int to,w,nex;
} e[M] ;
void add(int u,int v,int w){
    e[++tot] = {v,w,h[u]};
    h[u] = tot;
}
bool spfa(){
    for(int i=1;i<=n;++i) dis[i] = inf;
    memset(inq,0,sizeof(inq));
    queue<int> Q;
    Q.push(s); inq[s] = 1; dis[s] = 0 ;cnt[s]++;
    while(!Q.empty()) {
        int u = Q.front(); Q.pop() ; inq[u] = 0;
        for(int i=h[u];i;i=e[i].nex) {
            int v = e[i].to,w = e[i].w ;
            if(dis[v] > dis[u] + w ){
                dis[v] = dis[u] + w;
                if(!inq[v]) Q.push(v),inq[v] = 1,cnt[v]++;
                if(cnt[v] >= n) return false;
            }
        }
    }
    return true;
}
void init(){
    tot=0;
    memset(e,0,sizeof(e));
    memset(h,0,sizeof(h));
    memset(cnt,0,sizeof(cnt));
}
signed main(){
    int t;
    cin >> t;
    while(t--) {
        init();
        cin >> n >> m ;
        int u,v,w;
        for(int i=1;i<=m;++i) {
            cin >>u >> v >> w ;
            if(w >= 0) add(u,v,w),add(v,u,w);
            else add(u,v,w);
        } 
        if(spfa()) cout << "NO" << endl ;
        else cout << "YES" << endl ;
    }
    system("pause");
}
```

```c++
// dfs版本
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e3+1;
const int M = 2*3e3+2;
const int inf = 0x7fffffff;
int n,m,s=1;
int h[N],tot,dis[N],vis[N];
struct edge{
    int to,w,nex;
} e[M] ;
void add(int u,int v,int w){
    e[++tot] = {v,w,h[u]};
    h[u] = tot;
}
bool spfa(int u){
    vis[u] = true;
    for (int i = h[u]; i; i = e[i].nex){
        int v = e[i].to, w = e[i].w;
        if (dis[v] > dis[u] + w){
            dis[v] = dis[u] + w;
            if (vis[v] || !spfa(v)){
                vis[u] = false ; return false;
            }
        }
    }
    vis[u] = false;
    return true;
}

void init(){
    tot=0;
    memset(h,0,sizeof(h));
    memset(dis,0x3f,sizeof dis);
}
signed main(){
    int t;
    cin >> t;
    while(t--) {
        init();
        cin >> n >> m ;
        int u,v,w;
        for(int i=1;i<=m;++i) {
            cin >>u >> v >> w ;
            if(w >= 0) add(u,v,w),add(v,u,w);
            else add(u,v,w);
        } 
        dis[1] = 0 ;
        if(spfa(1)) cout << "NO" << endl ;
        else cout << "YES" << endl ;
    }
    system("pause");
}
```



#### 差分约数算法（LG P5960）

对于不同的题目，给出的条件都不一样，我们首先需要关注问题是什么，如果需要求的是两个变量差的最大值，那么需要将所有不等式转变成"<="的形式，建图后求最短路；相反，如果需要求的是两个变量差的最小值，那么需要将所有不等式转化成">="，建图后求最长路

[差分约束算法 - Stephen_Curry的博客 - 洛谷博客 (luogu.com.cn)](https://www.luogu.com.cn/blog/123StephenCurry/solution-p5960)

[差分约束，BFS-SPFA 与 DFS-SPFA 的优劣 - _kangkang - 博客园 (cnblogs.com)](https://www.cnblogs.com/kangkang-/p/11585506.html#:~:text=SPFA 有 BFS 和 DFS 两种实现方式，如果仅仅要判断是否存在负环，DFS-SPFA 要比,BFS-SPFA 快上很多。 但是在没有负环时要求出解，DFS-SPFA 会比 BFS-SPFA 慢很多。 例题：洛谷P1993 小K的农场)

[magolor 的博客 - 洛谷博客 (luogu.com.cn)](https://www.luogu.com.cn/blog/user16528/solution-p2294)

**题目[P5960 【模板】差分约束算法 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5960)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e5 +10 , M = 2e6 + 10 , inf = 1e9 ;
int n , m ; int S = 0 ;
int h[N] , tot ; struct node{int to,w,ne;}e[M] ; void add(int u,int v,int w){e[++tot]={v,w,h[u]};h[u]=tot;}
int dis[N] , vis[N] , cnt[N] ;
bool spfa(int s){
    memset(dis,0x3f,sizeof(dis)) ; memset(vis,0,sizeof(vis)) ;
    dis[s] = 0 ; queue<int> q ; q.push(s) ; vis[s] = 1 ;
    while(q.size()) {
        int u = q.front() ; q.pop() ; vis[u] = 0 ;
        for(int i=h[u];i;i=e[i].ne) {
            int v = e[i].to , w = e[i].w ;
            if(dis[v] > dis[u] + w){
                dis[v] = dis[u] + w ; 
                if(!vis[v]) q.push(v) , vis[v] = 1 , cnt[v] ++ ;
                if(cnt[v] == n + 1) return true ;
            }
        }
    }
    return false ;
}
int main(){
    cin >> n >> m ; int u , v , w ;
    for(int i=1;i<=m;++i) cin >> v >> u >> w , add(u,v,w) ;
    for(int i=1;i<=n;++i) add(S,i,0) ;
    if(spfa(S)) cout << "NO" << endl ;
    else {
        for(int i=1;i<=n;++i) cout << dis[i] << " " ; cout << endl ;
    }
    system("pause") ;
}
```



#### Johnson全源最短路（LG P5905）

**先跑spfa添加势能，再跑dijkstra n次**

[Johnson 全源最短路径算法学习笔记](https://studyingfather.blog.luogu.org/johnson-algorithm)

[P5905 【模板】Johnson 全源最短路)](https://www.luogu.com.cn/problem/P5905)

**SPFA进行n次，卡测试点**

```c++
#include <bits/stdc++.h>
using namespace std ;
typedef long long ll ;
const int N = 1e5+10 , M = 1e6+10 , inf = 1e9 ;
int n , m , dis[N] , inq[N] , cnt[N] , pe[N] , vis[N] ;  // pe(potential energy)势能，cnt计数判断有无负环圈
int h[N] , tot ;
struct edge{int to,w,ne;} e[M] ;
void add(int u,int v,int w){
    e[++tot] = {v,w,h[u]} ; h[u] = tot ;
}
bool spfa(int s){
    for(int i=1;i<=n;++i) pe[i] = inf ; pe[s] = 0 ; memset(inq,0,sizeof(inq));
    queue<int> q ; q.push(s) ; inq[s] = 1 ; 
    while(q.size()) {
        int u = q.front() ; q.pop() ; inq[u] = 0 ;
        for(int i=h[u];i;i=e[i].ne){
            int v = e[i].to , w = e[i].w ;
            if(pe[v] > pe[u] + w){
                pe[v] = pe[u] + w ;
                if(inq[v]) continue ;
                inq[v] = 1; cnt[v] ++ ; q.push(v) ;
                //注意在有重边的情况下要记录入队次数而不是松弛次数，以及因为新加入了一个0点，所以次数应该判n+1而不是n。
                if(cnt[v] >= n+1) return false;
            }
        }
    }
    return true ;
}
struct node{
    int dis,pos ;
    bool operator<(const node& x) const {return x.dis < dis;}
};
void dijkstra(int s){
    for(int i=1;i<=n;++i) dis[i] = inf ; dis[s] = 0 ; memset(vis,0,sizeof(vis)) ;
    priority_queue<node> q; q.push({dis[s],s}) ;
    while(q.size()){
        int u = q.top().pos ; q.pop() ;
        if(vis[u]) continue ; vis[u] = 1 ;
        for(int i=h[u];i;i=e[i].ne){
            int v = e[i].to , w = e[i].w ;
            if(dis[v] > dis[u] + w) dis[v] = dis[u] + w , q.push({dis[v],v}) ;  
        }
    }
}
void Johnson(){
    for(int i=1;i<=n;++i) add(0,i,0) ;
    if(!spfa(0)){cout << -1 << endl ; return ;}
    for(int u=1;u<=n;++u) for(int i=h[u];i;i=e[i].ne)
        e[i].w += pe[u] - pe[e[i].to] ;
    for(int i=1;i<=n;++i) {
        dijkstra(i) ; 
        ll ans = 0;
        for (int j = 1; j <= n; ++j) {
            if(dis[j]==inf) ans += 1LL*j*inf;
			else ans += 1LL*j*(dis[j]+(pe[j]-pe[i]));
        }
        cout << ans << endl;
    }
}
int main(){
    cin >> n >> m ; int u , v , w ;
    for(int i=1;i<=m;++i) cin >> u >> v >> w , add(u,v,w) ;
    Johnson() ;
    system("pause") ;
}
```

#### 无向图的最小环问题（Floyd模板题）

**题目：[P6175 无向图的最小环问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P6175)**

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std ;
typedef long long ll ;
const int N = 1e2+1 , inf = 1e9 ;
int n , m , ans = inf ; int w[N][N] , d[N][N] ;
signed main(){
    cin >> n >> m ; int u , v , c ;
    for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) if(i!=j) w[i][j] = inf ;
    for(int i=1;i<=m;++i) cin >> u >> v >> c , w[u][v]=w[v][u]=min(w[u][v],c) ;
    memcpy(d,w,sizeof(w)) ;
    for(int k=1;k<=n;++k){
        for(int i=1;i<k;++i) for(int j=i+1;j<k;++j) { // 求环
            ans = min(ans , d[i][j] + w[i][k] + w[k][j]) ;
        }
        for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) {  // floyd
            d[j][i] = d[i][j] = min(d[i][j],d[i][k]+d[k][j]) ;
        }
    }
    if(ans == inf) cout << "No solution." << endl ;
    else cout << ans << endl ;
    system("pause") ;
}
```



### 拓扑排序

**拓扑排序可以保证动态规划的无后效性。**

**针对：DAG 有向无环图**

**方法一：**DFS

[拓扑排序（DFS）](https://blog.csdn.net/qq_45349225/article/details/104810318)

```c++
stack<int> S;  // 拓扑排序
int visited[maxN];  // 0代表未访问，1代表正在访问，2代表访问完毕
void DFS(int u){
    if(visited[u]==2) return;
    visited[u] = 1;
    for(int i=head[u];i!=0;i=edges[i].next){
        if(visited[edges[i].to]==1){
            cout<<"存在回边"<<endl;continue;
        }else if(visited[edges[i].to]==2){
            continue;
        }
        DFS(edges[i].to);
    }
    S.push(u); 
    visited[u] = 2;
}
```

**方法二：**

[拓扑排序 Topological Sorting](https://blog.csdn.net/lisonglisonglisong/article/details/45543451)

1. 从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。
2. 从图中删除该顶点和所有以它为起点的有向边。
3. 重复 1 和 2 直到当前的 DAG 图为空或**当前图中不存在无前驱的顶点为止**。后一种情况说明有向图中必然存在环。

```c++
bool topoSort(){
    queue<int> Q; int cnt = 0 ;
    for(int i=1;i<=n;++i){
        if(inDegree[i]==0) Q.push(i);
    }
    while(!Q.empty()){
        int size = Q.size();
        for(int i=0;i<size;++i){
            int u = Q.front(); Q.pop(); cnt ++ ;
            for(int j=head[u];j!=0;j=edges[j].next){
                int v = edges[j].to;
                inDegree[v]--;
                if(inDegree[v]==0) Q.push(v);
            }
        }
    }
    return cnt == n ;
}
```

### 检测是否有环

[判断无向图/有向图中是否存在环 ](https://www.cnblogs.com/wangkundentisy/p/9320499.html)

**无向图：**可以用 fa(pai) 数组判断

**有向图：**可以增加 visited 数组的状态判断。或者利用拓扑排序

# 网络流

**参考：**

[[网络流]学习笔记：一次理解网络流！](https://blog.csdn.net/A_Comme_Amour/article/details/79356220)

[[算法竞赛入门\] 网络流基础：理解最大流/最小割定理](https://www.bilibili.com/video/BV1Q7411R7ie/?spm_id_from=333.788.recommend_more_video.-1&vd_source=787f243f7baf8e15cdf94b95889673a0)

## 网络流的概念

**网络流:** 所有弧上流量的集合f={f(u,v)},称为该容量网络的一个网络流.

**定义：**带权的有向图G=(V,E)，满足以下条件，则称为网络流图(flow network)：

- 仅有一个入度为0的顶点s，称s为源点
- 仅有一个出度为0的顶点t，称t为汇点
- 每条边的权值都为非负数，称为该边的容量，记作c ( i , j ) 。

**弧的流量:** 通过容量网络G中每条弧< u,v> , 上的实际流量(简称流量),记为f ( u , v ) ;

## 性质

- 容量限制：对任意u,v∈V，f(u,v) ≤ c(u,v)。
- 反对称性：对任意u,v∈V，f(u,v) = -f(v,u)。从u到v的流量一定是从v到u的流量  的相反值。
- 流守恒性：对任意u，若u不为S或T，一定有∑f(u,v)=0，(u,v)∈E。即u到相邻节点的流量之和为0，因为流入u的流量和u点流出的流量相等，u点本身不会”制造”和”消耗”流量。

## 网络的割

![这里写图片描述](初学上课笔记.assets\70-1670599352727-12.png)

**无向图的割集(Cut Set)**:C[A,B]是将图G分为A和B两个点集 A和B之间的边的全集
**网络的割集**:C[S,T]是将网络G分为s和t两部分点集 S属于s且T属于t 从S到T的边的全集
**带权图的割(Cut)**：就是割集中边或者有向边的权和

## 最大流与最小割

![这里写图片描述](初学上课笔记.assets\70-1670599170303-3.png)

![屏幕截图_20221210_000418](初学上课笔记.assets\屏幕截图_20221210_000418.png)



## 残留容量

给定容量网络G(V,E),及可行流f,弧< u,v>上的残留容量记为`cl(u,v)=c(u,v)-f(u,v)`.每条弧上的残留容量表示这条弧上可以增加的流量.因为从顶点u到顶点v的流量减少,等效与从顶点v到顶点u的流量增加,所以每条弧< u,v>上还有一个反方向的残留容量`cl(v,u)=-f(u,v).`

## 残余网络 (Residual Network)

在一个网络流图上，找到一条源到汇的路径（即找到了一个流量）后，对路径上所有的边，其容量都减去此次找到的量，对路径上所有的边，都添加一条反向边，其容量也等于此次找到的流量，这样得到的新图，就称为原图的“残余网络”

## 费用流

![这里写图片描述](初学上课笔记.assets\70-1670599641469-14.png)

## 最大流算法

**参考：[13-1: 网络流问题基础 Network Flow Problems_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1K64y1C7Do/?spm_id_from=333.788&vd_source=787f243f7baf8e15cdf94b95889673a0)**

### 模板题目

[P3376 【模板】网络最大流 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3376)

### Ford-Fulkerson算法

注：和EK算法一摸一样，只是搜索方式不是最短路搜索。

### Edmonds-Karp算法

```c++
#include <bits/stdc++.h>
using namespace std ;
typedef long long ll ;
const int N = 1e4+10 , M = 1e6+10 , inf = 0x3fffffff ;
int s , t , n , m , mf[N] , pre[N] ; // 存v的前驱边,S-v的流量上限,
int h[N] , tot = 1 ; // 边从2开始保证正反边进行异或操作能快速找到
struct edge{int to,c,ne;} e[M] ;
void add(int u,int v,int c){
    e[++tot] = {v,c,h[u]} ; h[u] = tot ;
    e[++tot] = {u,0,h[v]} ; h[v] = tot ;
}
bool bfs(){
    memset(mf,0,sizeof(mf)) ;
    queue<int> q ; q.push(s) ; mf[s] = inf ;
    while(q.size()){
        int u = q.front() ; q.pop() ;
        for(int i=h[u];i;i=e[i].ne){
            int v = e[i].to , c = e[i].c ;
            if(!mf[v] && c){
                q.push(v) ; mf[v] = min(mf[u],c) ; pre[v] = i ;
                if(v == t) return true ;
            }
        }
    }
    return false ;
}
ll EK(){
    ll flow = 0;
    while(bfs()){
        flow += (ll)mf[t] ; int v = t ;
        while(v != s){
            int i = pre[v] ;
            e[i].c -= mf[t] ; e[i^1].c += mf[t] ;
            v = e[i^1].to ;
        }
    }
    return flow ;
}
int main(){ 
    cin >> n >> m >> s >> t ; int u , v , c ;
    for(int i=1;i<=m;++i) cin >> u >> v >> c , add(u,v,c) ;
    cout << EK() << endl ;
    system("pause") ;
}
```

### Dinic算法

```c++
#include <bits/stdc++.h>
using namespace std ;
typedef long long ll ;
const int N = 1e4+10 , M = 1e6+10 , inf = 0x3fffffff ;
int s , t , n , m , cur[N] , d[N] ;  // cur优化，d层数
int h[N] , tot = 1 ; // 边从2开始保证正反边进行异或操作能快速找到
struct edge{int to,c,ne;} e[M] ;
void add(int u,int v,int c){
    e[++tot] = {v,c,h[u]} ; h[u] = tot ;
    e[++tot] = {u,0,h[v]} ; h[v] = tot ;
}
bool bfs(){
    memset(d,0,sizeof(d)) ;
    queue<int> q ; q.push(s) ; d[s] = 1 ;
    while(q.size()){
        int u = q.front() ; q.pop() ;
        for(int i=h[u];i;i=e[i].ne){
            int v = e[i].to , c = e[i].c ;
            if(!d[v] && c){
                q.push(v) ; d[v] = d[u] + 1 ;
                if(v == t) return true ;
            }
        }
    }
    return false ;
}
ll dfs(int u,int mf){
    if(u == t) return mf ;
    ll sum = 0;
    for(int i=cur[u];i;i=e[i].ne){
        cur[u] = i ; int v = e[i].to , c = e[i].c ;
        if(d[v] == d[u] + 1 && c){
            ll f = dfs(v,min(mf,c)) ;
            e[i].c -= f ; e[i^1].c += f ; sum += f ; mf -= f ;
            if(mf == 0) break ; 
        }
    }
    if(sum == 0) d[u] = 0;
    return sum ;
}
ll dinic(){
    ll flow = 0;
    while(bfs()){
        memcpy(cur,h,sizeof(h));
        flow += dfs(s,inf) ;
    }
    return flow ;
}
int main(){ 
    cin >> n >> m >> s >> t ; int u , v , c ;
    for(int i=1;i<=m;++i) cin >> u >> v >> c , add(u,v,c) ;
    cout << dinic() << endl ;
    system("pause") ;
}

```

### ISAP算法

**因为我们是按照深度来往前走的，路径上的点的深度一定是连续的，而t的深度为0，如果某个深度的点不存在，那么我们就无法到达t了**

**参考：[究级的最大流算法：ISAP与HLPP - 钱逸凡 的博客 - 洛谷博客 (luogu.com.cn)](https://www.luogu.com.cn/blog/ONE-PIECE/jiu-ji-di-zui-tai-liu-suan-fa-isap-yu-hlpp)**

```C++
#include <bits/stdc++.h>
using namespace std ;
typedef long long ll ;
const int N = 1e4+10 , M = 1e6+10 , inf = 0x3fffffff ;
int s , t , n , m , cur[N] , d[N] , g[N] ;  // cur优化，d[i]表示节点i的深度(到t)，g[i]表示（到t）距离的数量 
ll maxflow;
int h[N] , tot = 1 ; // 边从2开始保证正反边进行异或操作能快速找到
struct edge{int to,c,ne;} e[M] ;
void add(int u,int v,int c){
    e[++tot] = {v,c,h[u]} ; h[u] = tot ;
    e[++tot] = {u,0,h[v]} ; h[v] = tot ;
}
void bfs(){
    memset(d,-1,sizeof(d)) ; memset(g,0,sizeof(g)) ;
    queue<int> q ; q.push(t) ; d[t] = 0 ; g[0] = 1 ;
    while(q.size()){
        int u = q.front() ; q.pop() ;
        for(int i=h[u];i;i=e[i].ne){
            int v = e[i].to , c = e[i].c ;
            if(d[v]!=-1) continue ;
            q.push(v) ; d[v] = d[u] + 1; g[d[v]]++ ;
        }
    }
}
int dfs(int u,int mf){
    if(u == t) {maxflow += mf ;return mf ;}
    int sum = 0 ;
    for(int i=cur[u];i;i=e[i].ne){
        cur[u] = i ; int v = e[i].to , c = e[i].c ;
        if(d[v] + 1 == d[u] && c){
            int f = dfs(v,min(mf,c)) ;
            e[i].c -= f ; e[i^1].c += f ; sum += f ; mf -= f ;
            if(mf == 0) return sum ;
        }
    }
    if(--g[d[u]] == 0) d[s] = n + 1 ;
    d[u]++ ; g[d[u]]++ ;
    return sum ;
}
ll ISAP(){
    maxflow = 0; bfs() ;
    while(d[s] < n){
        memcpy(cur,h,sizeof(h));
        dfs(s,inf) ;
    }
    return maxflow ;
}
int main(){ 
    cin >> n >> m >> s >> t ; int u , v , c ;
    for(int i=1;i<=m;++i) cin >> u >> v >> c , add(u,v,c) ;
    cout << ISAP() << endl ;
    system("pause") ;
}

```



## 费用流算法

**EK算法改进，将bfs换成spfa算法**

**模板题：**

[P3381 【模板】最小费用最大流 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3381)

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 5e3 + 2;
const int M = 2*(5e4+3);
const int inf = 0x7fffffff;
int n,m,S,T;  // 起点，终点
int mf[N],d[N];  // S-v的流量上限和费用
int pre[N];  // 存v的前驱边
bool vis[N],inq[N];
struct edge {
    int to,c,w,nex;
} e[M] ;
int h[N] , tot = 1; // 小技巧，边从2开始保证正反边进行异或操作能快速找到
void add(int u,int v,int c,int w) { // add(u,v,c),add(v,u,0);
    e[++tot] = {v,c,w,h[u]};
    h[u] = tot;
}
bool spfa() {
    memset(d,0x3f,sizeof(d));
    memset(mf,0,sizeof(mf));
    queue<int> Q;
    Q.push(S);mf[S] = inf; inq[S] = 1;d[S] = 0;
    while(!Q.empty()) {
        int u = Q.front();Q.pop();inq[u] = 0;
        for(int i=h[u];i;i=e[i].nex) {
            int v = e[i].to , c = e[i].c , w = e[i].w ;
            if(d[v] > d[u] + w && c) {
                d[v] = d[u] + w;
                mf[v] = min(mf[u],c);
                pre[v] = i;
                if(!inq[v]) {
                    Q.push(v);
                    inq[v] = 1;
                }
            }
        }
    }
    return mf[T] > 0;
}
pair<int,int> EK(){
    int flow = 0,cost = 0;
    while(spfa()) {
        int v = T;
        while(v != S) {
            int i = pre[v];
            e[i].c -= mf[T];
            e[i^1].c += mf[T];
            v = e[i^1].to ;
        }
        flow += mf[T];
        cost += d[T]*mf[T];
    }
    return {flow,cost};
}
void mincut(int u) {
    vis[u] = 1;
    for(int i=h[u];i;i=e[i].nex) {
        int v = e[i].to;
        if(vis[v] == 0 && e[i].c) mincut(v);
    }
}
signed main(){
    cin >> n >> m >> S >> T ;
    int u,v,c,w;
    for(int i=1;i<=m;++i) {
        cin >> u >> v >> c >> w ;
        add(u,v,c,w);
        add(v,u,0,-w);
    }
    auto ans = EK();
    cout << ans.first << " " << ans.second << endl ;
    // mincut(S);
    // cout << "S : " ;
    // for(int i=1;i<=n;++i) if(vis[i]) cout << i << " " ;
    // cout << endl << "T : ";
    // for(int i=1;i<=n;++i) if(!vis[i]) cout<< i << " ";
    // cout << endl ; 
    system("pause");
}
```

```c++
// dinic
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 5e3 + 2;
const int M = 2*(5e4+3);
const int inf = 0x7fffffff;
int n,m,S,T;  // 起点，终点
using ll = long long ;

int h[N] , tot = 1 ;
struct qwq{int to,w,c,ne;}adj[M] ;
void add(int u,int v,int w,int c){
    adj[++tot] = {v,w,c,h[u]} ; h[u] = tot ;
    adj[++tot] = {u,-w,0,h[v]} ; h[v] = tot ;
}

int vis[N] , dis[N] ;
bool spfa(int s,int t){
    memset(vis,0,sizeof(vis)) ; memset(dis,0x3f,sizeof(dis)) ;
    queue<int> q ; q.push(s) ; vis[s] = 1 ; dis[s] = 0 ;
    while(q.size()){
        int u = q.front() ; q.pop() ; vis[u] = 0 ;
        for(int i=h[u];i;i=adj[i].ne){
            int v = adj[i].to , w = adj[i].w , c = adj[i].c ;
            if(c && dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w ; 
                if(!vis[v]) q.push(v) , vis[v] = 1 ;
            }
        }   
    }
    return dis[t] < inf;
}

ll minCost ;
ll dfs(int u,int t,ll mf){
    if(u == t) return mf ;
    ll sum = 0; vis[u] = 1 ;
    for(int i=h[u];i;i=adj[i].ne){
        int v = adj[i].to , w = adj[i].w , c = adj[i].c ;
        if(dis[v] == dis[u] + w && c && !vis[v]){
            ll f = dfs(v,t,min(mf,(ll)c)) ;
            adj[i].c -= f ; adj[i^1].c += f ; 
            sum += f ; mf -= f ; minCost += f * w ;
            if(mf == 0) break ;
        }
    }
    if(sum == 0) dis[u] = 0 ;
    return sum ;
}

pair<ll,ll> dinic(int s,int t){
    ll mf = 0 ; minCost = 0 ;
    while(spfa(s,t)){
        memset(vis,0,sizeof(vis)) ;
        mf += dfs(s,t,inf) ;
    }
    return {mf,minCost} ;
}
signed main(){
    cin >> n >> m >> S >> T ;
    int u,v,c,w;
    for(int i=1;i<=m;++i) {
        cin >> u >> v >> c >> w ;
        add(u,v,w,c);
    }
    auto ans = dinic(S,T);
    cout << ans.first << " " << ans.second << endl ;
    system("pause");
}
/*

*/
```

```c++

```



## 最小割算法

**回溯搜索残余网络**

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 201;
const int M = 2*5005;
const int inf = 0x7fffffff;
int n,m,S,T;  // 起点，终点
int mf[N];  // S-v的流量上限
int pre[N];  // 存v的前驱边
struct edge {
    int to,c,nex;
} e[M] ;
int h[N] , tot = 1; // 小技巧，边从2开始保证正反边进行异或操作能快速找到
void add(int u,int v,int c) { // add(u,v,c),add(v,u,0);
    e[++tot] = {v,c,h[u]};
    h[u] = tot;
}
bool bfs() {
    memset(mf,0,sizeof(mf));
    queue<int> Q;
    Q.push(S); mf[S] = inf;
    while(!Q.empty()) {
        int u = Q.front();Q.pop();
        for(int i=h[u];i;i=e[i].nex) {
            int v = e[i].to;
            int c = e[i].c;
            if(mf[v]==0 && c) {
                Q.push(v);
                mf[v] = min(mf[u],c);
                pre[v] = i;
                if(v == T) return true; 
            }
        }
    }
    return false;
}
int EK(){
    int flow = 0;
    while(bfs()) {
        int v = T;
        while(v != S) {
            int i = pre[v];
            e[i].c -= mf[T];
            e[i^1].c += mf[T];
            v = e[i^1].to ;
        }
        flow += mf[T];
    }
    return flow;
}
bool vis[N];
void mincut(int u) {
    vis[u] = 1;
    for(int i=h[u];i;i=e[i].nex) {
        int v = e[i].to;
        if(vis[v] == 0 && e[i].c) mincut(v);
    }
}
signed main(){
    cin >> n >> m >> S >> T ;
    int u,v,c;
    for(int i=1;i<=m;++i) {
        cin >> u >> v >> c ;
        add(u,v,c);
        add(v,u,0);
    }
    cout << EK() << endl ;
    mincut(S);
    cout << "S : " ;
    for(int i=1;i<=n;++i) if(vis[i]) cout << i << " " ;
    cout << endl << "T : ";
    for(int i=1;i<=n;++i) if(!vis[i]) cout<< i << " ";
    cout << endl ; 
    system("pause");
}

```

## 二分图

**参考：[14-1: 二部图及其判定算法 Bipartite Graphs_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV14q4y1j776/?spm_id_from=333.788&vd_source=787f243f7baf8e15cdf94b95889673a0)**

### 判断二分图（染色法）

bfs红蓝交替出现

**题目：[785. 判断二分图 - 力扣（LeetCode）](https://leetcode.cn/problems/is-graph-bipartite/)**

```c++
#include <bits/stdc++.h>
using namespace std;
struct edge{
    int to,ne;
} e[(int)1e5+1];
int h[(int)1e4+1],tot,color[(int)1e4+1];
int n,m;
void add(int u,int v){
    e[++tot] = {v,h[u]};
    h[u] = tot;
}
bool dfs(int u,int c) {
    color[u] = c;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to;
        if(!color[v]){
            if(dfs(v,3-c)) return true; // 1 和 2 反复出现
        } else if(color[v]==c) return true; // 有奇环
    }
    return false;
}
int main(){
    cin >> n >> m ;
    int u,v,tag=false;
    for(int i=1;i<=m;++i) cin >> u >> v , add(u,v) , add(v,u);
    for(int i=1;i<=n;++i){
        if(!color[i]){
            if(dfs(i,1)) {
                tag = true;
                break;
            }
        }
    }
    if(tag) cout << "不是二分图 " << endl ;
    else cout << "是二分图 " << endl ;
    system("pause");
}
```

### 二分图的最大匹配（匈牙利算法）

**模板题目：[P3386 【模板】二分图最大匹配 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3386)**

```c++
// 匈牙利算法
#include <bits/stdc++.h>
using namespace std;
const int N = 1001;
const int M = 5e4+1;
struct edge{int to,ne;} e[M];
int h[N],vis[N],ma[N],tot;
int n,m,k,ans;
void add(int u,int v){
    e[++tot] = {v,h[u]};
    h[u] = tot;
}
bool dfs(int u) {
    for(int i=h[u];i;i=e[i].ne) {
        int v = e[i].to;
        if(vis[v]) continue;
        vis[v] = 1;
        if(!ma[v] || dfs(ma[v])) {
            ma[v] = u;
            return true;
        }
    }
    return false;
}
int main(){
    cin >> n >> m >> k ;
    int u,v ;
    for(int i=0;i<k;++i) cin >> u >> v ,add(u,v);  
    for(int i=1;i<=n;++i){
        memset(vis,0,sizeof(vis));
        if(dfs(i)) ans++;
    }
    cout << ans << endl ;
    system("pause");
}
```

```c++
// 最大流算法
#include <bits/stdc++.h>
using namespace std;
const int N = 1006;
const int M = 1e6;
struct edge{int to,c,ne;} e[M];
int h[N],tot=1,d[N],cur[N];
int n,m,k,ans,S,T;
void add(int u,int v,int c){
    e[++tot] = {v,c,h[u]};
    h[u] = tot;
}
bool bfs(){
    memset(d,0,sizeof(d));
    queue<int> Q;
    Q.push(S);d[S] = 1;
    while(Q.size()) {
        int u = Q.front();Q.pop();
        for(int i=h[u];i;i=e[i].ne) {
            int v = e[i].to;
            int c = e[i].c;
            if(d[v]==0 && c) {
                Q.push(v);
                d[v] = d[u] + 1;
                if(v == T) return true;
            }
        }
    }
    return false;
}
int dfs(int u,int mf){
    if(u == T) return mf;
    int sum = 0;
    for(int i=cur[u];i;i=e[i].ne) {
        cur[u] = i;
        int v = e[i].to;
        if(d[v] == d[u] + 1 && e[i].c) {
            int f = dfs(v,min(mf,e[i].c));
            sum += f;
            mf -= f;
            e[i].c -= f;
            e[i^1].c += f;
            if(mf==0) break;
        }
    }
    if(sum==0) d[u] = 0;
    return sum;
}
int dinic(){
    int flow=0;
    while(bfs()) {
        memcpy(cur,h,sizeof(h));
        flow += dfs(S,1e9);
    }
    return flow ;
}
int main(){
    cin >> n >> m >> k ;
    S = n+m+1;
    T = n+m+2;
    int u,v ;
    for(int i=0;i<k;++i) {
        cin >> u >> v ;
        if(u > n || v > m) continue;
        add(u,v+n,1);add(v+n,u,0);  
    }
    for(int i=1;i<=n;++i) add(S,i,1),add(i,S,0);
    for(int i=n+1;i<=(n+m);++i) add(i,T,1),add(T,i,0);
    cout << dinic() << endl ;
    system("pause");
}
```

### 二分图的最大权完美匹配（KM算法）

**完美匹配：**左右两边点数相等，均为N，如果最大匹配为N，则是完美匹配

**可行顶标：**给每个节点分配一个权值 `la[x],lb[y]`，对于所有的边 `(x,y)`，满足 `la[x]+lb[y] >= w(x,y)`。

**相等子图：**在一组可行顶标下的原图生成的子图，包含所有点，包含部分边，其中边满足 `la[x] + lb[y] = w(x,y)`。

**重要定理：**如果相等子图存在完美匹配，则该匹配就是二分图的最大权完美匹配

**算法流程：**

![屏幕截图_20221223_150624](初学上课笔记.assets\屏幕截图_20221223_150624.png)

**相关处理：**

考虑到二分图中两个集合中的点并不总是相同，为了能应用 KM 算法解决二分图的最大权匹配，需要先作如下处理：将两个集合中点数比较少的补点，使得两边点数相同，再将不存在的边权重设为 ，这种情况下，问题就转换成求 **最大权完美匹配问题**，从而能应用 KM 算法求解。

**转化为费用流模型：**

在图中新增一个源点和一个汇点。

从源点向二分图的每个左部点连一条流量为 ，费用为 的边，从二分图的每个右部点向汇点连一条流量为 ，费用为 的边。

接下来对于二分图中每一条连接左部点 和右部点 ，边权为 的边，则连一条从 到 ，流量为 ，费用为 的边。

求这个网络的 [最大费用最大流](https://oi-wiki.org/graph/flow/min-cost/) 即可得到答案。

**模板题目：[P6577 【模板】二分图最大权完美匹配 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P6577)**

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e3+10 , M = 2e6+10 , inf = 1e18 ;
int n , m , w[N][N] ; int ma[N] , d[N];
int la[N] , lb[N] , va[N] , vb[N] , delta ;
bool dfs(int u){
    va[u] = 1 ;
    for(int v=1;v<=n;++v){
        if(!vb[v] && la[u] + lb[v] == w[u][v]){
            vb[v] = 1 ;
            if(!ma[v] || dfs(ma[v])){
                ma[v] = u ; return true ;
            }
        } else if(!vb[v]) d[v] = min(d[v],la[u] + lb[v] - w[u][v]) ;
    }
    return false ;
}
int KM() {
    // 处理顶标
    fill(la+1,la+n+1,-inf) ; fill(lb+1,lb+n+1,0) ;
    for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) la[i] = max(la[i],w[i][j]) ;
    // 开始处理左部分每个顶点
    for(int i=1;i<=n;++i){
        while(true){  // 直到找到匹配点
            fill(va+1,va+n+1,0) ; fill(vb+1,vb+n+1,0) ; delta = inf ; // 主要用来处理顶标的
            fill(d+1,d+n+1,inf) ;
            if(dfs(i)) break ;
            for(int j=1;j<=n;++j) if(!vb[j]) delta = min(delta,d[j]) ;
            for(int j=1;j<=n;++j){
                if(va[j]) la[j] -= delta ;
                if(vb[j]) lb[j] += delta ;
            }
        }
    }
    int res = 0;
    for(int i=1;i<=n;++i){
        if(w[ma[i]][i] == -inf){cout << "不存在完美匹配！" << endl ; break ; }
        res += w[ma[i]][i];
    }
    return res;
}
signed main(){
    cin >> n >> m ; int u , v , c ;
    for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) w[i][j] = -inf ;  // 如果需要判定不存在完美匹配就-inf，如果只需要最大权就0
    for(int i=1;i<=m;++i) cin >> u >> v >> c , w[u][v] = max(w[u][v],c) ;
    cout << KM() << endl ;
    for(int i=1;i<=n;++i) cout << ma[i] << " " ;
    system("pause") ;
}
```



# 并查集

**并查集适合合并，不适合分离，遇见分离的题目可以倒序进行，将分离转化成为合并  **

## 理论知识

- **合并**（Union）：把两个不相交的集合合并为一个集合。

- **查询**（Find）：查询两个元素是否在同一个集合中。

  可以判定图是否连通

## 简易版本

```c++
struct DSU{
    std::vector<int> fa , siz ;
    DSU(int n){
        fa.resize(n+1) ; siz.resize(n+1) ;
        for(int i=1;i<=n;++i){
            fa[i] = i ; 
            siz[i] = 1 ;
        }
    }
    int find(int x) {return x==fa[x]?fa[x]:fa[x]=find(fa[x]);}
    void merge(int x,int y){
        int xx = find(x) , yy = find(y) ;
        if(xx == yy) return ;
        fa[xx] = fa[yy] ;
        siz[yy] += siz[xx] ;
    }
    bool connected(int x,int y){return find(x) == find(y);}
} ;
```



## 普通版本

```c++
class UF{
private:
    int* eleGroup;  // 元素的节点标识符
    int _count;  // 元素分组的个数
    int* _size;  // 每个树的大小  
    int _maxN;  //  数组的最大值 
public:
    UF(int N){  // 初始化N个分组和其父节点下标
        _maxN = N;
        _count = _maxN;
        eleGroup = new int[_maxN];
        _size = new int[_maxN];
        for(int i=0;i<_maxN;++i){
            eleGroup[i] = i;
            _size[i]=1;
        }
    }
    ~UF(){  // 析构函数
        if(eleGroup != NULL){
            delete[] eleGroup;
            eleGroup = NULL;
        }
        if(_size != NULL){
            delete[] _size;
            _size = NULL;
        }
    }
    int count(){  // 返回分组的个数
        return this->_count;
    }
    bool connected(int p,int q){  // 查询p和q是否在同一个分组
        return find(p) == find(q);
    }
    int find(int p){  // 查询p的分组的父节点下标,保证p不超过数组长度
        if(p >= _maxN) return -1;
        if(p!=eleGroup[p]) eleGroup[p] = find(eleGroup[p]);
        return eleGroup[p]
    }
    void Union(int p,int q){  // 合并p和q所在的分组，保证p和q不超过数组长度
        int pRoot = find(p);
        int qRoot = find(q);
        if(pRoot == -1 || qRoot == -1 || pRoot==qRoot)  return;
        if(_size[qRoot] > _size[pRoot]){
            eleGroup[pRoot] = eleGroup[qRoot];
            _size[qRoot] += _size[pRoot];
        }else{
            eleGroup[qRoot] = eleGroup[pRoot];
            _size[pRoot] += _size[qRoot];
        }
        this->_count--;
    }
    void clear(){
        _count = _maxN;
        eleGroup = new int[_maxN];
        _size = new int[_maxN];
        for(int i=0;i<_maxN;++i){
            eleGroup[i] = i;
            _size[i]=1;
        }
    }
};
```

## 模板例题

[P3367 【模板】并查集 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3367#submit)

```c++
#include <bits/stdc++.h>
using namespace std;
#define maxN 10001
#define maxM 200001
int n,m;
int ele[maxN];
void Init(){
	for(int i=1;i<=n;++i) ele[i] = i;
}
int find(int x){
	if(ele[x]!=x) ele[x] = find(ele[x]);
	return ele[x];
}
bool connexted(int x,int y){return find(x)==find(y);}
void merge(int x,int y){
	int fx = find(x);
	int fy = find(y);
	if(fx == fy) return;
	ele[fx] = ele[fy];
}
int main() {
	scanf("%d %d",&n,&m);
	Init();
	while(m--){
		int x,y,z;
		scanf("%d %d %d",&z,&x,&y);
		if(z==1){
			merge(x,y);
		}else{
			if(connexted(x,y)) printf("Y\n");
			else printf("N\n");
		}
	}
	system("pause");
	return 0;
}
/*
4 7
2 1 2
1 1 2
2 1 2
1 3 4
2 1 4
1 2 3
2 1 4
*/
```

# ST表

**参考：[【朝夕的ACM笔记】数据结构-ST表 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/123360481)**

## **简介：**

**ST表**（Sparse Table，**稀疏表**）是一种简单的数据结构，主要用来解决**RMQ**（Range Maximum/Minimum Query，**区间最大/最小值查询**）问题。它主要应用**倍增**的思想，可以实现 O(nlog⁡n) 预处理、 O(1) 查询。

## **用途：**

ST表常用于解决**可重复贡献问题**。

什么是可重复贡献问题？

举例来说：要你求10个数中的最大数，你完全可以先求前6个数的 max ，再求后7个数的 max ，然后再对所求的两个最大数求 max 。虽然中间有几个数被重复计算了，但并不影响最后的答案。

**常见的可重复贡献问题有：**区间最值、区间按位和、区间按位或、区间GCD等。二而像区间和这样的问题就不是可重复贡献问题。

## **计算：**

![屏幕截图_20221201_123519](初学上课笔记.assets\屏幕截图_20221201_123519.png)

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10 ;
int n , m , nums[N] , Log2[N] ;
int f[N][21] ; // 1 << 20  > 1e6
void init(){
    for (int i = 2; i <= n; ++i)
        Log2[i] = Log2[i / 2] + 1;
}
void CreatStTable(){
    for(int i=1;i<=n;++i) f[i][0] = nums[i] ;
    for(int j=1;j<=Log2[n];++j) for(int i=1;(1 << j)+i-1<=n;++i) {
        f[i][j] = max(f[i][j-1],f[i+(1 << j-1)][j-1]) ;
    }
}
int query(int l,int r){
    int j = Log2[r - l + 1] ;
    return max(f[l][j] , f[r + 1 - (1 << j)][j]) ; 
}
int main(){
    ios::sync_with_stdio(0);cin.tie(nullptr);cout.tie(nullptr);
    cin >> n >> m ; for(int i=1;i<=n;++i) cin >> nums[i] ; 
    init() ; CreatStTable() ; int x, y ;
    while(m--) cin >> x >> y , cout << query(x , y) << endl ;
    system("pause") ;
}
```

## 模板题目

**[P3865 【模板】ST 表 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3865)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10 ;
int n , m , nums[N] , Log2[N] ;
int f[N][21] ; // 1 << 20  > 1e6
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void init(){
    for (int i = 2; i <= n; ++i)
        Log2[i] = Log2[i / 2] + 1;
}
void CreatStTable(){
    for(int i=1;i<=n;++i) f[i][0] = nums[i] ;
    for(int j=1;j<=Log2[n];++j) for(int i=1;(1 << j)+i-1<=n;++i) {
        f[i][j] = max(f[i][j-1],f[i+(1 << j-1)][j-1]) ;
    }
}
int query(int l,int r){
    int j = Log2[r - l + 1] ;
    return max(f[l][j] , f[r + 1 - (1 << j)][j]) ; 
}
int main(){
    n = read() ; m = read() ; for(int i=1;i<=n;++i) nums[i] = read() ; 
    init() ; CreatStTable() ; int x, y ;
    while(m--) x = read() , y = read() , printf("%d\n",query(x , y)) ;
    system("pause") ;
}
```

# 快速读入读出

**参考：[[C/C++\]快速读入读出代码（int， string， double型） - 深空之蓝 - 博客园 (cnblogs.com)](https://www.cnblogs.com/TheAzureDeepSpace/p/13476525.html)**

**例题：[P4305 [JLOI2011\]不重复数字 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4305)**

## 读入整数

```c++
inline int IntRead()//内联函数稍微快一点点 ,BUG就是：如果输入数据时" -  9"，它也会判断为负数！
{
    int s=0, w=1;char ch = getchar();
    while(ch<'0'||ch>'9')if(ch == '-') w=-1,ch=getchar();
    while(ch>= '0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return s*w;
}
```

## 读入字符串

```c++
inline string StringRead()
{
    string str;
    char s = getchar();
    //处理多余回车或空格 
    while(s==' '||s =='\n'||s=='\r'){s = getchar();}
    //不断读入直到遇到回车或空格 
    while (s!=' '&&s!='\n'&&s!='\r'){str += s;s = getchar();}
    return str;
}
```

## 读入浮点数

```c++
inline double DoubleRead()
{
    //double的值可能很大，所以开long long 
    long long s=0,w=1,k=0,n=0,m=0;
    char ch=getchar(); 
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch = getchar();}
    while((ch >= '0' && ch <= '9') || ch == '.'){
        //n = 0代表读入整数，= 1代表读入小数 
        if(ch == '.') n=1;
        else if (n == 0) s=s*10+ch-'0';
        else k=k*10+ch-'0',m++;
        ch=getchar();
    }
    return (pow(0.1, m)*k+s)*w;
}
```

## 读出整数

```c++
inline void IntWrite (int s)
{
    int k = 0, len = 0;
    if (s == 0) 
        putchar('0');
    while (s)
    {
        k = k * 10 + s % 10;
        s /= 10, len++;
    }
    for (int i = 0;i < len;i++)
    {
        putchar(k % 10 + '0');
        k /= 10;
    }
}
```

## 读出字符串

```c++
inline void StringWrite(std::string str){
    int i = 0;
    while (str[i] != '\0'){putchar(str[i]), i++;}
}
```

## 读出浮点数

```c++
inline void DoubleWrite(double a)
{
    int mi = 0, s[100];
    if (a == 0)
        putchar('0');
    while (a != (long long int)a)
    {
        a *= 10, mi++;
    }
    long long int k = a, len = 0;
    while (k != 0)
    {
        s[len] = k % 10, len++, k /= 10;
    }
    for (len -= 1;len >= 0;len--)
    {
        if (len == mi - 1)
            putchar('.');
        putchar(s[len] + '0');
    }
}
```

# 树状数组

数组下标从1开始。

## **参考：**

**[树状数组详解 - Xenny - 博客园 (cnblogs.com)](https://www.cnblogs.com/xenny/p/9739600.html)**

**[五分钟丝滑动画讲解 | 树状数组_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ce411u7qP/?spm_id_from=333.337.search-card.all.click&vd_source=787f243f7baf8e15cdf94b95889673a0)**

![屏幕截图_20221230_150803](初学上课笔记.assets\屏幕截图_20221230_150803.png)

## **运用：**

可以解决大部分基于区间上的更新以及求和问题。

```c++
int n;
int a[1005],c[1005]; //对应原数组和树状数组

int lowbit(int x){
    return x&(-x);
}

void updata(int i,int k){    //在i位置加上k
    while(i <= n){
        c[i] += k;
        i += lowbit(i);
    }
}

int getsum(int i){        //求A[1 - i]的和
    int res = 0;
    while(i > 0){
        res += c[i];
        i -= lowbit(i);
    }
    return res;
}
```

## 模板题目

**[P3374 【模板】树状数组 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3374)**

```c++
#include <bits/stdc++.h>
#define lowbit(x) (x&(-x))
using namespace std ;
const int N = 1e6+10;
int c[N] , n , m ;
void updata(int x,int k){
    while(x <= n) c[x] += k , x += lowbit(x) ;
}
int getSum(int x){
    int ans = 0;
    while(x >= 1) ans += c[x] , x -= lowbit(x) ;
    return ans ; 
}
int main(){
    cin >> n >> m ; 
    int op,x,y;
    for(int i=1;i<=n;++i) cin >> x , updata(i,x) ;
    while(m--){
		int op,x,y; cin >> op >> x >> y ;
		if(op==1)
			updata(x,y);
		else
			cout << getSum(y)-getSum(x-1) << endl ;
	}
    system("pause") ;
}
```



## 利用差分数组

可以实现 区间修改和单点查询

例题：[P3368 【模板】树状数组 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3368)

```c++
#include <bits/stdc++.h>
using namespace std;
#define maxN 500001
#define lowbit(x) (x&-x)
int n,m;
int tree[maxN];
int getNum(int x){
	int res = 0;
	while(x > 0){
		res += tree[x];
		x -= lowbit(x);
	}
	return res;
}
void updata(int x,int k){
	while(x <= n){
		tree[x] += k;
		x += lowbit(x); 
	}
}
void qujianUpdata(int x,int y,int k){
	updata(x,k);
	updata(y+1,-k);
}
void read(){
	scanf("%d %d",&n,&m);
	int now=0,pre=0;
	for(int i=1;i<=n;++i){
		scanf("%d",&now);
		updata(i,now-pre);
		pre=now;
	}
}
int main() {
	read();
	while(m--){
		int op;
		scanf("%d",&op);
		if(op==1){
			int x,y,k;
			scanf("%d%d%d",&x,&y,&k);
			qujianUpdata(x,y,k);
		}else{
			int x;
			scanf("%d",&x);
			printf("%d\n",getNum(x));
		}
	}
	system("pause");
	return 0;
}
/*
5 5
1 5 4 2 3
1 2 4 2
2 3
1 1 5 -1
1 3 5 7
2 4
*/
```

# 线段树（RMQ）

根节点是 1 

## 参考

[【算法】线段树详解_huangzihaoal的博客-CSDN博客_线段树](https://blog.csdn.net/huangzihaoal/article/details/81813454)

## 概念

![屏幕截图_20221201_215008](初学上课笔记.assets\屏幕截图_20221201_215008.png)

## **区间线段树**

[P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3372)

```c++
#include <bits/stdc++.h>
#define int long long
#define l(x) tr[x].l
#define r(x) tr[x].r
#define sum(x) tr[x].sum
#define lz(x) tr[x].lz
#define lc(x) (x<<1)
#define rc(x) (x<<1|1)
using namespace std;
const int N = 1e5+10 ;  // 一般线段树开四倍空间
int num[N] , n , m ;
struct node{int l,r,sum,lz;} tr[N*4];
void pushdown(int p){
    if(lz(p)){
        sum(lc(p)) += lz(p) * (r(lc(p)) - l(lc(p)) + 1) ;
        sum(rc(p)) += lz(p) * (r(rc(p)) - l(rc(p)) + 1) ;
        lz(lc(p)) += lz(p) ;
        lz(rc(p)) += lz(p) ;
        lz(p) = 0;
    }
}
void pushup(int p){
    sum(p) = sum(lc(p)) + sum(rc(p)) ;
}
void build(int l,int r,int p){
    tr[p] = {l,r,num[l],0};
    if(l==r) return ;
    int m = (l + r) >> 1 ;
    build(l,m,lc(p)) ; build(m+1,r,rc(p)) ;
    pushup(p) ;
}
int query(int l,int r,int p){
    if(l <= l(p) && r >= r(p)) return sum(p) ;
    pushdown(p) ;
    int sum = 0; int m = (l(p) + r(p)) >> 1;
    if(l <= m)  sum += query(l,r,lc(p)) ;
    if(r > m) sum += query(l,r,rc(p)) ;
    return sum ;
}
void updata(int l,int r,int k,int p){
    if(l <= l(p) && r >= r(p)) {
        sum(p) += k * (r(p) - l(p) + 1) ;
        lz(p) += k ; 
        return ;
    }
    pushdown(p) ;
    int m = (l(p) + r(p)) >> 1;
    if(l <= m) updata(l,r,k,lc(p)) ;
    if(r > m) updata(l,r,k,rc(p)) ;
    pushup(p) ;
}
signed  main(){
    cin>>n>>m;
    for(int i=1;i<=n;++i){
        cin>>num[i];
    }
    build(1,n,1);
    for(int i=0;i<m;++i){
        int op;
        cin>>op;
        if(op==1){
            int x,y,k;
            cin>>x>>y>>k;
            updata(x,y,k,1);
        }else if(op==2){
            int x,y;
            cin>>x>>y;
            cout<<query(x,y,1)<<endl;
        }
    }
    system("pause");
}
```

**动态开点：**

```c++
#include <bits/stdc++.h>
#define int long long
#define x first
#define y second 
#define debug cout << "__LINE__" << __LINE__ << endl ;
using namespace std ; typedef long long ll ; typedef pair<int,int> pii ;
const int INF = 0x3f3f3f3f3f3f3f3f ; const double eps=1e-6 ; const int P = 1e9 + 7 ;
inline ll gcd(ll a, ll b) { return b == 0 ? a : gcd(b,a%b);}
inline ll lcm(ll a, ll b) { return a / gcd(a, b) * b;}
inline ll mod(ll x,ll p=P) { return (x%p + p)%p;}
inline ll qpow(ll a,ll b,ll p=P) { ll res = 1;a=mod(a,p); while (b) { if (b&1) res=mod(res*a,p);a=mod(a*a,p);b>>=1;}return res;}

int nums[1000001] ;

struct node{
    int x, y;
    int sum ;
    int lz ;
    node* lc ;
    node* rc ;
    node(){
        lc = NULL ;
        rc = NULL ;
        sum = lz = 0 ;
    }
} ;

void pushup(node * p) {
    if(p == NULL) return ;
    if(p->lc) p->sum = p->lc->sum ;
    if(p->rc) p->sum += p->rc->sum ;
}

void pushdown(node* p){
    if(p == NULL) return ;
    if(p->lz == 0) return ;
    if(p->lc) {
        p->lc->sum += p->lz * (p->lc->y - p->lc->x + 1) ;
        p->lc->lz += p->lz ;
    }
    if(p->rc) {
        p->rc->sum += p->lz * (p->rc->y - p->rc->x + 1) ;
        p->rc->lz += p->lz ;
    }
    p->lz = 0 ;
}

void updata(node* p, int x, int y, int k) {
    if(p == NULL) return ;
    if(x <= p->x && y>= p->y) {
        p->sum += k * (p->y - p->x + 1) ;
        p->lz += k ;
        return ;
    }
    pushdown(p) ;
    int m = (p->x + p->y) >> 1 ;
    if(x <= m) updata(p->lc, x, y, k) ;
    if(y > m) updata(p->rc, x, y, k) ;
    pushup(p) ;
}

int query(node* p, int x, int y) {
    int ret = 0 ;
    if(p == NULL) return 0 ;
    if(x <= p->x && y>= p->y) {
        return p->sum ;
    }
    pushdown(p) ;
    int m = (p->x + p->y) >> 1 ;
    if(x <= m) ret += query(p->lc, x, y) ;
    if(y > m) ret += query(p->rc, x, y) ;
    pushup(p) ;
    return ret ;
}

node* build(node* p, int x, int y) {
    if(p == NULL) p = new node() ;
    p->x = x ; p->y = y ;
    if(x == y) {
        p->sum = nums[x] ;
        return p ;
    }
    int m = (x + y) >> 1 ;
    p->lc = build(p->lc, x, m) ;
    p->rc = build(p->rc, m + 1, y) ;
    pushup(p) ;
    return p ;
}

void solve(){
    int n , m ;
    cin >> n >> m ;
    for(int i = 1 ; i <= n ; ++ i){
        cin >> nums[i] ;
    }
    node* root = NULL ;
    root = build(root, 1, n);
    for(int i=0;i<m;++i){
        int op;
        cin>>op;
        if(op==1){
            int x,y,k;
            cin>>x>>y>>k;
            updata(root, x,y,k);
        }else if(op==2){
            int x,y;
            cin>>x>>y;
            cout<<query(root, x,y)<<endl;
        }
    }
}

signed main(){
    ios::sync_with_stdio(false) ; 
    cin.tie(nullptr) ; cout.tie(nullptr) ;
    int t = 1 ; // cin >> t ;
    while( t -- ) solve() ;
    return 0 ;
}

```

[P3373 【模板】线段树 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3373)

```c++
#include <bits/stdc++.h>
#define int long long
#define l(x) tr[x].l
#define r(x) tr[x].r
#define sum(x) tr[x].sum
#define lz_add(x) tr[x].lz_add
#define lz_mul(x) tr[x].lz_mul
#define lc(x) (x<<1)
#define rc(x) (x<<1|1)
using namespace std;
const int N = 1e5+10 ;  // 一般线段树开四倍空间
int num[N] , n , m , P ;
struct node{int l,r,sum,lz_add,lz_mul;} tr[N*4];
void pushdown(int p){
    sum(lc(p)) = ( sum(lc(p)) * lz_mul(p) + lz_add(p) * ( r(lc(p)) - l(lc(p)) + 1 ) ) % P ;
    sum(rc(p)) = ( sum(rc(p)) * lz_mul(p) + lz_add(p) * ( r(rc(p)) - l(rc(p)) + 1 ) ) % P ;
    lz_mul(lc(p)) = ( lz_mul(lc(p)) * lz_mul(p) ) % P ;
    lz_mul(rc(p)) = ( lz_mul(rc(p)) * lz_mul(p) ) % P ;
    lz_add(lc(p)) = ( lz_add(lc(p)) * lz_mul(p) + lz_add(p) ) % P ;
    lz_add(rc(p)) = ( lz_add(rc(p)) * lz_mul(p) + lz_add(p) ) % P ;
    lz_mul(p) = 1;
    lz_add(p) = 0;
}
void pushup(int p){
    sum(p) = ( sum(lc(p)) + sum(rc(p)) ) % P ;
}
void build(int l,int r,int p){
    tr[p] = {l,r,num[l],0,1};
    if(l==r) return ;
    int m = (l + r) >> 1 ;
    build(l,m,lc(p)) ; build(m+1,r,rc(p)) ;
    pushup(p) ;
}
int query(int l,int r,int p){
    if(l <= l(p) && r >= r(p)) return sum(p) ;
    pushdown(p) ;
    int sum = 0; int m = (l(p) + r(p)) >> 1;
    if(l <= m)  sum = ( sum + query(l,r,lc(p)) ) % P ;
    if(r > m) sum = ( sum + query(l,r,rc(p)) ) % P ;
    return sum % P;
}
void updata_add(int l,int r,int k,int p){
    if(l <= l(p) && r >= r(p)) {
        sum(p) = ( sum(p) + k * (r(p) - l(p) + 1) ) % P ;
        lz_add(p) = ( lz_add(p) + k ) % P ;
        return ;
    }
    pushdown(p) ;
    int m = (l(p) + r(p)) >> 1;
    if(l <= m) updata_add(l,r,k,lc(p)) ;
    if(r > m) updata_add(l,r,k,rc(p)) ;
    pushup(p) ;
}
void updata_mul(int l,int r,int k,int p){
    if(l <= l(p) && r >= r(p)) {
        sum(p) = ( sum(p) * k ) % P ;
        lz_mul(p) = ( lz_mul(p) * k ) % P ; 
        lz_add(p) = ( lz_add(p) * k ) % P ;
        return ;
    }
    pushdown(p) ;
    int m = (l(p) + r(p)) >> 1;
    if(l <= m) updata_mul(l,r,k,lc(p)) ;
    if(r > m) updata_mul(l,r,k,rc(p)) ;
    pushup(p) ;
}
signed  main(){
    cin >> n >> m >> P ;
    for(int i=1;i<=n;++i){
        cin>>num[i];
    }
    build(1,n,1);
    for(int i=0;i<m;++i){
        int op;
        cin>>op;
        if(op==1){
            int x,y,k;
            cin >> x >> y >> k ;
            updata_mul(x,y,k,1);
        } else if(op == 2){
            int x,y,k;
            cin >> x >> y >> k ;
            updata_add(x,y,k,1);
        } else if(op == 3){
            int x,y;
            cin >> x >> y ;
            cout << query(x,y,1) << endl ;
        }
    }
    system("pause");
}
```

[P6242 【模板】线段树 3 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P6242)

## 权值线段树

**参考：[【算法讲堂】【电子科技大学】【ACM】权值线段树与主席树_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Cx411V7jH/?spm_id_from=333.337.search-card.all.click&vd_source=787f243f7baf8e15cdf94b95889673a0)**

[P3369 【模板】普通平衡树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3369)

```c++
#include <bits/stdc++.h>
#define lc(x) tr[x].ch[0]
#define rc(x) tr[x].ch[1]
#define s(x) (tr[x].s)
using namespace std;
const int N = 1e7+10 ;
struct node{int ch[2],s;} tr[N<<2];
int root , idx ;
void build(int l,int r,int& rt){
    rt = ++idx ;
    if(l==r) return ;
    int m = l + r >> 1 ;
    build(l,m,lc(rt)) ;
    build(m+1,r,rc(rt)) ;
}
void updata(int l,int r,int val,int op,int rt){  // op:1插入，op:-1删除
    s(rt) += op ;
    if(l == r) return ;
    int m = l + r >> 1 ;
    if(val <= m) updata(l,m,val,op,lc(rt)) ;
    else updata(m+1,r,val,op,rc(rt)) ;
}
int Kth(int l,int r,int k,int rt) {  // 第 K 小的值
    if(l == r) return l ;
    int m = l + r >> 1 ;
    if(k <= s(lc(rt))) return Kth(l,m,k,lc(rt));
    else return Kth(m+1,r,k-s(lc(rt)),rc(rt));
}
int getrank(int l,int r,int val,int rt){  // 排名
    if(l == r) return 1;
    int m = l + r >> 1 ;
    if(val <= m) return getrank(l,m,val,lc(rt)) ;
    else return s(lc(rt)) + getrank(m+1,r,val,rc(rt)) ;
}
int main(){
    int Min,Max ;
    build(Min,Max,root) ;
    system("pause") ;
}
```



## 主席树（可持久化权值线段树）

**可持久化线段树**

**模板例题：[P3834 【模板】可持久化线段树 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3834)**

```c++
#include <bits/stdc++.h>
#define lc(x) tr[x].ch[0]
#define rc(x) tr[x].ch[1]
#define s(x) (tr[x].s)
using namespace std;
const int N = 2e5+10 ;
struct node{int ch[2],s;} tr[N*30];
int root[N] , idx ; vector<int> v ; int n , m , a[N];
void build(int l,int r,int& rt){
    rt = ++idx ;
    if(l == r) return ;
    int m = l + r >> 1 ;
    build(l,m,lc(rt)) ; build(m+1,r,rc(rt)) ;
}
void updata(int l,int r,int val,int op,int& x,int y){  // op:1 插入 ，op:-1 删除
    x = ++idx ; tr[x] = tr[y] ; s(x) += op ;
    if(l == r) return ;
    int m = l + r >> 1 ;
    if(val <= m) updata(l,m,val,op,lc(x),lc(y)) ;
    else updata(m+1,r,val,op,rc(x),rc(y)) ;
}
int Kth(int l,int r,int k,int x,int y) { // l,r 权值区间，x=root[left-1] , y = root[right];
    if(l == r) return l ;
    int m = l + r >> 1 ;
    int s = s(lc(y)) - s(lc(x)) ;
    if(k <= s) return Kth(l,m,k,lc(x),lc(y)) ;
    return Kth(m+1,r,k-s,rc(x),rc(y)) ;
}
int getrank(int l,int r,int k,int x,int y){ // l,r 权值区间，x=root[left-1] , y = root[right];
    if(l == r) return 1 ; 
    int m = l + r >> 1 ;
    int s = s(lc(y)) - s(lc(x)) ;
    if(k <= s) return getrank(l,m,k,lc(x),lc(y)) ;
    return s + getrank(m+1,r,k,rc(x),rc(y)) ;
}
int getid(int val){
    return lower_bound(v.begin(),v.end(),val) - v.begin() + 1 ;
}
int main(){
    ios::sync_with_stdio(0); cin.tie(nullptr);cout.tie(nullptr);
    cin >> n >> m ; for(int i=1;i<=n;++i) cin >> a[i], v.push_back(a[i]) ;
    sort(v.begin(),v.end()) ; v.erase(unique(v.begin(),v.end()),v.end()) ;
    int Max = v.size() ;  build(1,Max,root[0]) ;
    for(int i=1;i<=n;++i) updata(1,Max,getid(a[i]),1,root[i],root[i-1]) ;
    int left , right , k ;
    while(m--){
        cin >> left >> right >> k ;
        cout << v[Kth(1,Max,k,root[left-1],root[right]) - 1] << endl ;
    }
    system("pause") ;
}
```

## 可持久化区间线段树（可持久化数组）

根节点是 1 

**模板题目：[P3919 【模板】可持久化线段树 1（可持久化数组） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3919)**

```c++
#include <bits/stdc++.h>
#define lc(x) tr[x].ch[0]
#define rc(x) tr[x].ch[1]
using namespace std;
const int N = 1e6 + 10 ;
int idx , num[N] , root[N] , n , m ;
struct node{int ch[2],val;}tr[N*30];
void build(int& p,int l,int r){
    p = ++idx ;
    if(l==r){tr[p].val = num[l];return;}
    int m = l+r >> 1 ;
    build(lc(p),l,m); build(rc(p),m+1,r);
}
int query(int p,int l,int r,int pos){
    if(l==r) return tr[p].val ;
    int m = l + r >> 1;
    if(pos <= m) return query(lc(p),l,m,pos);
    else return query(rc(p),m+1,r,pos); 
}
void modify(int& x,int y,int l,int r,int pos,int val){
    x = ++idx ; tr[x] = tr[y] ;
    if(l == r) {tr[x].val = val;return;}
    int m = l + r >> 1 ;
    if(pos <= m) modify(lc(x),lc(y),l,m,pos,val);
    else modify(rc(x),rc(y),m+1,r,pos,val) ;
}
int main(){
    cin.tie(0);
    ios::sync_with_stdio(0);
    cin >> n >> m;
    for(int i=1;i<=n;++i) cin >> num[i] ;
    build(root[0],1,n);
    int tot=0;
    while(m--){
        int ver,op,pos,val;
        cin >> ver >> op ;
        if(op == 1) {
            cin >> pos >> val ;
            modify(root[++tot],root[ver],1,n,pos,val);
        } else {
            cin >> pos ;
            cout << query(root[ver],1,n,pos) << endl ;
            root[++tot] = ++idx ; tr[idx] = tr[root[ver]] ;
        }
    }
    system("pause");
}
```



# 分块思想

**例题：**

[P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3372)

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5+7;
const int inf = INT_MAX;
int a[N],sum[N],lz[N],L[N],R[N],pos[N];
int n,m;
int getSum(int l,int r) {
    int p = pos[l] , q = pos[r] ;
    int ans = 0 ; 
    if( p == q ) {
        for(int i=l ; i <= r ; ++ i)  ans += a[i] ;
        ans += lz[p] * (r - l + 1) ;
    } else {
        for(int i=p+1 ; i <= q-1 ; ++ i) ans += sum[i] + lz[i] * (R[i] - L[i] + 1);
        for(int i=l ; i <= R[p] ; ++ i) ans += a[i] ; 
        ans += lz[p] * (R[p] - l + 1) ;
        for(int i=L[q] ; i <= r ; ++ i) ans += a[i] ;
        ans += lz[q] * (r - L[q] + 1) ; 
    }
    return ans ;
}
void change(int l,int r,int k) {
    int p = pos[l] ,q = pos[r] ;
    if( p == q ) {
        for(int i=l ; i <= r ; ++ i)  a[i] += k ;
        sum[p] += k * (r - l + 1) ;
    } else {
        for(int i=p+1 ; i <= q-1 ; ++ i) lz[i] += k;
        for(int i=l ; i <= R[p] ; ++ i) a[i] += k ; 
        sum[p] += k * (R[p] - l + 1) ;
        for(int i=L[q] ; i <= r ; ++ i) a[i] += k ;
        sum[q] += k * (r - L[q] + 1) ; 
    }
}
void init() {
    int t = sqrt(n);
    // 分块
    for(int i=1 ; i <= t ; ++ i) {
        L[i] = (i - 1) * t + 1;
        R[i] = i * t ;
    }
    if(R[t] < n) t++ , L[t] = R[t - 1] + 1, R[t] = n ;
    // 预处理sum 和 pos
    for(int i=1 ; i <= t ; ++ i) {
        for(int j = L[i] ; j <= R[i] ; ++ j) {
            pos[j] = i;
            sum[i] += a[j];
        }
    }
}
signed main() {
    cin >> n >> m;
    for(int i=1 ; i<=n ; ++ i) cin >> a[i];
    init();
    for(int i=0;i<m;++i){
        int op;
        cin>>op;
        if(op==1){
            int x,y,k;
            cin>>x>>y>>k;
            change(x,y,k);
        }else if(op==2){
            int x,y;
            cin>>x>>y;
            cout<<getSum(x,y)<<endl;
        }
    }
    system("pause");
    return 0;
}


```



# 差分数组和前缀和

## 前缀和

**主要用处：**求任意区间和

`S[i] = S[i-1] + A[i]`

## 差分数组

**参考：**[差分数组是个啥？能干啥？怎么用？（差分详解+例题）_From now on...的博客-CSDN博客_差分数组的定义及用途](https://blog.csdn.net/qq_44786250/article/details/100056975)

**作用：**从侧面反映给定一个数组的变化，一般用来进行区间修改操作。

**区间修改：**

```c++
// 修改 [x,y] 每个数+k
diff[x] += k;
diff[y+1] -= k;
```

**差分数组的前缀和是原数组的值：**

可以搭配树状数组来使用

**例题：**

[P3368 【模板】树状数组 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3368)

```c++
#include <bits/stdc++.h>
using namespace std;
#define maxN 500001
#define lowbit(x) (x&-x)
int n,m;
int tree[maxN];
int getNum(int x){
	int res = 0;
	while(x > 0){
		res += tree[x];
		x -= lowbit(x);
	}
	return res;
}
void updata(int x,int k){
	while(x <= n){
		tree[x] += k;
		x += lowbit(x); 
	}
}
void qujianUpdata(int x,int y,int k){
	updata(x,k);
	updata(y+1,-k);
}
void read(){
	scanf("%d %d",&n,&m);
	int now=0,pre=0;
	for(int i=1;i<=n;++i){
		scanf("%d",&now);
		updata(i,now-pre);
		pre=now;
	}
}
int main() {
	read();
	while(m--){
		int op;
		scanf("%d",&op);
		if(op==1){
			int x,y,k;
			scanf("%d%d%d",&x,&y,&k);
			qujianUpdata(x,y,k);
		}else{
			int x;
			scanf("%d",&x);
			printf("%d\n",getNum(x));
		}
	}
	system("pause");
	return 0;
}
/*
5 5
1 5 4 2 3
1 2 4 2
2 3
1 1 5 -1
1 3 5 7
2 4
*/
```

## 二维差分与前缀和

**例题：[2536. 子矩阵元素加 1 - 力扣（LeetCode）](https://leetcode.cn/problems/increment-submatrices-by-one/)**

```c++
class Solution {
public:	
    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {
    	vector<vector<int>> diff(n , vector<int>(n)) ;
    	
    	// 差分修改
    	for(auto m : queries){
    		diff[m[0]][m[1]] ++ ;
    		if(m[2]+1 < n)diff[m[2]+1][m[1]] -- ;
    		if(m[2]+1 < n && m[3] + 1 < n)diff[m[2]+1][m[3]+1] ++;
    		if(m[3]+1 < n)diff[m[0]][m[3]+1] -- ;
    	}
        
    	// 前缀和求原数组
    	for(int i=0;i<n;++i){
    		for(int j=0;j<n;++j){
    			if(i > 0)diff[i][j] += diff[i-1][j] ;
    			if(j > 0)diff[i][j] += diff[i][j-1] ;
    			if(i > 0 && j > 0)diff[i][j] -= diff[i-1][j-1] ;
    		}
    	}

    	return diff ;
    }
};
```



# 字典树（Trie树，前缀树）

根节点是 0 

## 字符串类型 

**模板：[208. 实现 Trie (前缀树) - 力扣（LeetCode）](https://leetcode.cn/problems/implement-trie-prefix-tree/) **

**[P8306 【模板】字典树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P8306)**

**简介：**

 首先字典树是一种**数据结构**,用于处理大量字符串.,优点在于利用字符串的公共前缀,在存储时节约存储空间,并在查询时最大限度的减少无谓的字符串比较.

**用途：**

**1.以最节约空间的方式存储大量字符串.且存好后是有序的**
           因为是有序的,故而字典树不仅可用于大量字符串的存储,还可用于大量字符串的排序.

**2.快速查询某字符串s在字典树中是否已存在,甚至出现过几次**
      因为当字典树预处理好之后,查询字符串s在当前的出现情况的效率为strlen(s),异常高效,故而常用于搜索引擎等.

**实现：**

**建立**

![屏幕截图_20221203_213051](初学上课笔记.assets\屏幕截图_20221203_213051.png)

```c++
const int N = 1001;
int ch[N][26],cnt[N],idx;
void insert(string s){
	int p = 0;
	for(int i=0;i<s.size();++i){
		int j = s[i] - 'a';
		if(!ch[p][j]) ch[p][j] = ++idx;
		p = ch[p][j];
	}
	cnt[p]++;
}
```

**查询**

```c++
int query(string s){  // 返回字符串在字典树中存在了几个
	int p = 0;
	for(int i=0;i<s.size();++i){
		int j = s[i] - 'a';
		if(!ch[p][j]) return 0;
		p = ch[p][j];
	}
	return cnt[p];
}
```

## 01Trie树

**最大异或对：[143. 最大异或对 - AcWing题库](https://www.acwing.com/problem/content/description/145/)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int len = 32;
const int N = 1001;
int ch[N*len][2],idx;
int n,a[N];
void insert(int x){
    int p = 0 ;
    for(int i=len-1;i>=0;--i) {
        int j = x >> i & 1 ;
        if(!ch[p][j]) ch[p][j] = ++idx;
        p = ch[p][j] ;
    }
}
int query(int x){  // 查询x的最大异或(^)
    int p = 0, res = 0;
    for(int i=len-1;i>=0;--i) {
        int j = x >> i & 1 ;
        if(ch[p][!j]) {
            res += 1 << i ;
            p = ch[p][!j] ;
        } else {
            p = ch[p][j] ;
        }
    }
    return res ;
}
int main(){
    cin >> n ;
    for(int i=1;i<=n;++i) cin >> a[i] , insert(a[i]) ;
    int ans = 0;
    for(int i=1;i<=n;++i) ans = max(ans,query(a[i]));
    cout << ans << endl ;
    system("pause");
}
```



## 可持久化 01Trie 树

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e3+10;
const int LEN = 32 ;
int n ; string s ;

class Trie{
private:
    int ch[N*LEN][2] , root[N] , idx ,ver[N*LEN];
public:
    Trie(){
        // 空节点ch[0] 版本是-1 ， 最初应该插入空树insert(root[0],0,0,1) ; 0号版本的编号是1，-1号版本的编号是0
        memset(ch,0,sizeof(ch));
        memset(root,0,sizeof(root));
        memset(ver,0,sizeof(ver)); 
        idx = 0 ;
        ver[0] = -1 ; root[0] = ++idx ;
        insert(root[0],0,0,0) ;
    }
    // 版本从1开始
    void insert(int x,int y,int c,int v){ // x是当前版本编号，y是上一版本编号，c是需要插入的数字,v是插入数字的版本
        ver[x] = v ;
        for(int i=LEN-1;i>=0;--i){
            int j = c>>i & 1;
            ch[x][!j] = ch[y][!j] ;
            ch[x][j] = ++idx ; // 新插入的数字都需要重新编号
            x = ch[x][j] ; y = ch[y][j] ; // 上一版本若有j，则进入，否则y退回空节点0
            ver[x] = v ;
        }
    }
    int query(int R , int L , int c){  // 查询c在[R,L]范围内的最大异或
        int p = root[R] , ans = 0 ;
        for(int i=LEN-1;i>=0;--i){
            int j = c >> i & 1 ;
            if(ver[ch[p][!j]] >= L) {
                p = ch[p][!j] ; ans += 1 << i ;
            } else {
                p = ch[p][j] ;
            }
        }
        return ans ;
    }
};
int main(){
    Trie R ;
    system("pause");
}

```

**最大异或和：[P4735 最大异或和 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4735)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int len = 32;
const int N = 3e6+10;
int ch[N*len][2],idx,root[N],ver[N*len];
int n,m,s[N];
void insert(int x,int y,int i){
    ver[x] =  i;
    for(int k=len-1;k>=0;--k) {
        int j = s[i] >> k & 1;
        ch[x][!j] = ch[y][!j] ;
        ch[x][j] = ++idx;
        x = ch[x][j] ; y = ch[y][j] ; 
        ver[x] = i;
    }
}
int query(int x,int L,int v){  // 查询v的最大异或(^)
    int res = 0;
    for(int k=len-1;k>=0;--k) {
        int j = v >> k & 1;
        if(ver[ch[x][!j]] >= L) {
            x = ch[x][!j];
            res += 1 << k ;
        } else {
            x = ch[x][j] ;
        }
    }
    return res ;
}
int main(){
    char op;
    int l,r,x;
    cin >> n >> m ;
    ver[0] = -1;
    root[0] = ++idx;
    insert(root[0],0,0);
    for(int i=1;i<=n;++i) {
        cin >> x ;
        s[i] = s[i-1] ^ x;
        root[i] = ++idx;
        insert(root[i],root[i-1],i);
    }
    while(m--) {
        cin >> op ;
        if(op == 'A') {
            cin >> x ; ++n;
            s[n] = s[n-1] ^ x;
            root[n] = ++idx;
            insert(root[n],root[n-1],n); 
        } else {
            cin >> l >> r >> x;
            int ans = query(root[r-1],l-1,s[n]^x);
            cout << ans << endl ;
        }
    }
    system("pause");
}
```

## 应用

### 统计不同子串

把字符串所有后缀插入，输出节点号

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e6+1;
int ch[N][26] , tot ;
string s;
void insert(int k){
    int  p = 0;
    for(int i=k;i<s.size();++i){
        int j = s[i] - 'a' ;
        if(!ch[p][j]) ch[p][j] = ++tot ;
        p = ch[p][j] ;
    }
}
signed main(){
    int n ; cin >> n ;
    cin >> s ;
    for(int i=0;i<s.size();++i) insert(i) ;
    cout << tot << endl;
    system("pause");
}
```

### 统计异或值在范围内的数对有多少（LC 1803）

**题目：[1803. 统计异或值在范围内的数对有多少 - 力扣（LeetCode）](https://leetcode.cn/problems/count-pairs-with-xor-in-a-range/)**

```c++
class Solution {
private:
    // cnt[p]:p节点下插入了几个数
    int ch[2*1001*32][2] , idx , cnt[2*1001*32] ;
public:
    void insert(int x) {
        int p = 0 ;
        for(int i=31;i>=0;--i){
            int j = (x >> i) & 1 ;
            if(!ch[p][j]) ch[p][j] = ++idx ;
            cnt[p] ++ ; p = ch[p][j] ;
        }
        cnt[p] ++ ;
    }
    int query(int x , int r) {    // 查询与x异或的值小于等于r的数量
        int p = 0 ; int res = 0 ; 
        for(int i=31;i>=0;--i){
            int j = (x >> i) & 1 ;
            int k = (r >> i) & 1 ;
            if(k == 1) {
                if(ch[p][j]) {
                    res += cnt[ch[p][j]] ;
                    if(ch[p][!j]) p = ch[p][!j] ;
                    else return res ;
                } else {
                    if(ch[p][!j]) p = ch[p][!j] ;
                    else return res ;
                }
            } else {
                if(ch[p][j]) p = ch[p][j] ;
                else return res ;
            }
        }
        return res + cnt[p] ;
    }

    int get(vector<int>& nums,int r){ 
        memset(ch,0,sizeof(ch)) ; idx = 0 ; memset(cnt,0,sizeof(cnt)) ;
        int ans = 0;
        for(auto e : nums) {
            ans += query(e , r) ;
            insert(e) ;
        }
        return ans ;
    }
    int countPairs(vector<int>& nums, int low, int high) {
        int x = get(nums , high) ; 
        int y = get(nums , low-1) ;
        return x - y ;
    }
};
```

### 连接词

**题目：[472. 连接词 - 力扣（LeetCode）](https://leetcode.cn/problems/concatenated-words/)**

```c++
#include <bits/stdc++.h>
#define debug cout << "__LINE__ : " << __LINE__ - 9 <<endl ;
using namespace std ;


using ll = long long ;
class Solution {
private:
    static const int N = 3e5 + 1 ;
    int ch[N][26] , cnt[N]; int idx = 0 ;
    unordered_map<string,int> mp ;
    void add(string& s){
        int p = 0 ; 
        for(int i=0;i<s.size();++i){
            int j = s[i] - 'a' ;
            if(!ch[p][j]) ch[p][j] = ++ idx ;
            p = ch[p][j] ;
            //debug cout << p << endl ;
        }
        cnt[p] = 1 ;
        mp[s] = p ;
    }
    bool query(int root,int start,string& s){
        //debug ; cout << start << endl ;
        if(start == s.size()) return mp[s] != root ;
        int p = 0 ;
        for(int i=start;i<s.size();++i){
            int j = s[i] - 'a' ;
            if(!ch[p][j]) return false ;
            p = ch[p][j] ;
            if(cnt[p] && query(p,i+1,s)) return true ; 
        }
        return false ;
    } 
public:
    Solution(){
        memset(ch,0,sizeof(ch)) ; idx = 0 ;
        memset(cnt,0,sizeof(cnt)) ;
    }
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        vector<string> ans ;
        for(auto& s : words) {
            //debug ; cout << s << endl ;
            add(s) ;
        }
        for(auto& s : words) {
            //debug ; cout << s << endl ;
            if(query(0,0,s)) ans.push_back(s) ;
        }
        return ans ;
    }
};
```

### 最大的异或

**题目:[剑指 Offer II 067. 最大的异或 - 力扣（LeetCode）](https://leetcode.cn/problems/ms70jA/)**

```c++
struct Trie{
    struct node{
        node* ch[2] ; int cnt ;
        node(){for(int i=0;i<2;++i) ch[i] = nullptr ; cnt = 0 ;}
    } ;
    node* root = new node ; 
    void add(int x){
        node* p = root ;
        for(int i=31;i>=0;--i){
            int j = x >> i & 1 ;
            if(!p->ch[j]) p->ch[j] = new node ;
            p = p->ch[j] ;
        }
        p->cnt ++ ;
    }
    int query(int x){
        int res = 0 ; node* p = root ;
        for(int i=31;i>=0;--i){
            int j = x >> i & 1 ;
            if(p->ch[!j]) res += 1 << i , p = p->ch[!j] ; 
            else p = p->ch[j] ;
        }
        return res ;
    }
} ;
class Solution {
public:
    int findMaximumXOR(vector<int>& nums) {
        Trie trie ; int ans = 0 ;
        for(auto e : nums) trie.add(e) ;
        for(auto e : nums) ans = max(ans , trie.query(e)) ;
        return ans ;
    }
};
```

### [1032. 字符流 - 力扣（LeetCode）](https://leetcode.cn/problems/stream-of-characters/)

```c++
class Trie {
private:
    array<Trie*, 26> ch ;
    bool is_end ;
public:
    Trie() {
        for(int i = 0 ; i < 26 ; ++ i) ch[i] = NULL ;
        is_end = false ;
    }
    void add(string& s) {
        int n = s.size() ; Trie* p = this ;
        for(int i = 0 ; i < n ; ++ i) {
            int j = s[i] - 'a' ;
            if(p->ch[j] == NULL) p->ch[j] = new Trie() ;
            p = p->ch[j] ;
        }
        p->is_end = true ;
    }
    bool query(string& s) {
        Trie* p = this ; int n = s.size() ;
        for(int i = n-1 ; i >=0 ; -- i) {
            int j = s[i] - 'a' ;
            if(p->ch[j] == NULL) return false ;
            p = p->ch[j] ;
            if(p->is_end == true) return true ;
        }
        return false ;
    }
} ;

class StreamChecker {
private:
    Trie root ;
    string str ;
public:
    StreamChecker(vector<string>& words) {
        int n = words.size() ;
        for(int i = n-1 ; i >=0 ; -- i) {
            string s = words[i] ;
            reverse(s.begin(), s.end()) ;
            root.add(s) ;
        }
    }
    
    bool query(char letter) {
        str += letter ;
        return root.query(str) ;
    }
};

/**
 * Your StreamChecker object will be instantiated and called as such:
 * StreamChecker* obj = new StreamChecker(words);
 * bool param_1 = obj->query(letter);
 */
```



# AC自动机

根节点是  0

**参考：**

[AC自动机 算法详解(图解)及模板_bestsort的博客-CSDN博客_ac自动机](https://blog.csdn.net/bestsort/article/details/82947639)

[构建AC自动机代码](https://www.bilibili.com/video/BV1tF41157Dy/?spm_id_from=333.337.search-card.all.click&vd_source=787f243f7baf8e15cdf94b95889673a0)

[理解AC自动机如何多模式匹配](https://www.bilibili.com/video/BV14v4y1Z7fu/?spm_id_from=333.337.search-card.all.click&vd_source=787f243f7baf8e15cdf94b95889673a0)

[Fail指针理解和构建](https://www.bilibili.com/video/BV1Ag41117YU/?spm_id_from=333.337.search-card.all.click&vd_source=787f243f7baf8e15cdf94b95889673a0)

**Fail指针的建立（回跳边）：**

1、构建fail指针的顺序应该是层次遍历的顺序。

2、根节点的fail指针指向本身。

3、如果当前节点的父节点的fail指针指向的节点下存在与当前节点一样的子节点，那么当前节点的fail指针指向该子节点，否则指向根节点。

**优化：**

1、转移边优化（常用，一句话的事情）

2、拓扑排序优化（难度较大）P5357

![屏幕截图_20221226_124707](初学上课笔记.assets\屏幕截图_20221226_124707.png)

**模板题目：[P3808 【模板】AC 自动机（简单版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3808)**

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll ;
const int N = 1e6+10;
string s ; int  n ;
int ch[N][26] , cnt[N] , ne[N] , idx ;
void insert(string& s){
    int  p = 0;
    for(int i=0;i<s.size();++i){
        int j = s[i] - 'a' ;
        if(!ch[p][j]) ch[p][j] = ++idx ; 
        p = ch[p][j] ;
    }
    cnt[p] ++ ;
}
void build(){
    queue<int> q;
    for(int i=0;i<26;++i) if(ch[0][i]) q.push(ch[0][i]);
    while(q.size()){
        int u = q.front() ; q.pop() ;
        for(int i=0;i<26;++i){
            int v = ch[u][i] ;
            if(v) ne[v] = ch[ne[u]][i] , q.push(v) ;
            else ch[u][i] = ch[ne[u]][i] ;
        }
    }
}
ll query(string& s){
    ll ans = 0 ;
    int p = 0;
    for(int i=0;i<s.size();++i){
        p = ch[p][s[i] - 'a'] ;
        for(int j=p;j && cnt[j]!=-1;j=ne[j]){
            ans += (ll)cnt[j] ; cnt[j] = -1;
        }
    }
    return ans ;
}
int main(){
    cin >> n ;
    for(int i=1;i<=n;++i) cin >> s , insert(s) ; cin >> s ;
    build() ; cout << query(s) << endl ;
    system("pause");
}
```

**模板题目：[P3796 【模板】AC 自动机（加强版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3796)**

**会被卡掉：**然后的话，很多人用 AC 自动机进行多模匹配时都会暴力跳 fail 边，但这样做复杂度是错误的，可以被类似于 `aaaaa……aaaaa` 这样的串卡掉。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 151*71;
int ch[N][26],idx,cnt[N],ne[N];
int c[151];  // 记录模式串出现次数   了
string pat[151];  // 记录模式串
void insert(string& s,int v){
    int p = 0;
    for(int i=0;i<s.size();++i){
        int j = s[i] - 'a';
        if(!ch[p][j]) ch[p][j] = ++idx;
        p = ch[p][j];
    }
    cnt[p] = v;  // 记录编号
}
void buildACauto(){
    queue<int> q;
    for(int i=0;i<26;++i){
        if(ch[0][i]) q.push(ch[0][i]);
    }
    while(q.size()){
        int u = q.front();q.pop();
        for(int i=0;i<26;++i){
            int v = ch[u][i];
            if(v) ne[v] = ch[ne[u]][i] , q.push(v);
            else ch[u][i] = ch[ne[u]][i];
        }
    }
}
void query(string& s){  // 查询模式串在主串中出现的次数
    int p = 0 ;
    for(int i=0;i<s.size();++i){
        p = ch[p][s[i] - 'a'] ;
        for(int j=p; j ; j=ne[j]) {
            c[cnt[j]]++;
        }
    }
}
void init(){
    memset(ch,0,sizeof(ch));
    memset(cnt,0,sizeof(cnt));
    memset(ne,0,sizeof(ne));
    memset(c,0,sizeof(c));
    idx = 0;
}
signed main(){
    int n ;
    while(cin >> n , n){
        init();
        string ma;
        for(int i=1;i<=n;++i) cin >> pat[i] , insert(pat[i],i); cin >> ma ;
        buildACauto();
        query(ma);
        int t = 0;
        for(int i=1;i<=n;++i) t = max(t,c[i]);
        cout << t << endl ;
        for(int i=1;i<=n;i++)if(c[i]==t) cout << pat[i] << endl ;
    }
    system("pause");
}
```



# KMP算法

数组下标从 1 开始

## KMP实现

**参考：**

[KMP算法—终于全部弄懂了_June·D的博客-CSDN博客_kmp算法](https://blog.csdn.net/dark_cy/article/details/88698736)

[KMP算法之求next数组代码讲解_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV16X4y137qw/?spm_id_from=autoNext&vd_source=787f243f7baf8e15cdf94b95889673a0)

[【天勤考研】KMP算法易懂版_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1jb411V78H/?spm_id_from=333.337.search-card.all.click&vd_source=787f243f7baf8e15cdf94b95889673a0)

**next数组：**next[i] = k 表示s[i]之前的子串中，存在长度为k的相同前缀和后缀

**模板题目：[P3375 【模板】KMP字符串匹配 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3375)**

```c++
int kmp(string& a , string& b)
{
    int n = a.size() , m = b.size() ;
    vector<int> ne(m) ; ne[0] = -1 ; int j = -1 ;
    for(int i = 1 ; i < m ; ++ i)
    {
        while(~j && b[i] != b[j + 1]) j = ne[j] ;
        if(b[i] == b[j + 1]) j ++ ;
        ne[i] = j ;
    }
    j = -1 ;
    for(int i = 0 ; i < n ; ++ i)
    {
        while(~j && a[i] != b[j + 1]) j = ne[j] ;
        if(a[i] == b[j + 1]) j ++ ;
        if(j == m - 1) return i - j - 1 ;
    }
    return -1 ;
}
```

### 例题：重复叠加字符串的匹配

**题目：[686. 重复叠加字符串匹配 - 力扣（LeetCode）](https://leetcode.cn/problems/repeated-string-match/)**

```c++
class Solution {
public:
    void get_nex(string& s,vector<int>& ne){
        int n = s.size() ; ne[0] = -1 ; int j = -1 ;
        for(int i=1;i<n;++i){
            while(~j && s[i] != s[j+1]) j = ne[j] ;
            if(s[i] == s[j+1]) j++ ;
            ne[i] = j ;
        }
    }
    int KMP(string& a,string& b){
        vector<int> ne(b.size()) ; int n = a.size() ;
        get_nex(b,ne) ; int j = -1 ;
        for(int i=0;i < n + b.size();++i){
            while(~j && a[i%n] != b[j + 1]) j = ne[j] ;
            if(a[i%n] == b[j+1]) j ++ ;
            if(j == b.size() - 1) return i - j ;
        }
        return -1 ;
    }
    int repeatedStringMatch(string a, string b) {
        int an = a.size(), bn = b.size();
        int index = KMP(a, b);
        if (index == -1) {
            return -1;
        }
        if (an - index >= bn) {
            return 1;
        }
        return (bn + index - an - 1) / an + 2;
    }
};

```

### 找出字符串中第一个匹配项的下标（LC 28）

**题目：[28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)**

```c++
class Solution {
public:
    int strStr(string haystack, string needle) {
        int n = haystack.size() , m = needle.size() ;
        vector<int> nex(m) ;
        nex[0] = -1 ; int j = -1 ;
        for(int i=1;i<m;++i){
            while(~j && needle[i] != needle[j+1]) j = nex[j] ;
            if(needle[i] == needle[j+1]) j ++ ;
            nex[i] = j ;
        }
        j = -1 ;
        for(int i=0;i<n;++i){
            while(~j && haystack[i] != needle[j+1]) j = nex[j] ;
            if(haystack[i] == needle[j+1]) j ++ ;
            if(j == m - 1) return i - j ;
        }
        return -1 ;
    }
};
```



## 扩展KMP（Z函数）

**参考：[Z 函数（扩展 KMP） - OI Wiki (oi-wiki.org)](https://oi-wiki.org/string/z-func/)**

```
z[i] : 表示s 和 s[i...n-1] 的最长公共前缀的长度
```

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1001;
int z[N]; 
void get_z(string& s){
    int n = s.size(),l=0,r=0;
    z[0] = n;  
    for(int i=1;i<n;++i){
        if(i > r){
            while(i+z[i] < n && z[i] < n && s[i+z[i]] == s[z[i]]) z[i]++;
            l = i; r = i+z[i]-1;
        }else if(z[i-l] < r-i+1){
            z[i] = z[i-l];
        }else {
            z[i] = r-i+1;
            while(i+z[i] < n && z[i] < n && s[i+z[i]] == s[z[i]]) z[i]++;
            l = i; r = i+z[i]-1;
        }
    }
    for(int i=0;i<n;++i) cout << z[i] << " ";
}
int main(){
    string s;
    cin >> s;
    get_z(s);
    system("pause");
}
```

## 扩展KMP（extend函数）

```
ext[i] : s1的第i为开始的后缀与s2的最长公共前缀（LCP）
```

**模板题目：[P5410 【模板】扩展 KMP（Z 函数） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5410)**

```c++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N = 2e7+1;
char s1[N],s2[N];
int z[N],ext[N];
void getz(char* s){
    int l = 0 , r = 0 , n = strlen(s+1) ;
    z[1] = n ;
    for(int i=2;i<=n;++i){
        // 盒子长度就是盒子内的字符个数
        if(i > r){
            while(s[i + z[i]] == s[1 + z[i]]) z[i]++ ;
            l = i ; r = z[i] + i - 1 ;
        } else if(z[i - l + 1] < r - i + 1) {
            z[i] = z[i - l + 1] ;
        } else {
            z[i] = r - i + 1 ;
            while(s[i + z[i]] == s[1 + z[i]]) z[i]++ ;
            l = i ; r = z[i] + i - 1 ;
        }
    }
}
void getext(char* s1 , char* s2){
    int l = 0 , r = 0 , p = 1 , n = strlen(s1+1) , m = strlen(s2+1);
    getz(s2) ;
    while(p <= n && p <= m && s1[p] == s2[p]) p++;
    ext[1] = p - 1 ;
    for(int i=2;i<=n;++i){
        if(i > r) { 
            while(i + ext[i] <= n && 1 + ext[i] <= m && s1[i + ext[i]] == s2[1 + ext[i]]) ext[i]++ ;
            l = i ; r = ext[i] + i - 1 ;
        } else if(z[i - l + 1] < r - i + 1){
            ext[i] = z[i - l + 1] ;
        } else {
            ext[i] = r - i + 1 ;
            while(i + ext[i] <= n && 1 + ext[i] <= m && s1[i + ext[i]] == s2[1 + ext[i]]) ext[i]++ ;
            l = i ; r = ext[i] + i - 1 ;
        }
    }
    //for(int i=1;i<=m;++i) cout << z[i] << " " ; cout << endl ;
    //for(int i=1;i<=n;++i) cout << ext[i] << " " ; cout << endl ;
}
ll getval(int* arr , int n){
    ll ans = 0;
    for(int i=1;i<=n;++i){
        ans ^= (ll)(i * (ll)((ll)arr[i]+1LL));
    }
    return ans ;
}
signed main(){
    ios::sync_with_stdio(0) ; cin.tie(nullptr) ;
    cin >> s1+1 >> s2+1 ;
    getext(s1,s2);
    cout << getval(z,strlen(s2+1)) << endl ;
    cout << getval(ext,strlen(s1+1)) << endl ;
    system("pause");
}

```

# Manacher 算法

**专门处理最长回文串问题，线性时间**

**参考：[图解马拉车算法 ](https://leetcode.cn/problems/longest-palindromic-substring/solution/tu-jie-ma-la-che-suan-fa-by-wang_ni_ma-if33/)**

**题目：[5. 最长回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-substring/)**

```c++
// 马拉车算法
class Solution {
public:
    string longestPalindrome(string ss) {
        string s = "#" ; 
        for(auto c : ss) s += c , s += "#" ;
        int n = s.size() ; int len = 0 , idx = -1 ;
        vector<int> armlen(n) ; int right = 0 , center = 0 ;
        for(int i = 0 ; i < n ; ++ i)
        {
            if(right < i) 
            {
                int i_left = i , i_right = i ;  // 确定开始的左边界和右边界
                
                while(i_left >= 0 && i_right < n && s[i_left] == s[i_right]) 
                {
                    i_left -- , i_right ++ ;
                }

                armlen[i] = (i_right - i_left - 2) / 2 ;  // 多走了一步
            }
            else
            {
                int i_mirror = 2 * center - i ;  // i + i_mirror= 2 * center
                int start_len = min(right - i , armlen[i_mirror]) ; // 根据镜像位置确定开始的长度
                int i_left = i - start_len , i_right = i + start_len ;  // 确定开始的左边界和右边界
                
                while(i_left >= 0 && i_right < n && s[i_left] == s[i_right]) 
                {
                    i_left -- , i_right ++ ;
                }

                armlen[i] = (i_right - i_left - 2) / 2 ;  // 多走了一步
            }
            if(len < armlen[i]) len = armlen[i] , idx = i ;
            if(right < i + armlen[i]) right = i + armlen[i] , center = i ;
        }
        return ss.substr((idx - armlen[idx]) / 2, len) ;
    }
};

// 中心扩散法
class Solution {
public:
    string init(string& s) {
        string t="";
        for(int i=0 ; i < s.size() ; ++ i) {
            t += "#" + s.substr(i,1) ;
        }
        t += "#" ;
        return t; 
    }
    string longestPalindrome(string s) {
        string t = init(s);
        int len = 1 , idx = 0;
        for(int i=0 ; i < t.size() ; ++ i) {
            int p = i - 1, q = i + 1 ;
            int tm = t[i] == '#' ? 0:1;
            while(p >= 0 && q < t.size() && t[p] == t[q]) {
                if(t[p] != '#') tm += 2 ;
                if(t[p] != '#' && len < tm) {
                    len = tm ; idx = p / 2 ;
                } 
                p -- ; q ++ ;
            }
        }
        return s.substr(idx,len);
    }
};

// 动态规划
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        bool dp[n][n] ;  // dp[i][j]代表子串i~j是否是回文子串
        int maxlen = 1;  // 最长回文子串的长度
        int index = 0;  // 最长回文子串的起始下标
        for(int j=1;j<n;j++){ 
            for(int i=0;i<j;i++){
                if(s[i] != s[j]){
                    dp[i][j] = false;
                }else{
                    if(j-i+1<=3) dp[i][j] = true;  // 长度为 2或者3
                    else{  // 否则
                        dp[i][j] = dp[i+1][j-1];
                    }
                    if(dp[i][j] && (j-i+1)>maxlen){
                        maxlen = j-i+1;
                        index = i;
                    }
                }
            }
        }
        return s.substr(index,maxlen);
    }
};
```

# 后缀自动机（SAM）

根节点是 1 

**参考：**

[后缀自动机详解 ](https://www.luogu.com.cn/blog/Kesdiael3/hou-zhui-zi-dong-ji-yang-xie)

字符串的 SAM 可以理解为给定字符串的 所有子串 的压缩形式。值得注意的事实是， SAM 将所有的这些信息以高度压缩的形式储存

![屏幕截图_20221226_202731](初学上课笔记.assets\屏幕截图_20221226_202731.png)

![屏幕截图_20221226_202749](初学上课笔记.assets\屏幕截图_20221226_202749.png)

![屏幕截图_20221226_203230](初学上课笔记.assets\屏幕截图_20221226_203230.png)

![屏幕截图_20221226_203243](初学上课笔记.assets\屏幕截图_20221226_203243.png)

**模板题目：[P3804 【模板】后缀自动机 (SAM) - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3804)**

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll ;
const int N = 2e6+1;  // 开两倍长度的点
// fa链接边的终点，ch转移边终点，len最长串的长度，cnt子串的出现的次数
int cnt[N],fa[N],ch[N][26],len[N];
// tot给节点编号，np指向新点,根节点是 1
int tot = 1 , np = 1;
char s[N] ; ll ans = 0; vector<int> e[N] ;
void extend(int c){  // 字符c
    int p = np ; np = ++tot;  // p指向旧点，np指向新点
    len[np] = len[p] + 1; cnt[np] = 1;  // 子串出现次数
    while(p && !ch[p][c]) ch[p][c] = np , p = fa[p];
    // 如果c是新字符
    if(p==0) fa[np] = 1;
    else {
        int q = ch[p][c] ;  // q是链接点
        if(len[q] == len[p] + 1) fa[np] = q ;
        else {  // 不合法就裂开q点，重新建立两类边
            int nq = ++tot;  // nq是新链接点
            len[nq] = len[p] + 1;
            fa[nq] = fa[q] ; fa[q] = nq; fa[np] = nq;
            while(p && ch[p][c]==q) ch[p][c] = nq , p = fa[p];
            memcpy(ch[nq],ch[q],sizeof(ch[q]));
        }
    }
}
void dfs(int u){
    for(auto v:e[u]){
        dfs(v);
        cnt[u] += cnt[v];
    }
    if(cnt[u] > 1) ans = max(ans,(ll)cnt[u]*len[u]);
}
signed main(){
    cin >> s+1 ; 
    for(int i=1;s[i];++i) extend(s[i] - 'a') ;
    for(int i=2;i<=tot;++i) e[fa[i]].push_back(i) ;
    dfs(1) ; cout << ans << endl ;
    system("pause");
    system("pause");
}
```



# 后缀数组

数组下标从 1 开始

**参考：[后缀数组简介 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/string/sa/#sa-is)**

**模板题目：[P3809 【模板】后缀排序 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3809)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6+10;
char s[N] ; 
// sa数组就是排序后的后缀字符串
// rk数组就是每个后缀字符串的val值大小
int sa[N] , rk[N << 1] , oldrk[N << 1] ;
// 为了防止访问 rk[i+w] 导致数组越界，开两倍数组。
// 当然也可以在访问前判断是否越界，但直接开两倍数组方便一些。
int n;
void get_sa(){
    for(int i = 1 ; i <= n ; ++i) sa[i] = i , rk[i] = s[i] ;
    for(int k = 1 ; k < n ; k <<= 1){
        sort(sa+1,sa+n+1,[&](int x,int y){
            return rk[x]==rk[y] ? rk[x+k]<rk[y+k] : rk[x]<rk[y] ;
        });
        // 若两个子串相同，它们对应的 rk 也需要相同，所以要去重
        memcpy(oldrk,rk,sizeof(rk));
        for(int p = 0 , i = 1 ; i <= n ; ++i){
            if(oldrk[sa[i]] == oldrk[sa[i-1]] && oldrk[sa[i]+k] == oldrk[sa[i-1]+k])
                rk[sa[i]] = p;
            else rk[sa[i]] = ++p ;
        }
    }
}
void get_height(){
    return ;
}
int main(){
    //ios::sync_with_stdio(0);cin.tie(nullptr);cout.tie(nullptr);
    cin >> s+1 ; n = strlen(s+1);
    get_sa();
    for (int i = 1; i <= n; ++i) printf("%d ", sa[i]);
    system("pause");
}
```



## SA数组和Rank数组

**定义：**就是把一个字符串的每一个后缀都进行排序。在这个算法中，我们需要处理得到两个数组，第一个数组记录的排名第i的后缀是哪一个（sa数组），第二个数组（rank数组）是第i个后缀的排名是多少。

**重要性质：** sa 和 rk 数组互为反函数 ， 即 `sa[rk[x]] = rk[sa[x]] = x`

![屏幕截图_20221227_115234](初学上课笔记.assets\屏幕截图_20221227_115234.png)

```c++
#include <bits/stdc++.h>
#define debug cout << "__LINE__ : " << __LINE__ << endl ;
using namespace std ;

using ll = long long ;

pair<vector<int>,vector<int>> getsa(string& s){
    int n = s.size() ; vector<int> sa(n) , rk(n << 1) , bk(n << 1) ; 

    for (int i = 0; i < n; ++i)
    {
        sa[i] = i ; rk[i] = s[i] ;
    }

    for (int i = 1; i < n; i <<= 1)
    {
        sort(sa.begin(),sa.end(),[&](int& x,int& y){
            return tie(rk[x],rk[x+i]) < tie(rk[y],rk[y+i]) ;
        }) ;
        bk = rk ; int p = -1 ;
        for (int j = 0; j < n; ++j)
        {
            if(j > 0 && bk[sa[j]] == bk[sa[j-1]] && bk[sa[j]+i] == bk[sa[j-1]+i]) rk[sa[j]] = p ;
            else rk[sa[j]] = ++ p ;
        }
        if(p == n-1) break ;
    }

    // height
    int k = 0 ; vector<int> h(n) ;
    for (int i = 0; i < n; ++i)
    {
        if(rk[i]] == 0) continue ;
        if(k) -- k ;
        int j = sa[rk[i] - 1] ;
        while(i+k < n && j+k < n && s[i+k] == s[j+k]) ++ k ;
        h[rk[i]] = k ;
    }

    return {sa,h} ;
}

void solve(){
    string s ; cin >> s ; 
    auto it = getsa(s) ; 
    for(auto e : it.first) cout << e + 1 << " " ; cout << endl ;
}

signed main(){
    ios::sync_with_stdio(false) ; cin.tie(nullptr) ; cout.tie(nullptr) ;

    int t = 1 ;  // cin >> t ;

    while(t -- ){
        solve() ;
    }
    return 0 ;
}
```

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 2e6+10;
char s[N] ; int n , m;  // n是字符串的长度 ，m是桶的个数（不低于ASCill）
int sa[N] , rk[N << 1] , oldrk[N << 1] , height[N] ;
int c[N] , b[N]; 
void get_sa(){
    for(int i=1;i<=n;++i) sa[i] = i , rk[i] = s[i] ;
    for(int k=1;k<n;k<<=1){
        
        memset(c,0,sizeof(c));
        for(int i=1;i<=n;++i) c[rk[sa[i]+k]]++;
        for(int i=1;i<=m;++i) c[i] += c[i-1] ;
        for(int i=n;i>=1;--i) b[c[rk[sa[i]+k]]--] = sa[i] ;
        for(int i=1;i<=n;++i) sa[i] = b[i] ;
        memset(c,0,sizeof(c));
        for(int i=1;i<=n;++i) c[rk[sa[i]]]++;
        for(int i=1;i<=m;++i) c[i] += c[i-1] ;
        for(int i=n;i>=1;--i) b[c[rk[sa[i]]]--] = sa[i] ;
        for(int i=1;i<=n;++i) sa[i] = b[i] ;
        
        memcpy(oldrk,rk,sizeof(rk)); int p = 0;
        for(int i=1;i<=n;++i){
            if(oldrk[sa[i]]==oldrk[sa[i-1]]&&oldrk[sa[i]+k]==oldrk[sa[i-1]+k])
                rk[sa[i]] = p;
            else rk[sa[i]] = ++p;
        }
        if(p==n) break;
    }
}
void get_height(){
    int k = 0;
    for(int i=1;i<=n;++i){
        if(rk[i]==1) continue ;
        if(k) k--;
        int j = sa[rk[i]-1] ;
        while(i+k<=n && j+k<=n && s[i+k]==s[j+k]) k++;
        height[rk[i]] = k ;
    }
}
int main(){
    cin >> s+1 ; n = strlen(s+1); m = max(128,n) ;
    get_sa(); get_height();
    for (int i = 1; i <= n; ++i) printf("%d ", sa[i]);
    system("pause");
}
```

## height数组与h数组

所有子串都是某个**后缀的前缀**

**定义height[i]=k：**表示后缀Sa[i]和后缀Sa[i-1]的最长公共前缀的长度为k。

**定义LCP(a，b)：**表示后缀a和后缀b的最长公共前缀的长度。

**定义h数组：**h[i] = height[ Rank[i] ]，h[i]表达第i个后缀和排名在他之前一位的后缀的最长公共前缀。

**h数组有这样的性质：**![h[i]\geq h[i-1]-1](初学上课笔记.assets\geq h[i-1]-1.gif)
$$
LCP(a，b)=min（height[ Rank[a] ]、height[ Rank[a]+1]、height[ Rank[a]+2]、……、height[ Rank[b] ]）
$$
**例如：**字符串为"aabaaaab"，求后缀"abaaaab"和后缀"aaab"的最长公共前缀

```c++
int height[N] ;  // height[rk[i]] >= height[rk[i-1]] - 1
void get_height(){
    int k = 0 ; 
    for(int i=1;i<=n;++i){
        if(rk[i] == 1) continue ;  // height[1] = 0;
        if(k) k--;
        int j = sa[rk[i] - 1] ;
        while(i+k <= n && j+k <= n && s[i+k] == s[j+k]) k++;
        height[rk[i]] = k ; 
    }
}
```



## 后缀数组的应用

**直接用：**

```c++
class SA{
    public:
        static const int N = 3e4+1;
        string s;
        int n ;
        int height[N] , sa[N] , rk[N << 1] , oldrk[N << 1] ; 
        SA(string t){
            this->s = " " + t;
            n = t.size() ;
            init();
            get_sa();
            getHeight();
        }
        void init(){
            memset(height,0,sizeof(height));
            memset(sa,0,sizeof(sa));
            memset(rk,0,sizeof(rk));
            memset(oldrk,0,sizeof(oldrk));
        }
        void get_sa(){
            for(int i=1;i<=n;++i) sa[i] = i , rk[i] = s[i] ;
            for(int k=1;k<n;k<<=1){
                sort(sa+1,sa+n+1,[&](int x,int y){
                    return rk[x]==rk[y] ? rk[x+k]<rk[y+k] : rk[x]<rk[y] ;
                });
                memcpy(oldrk,rk,sizeof(rk)); int p = 0;
                for(int i=1;i<=n;++i){
                    if(oldrk[sa[i]]==oldrk[sa[i-1]] && oldrk[sa[i]+k]==oldrk[sa[i-1]+k])
                        rk[sa[i]] = p;
                    else rk[sa[i]] = ++p ;
                }
                if(p == n) break;
            }
        }
        void getHeight(){
            int k = 0; 
            for(int i=1;i<=n;++i){
                if(rk[i] == 1) continue;
                if(k) k--;
                int j = sa[rk[i]-1] ;
                while(i+k <=n && j+k <= n && s[i+k]==s[j+k]) k++;
                height[rk[i]] = k;
            }
        }
    };
```

### 求任意后缀的最大LCP（height）

任意后缀的LCP ： 

```
如后缀 i 和 后缀 j 的 LCP
i 和 j 的排名分别是 rk[i] 和 rk[j] 
LCP(i,j) = min(height[rk[i] + 1] ~ height[rk[j]])
```



### 可重叠k次最长重复子串的长度

**题目：[P2852 [USACO06DEC\]Milk Patterns G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2852)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 4e4 + 10 ;
int sa[N],rk[N << 1],oldrk[N << 1],height[N];
int n , k ; int s[N] ;
void get_sa(){
	for(int i=1;i<=n;++i) sa[i] = i , rk[i] = s[i] ;
	for(int k=1;k<n;k<<=1){
		sort(sa+1,sa+1+n,[&](int x,int y){
			return rk[x]==rk[y]?rk[x+k]<rk[y+k]:rk[x]<rk[y];
		});
		memcpy(oldrk,rk,sizeof(rk)); int p = 0 ;
		for(int i=1;i<=n;++i){
			if(oldrk[sa[i]]==oldrk[sa[i-1]]&&oldrk[sa[i]+k]==oldrk[sa[i-1]+k])
				rk[sa[i]] = p;
			else rk[sa[i]] = ++p ;
		}
		if(p == n) break;
	}
}
void get_height(){
	int k = 0;
	for(int i=1;i<=n;++i) {
		if(rk[i]==1) continue ;
		if(k) k-- ;
		int j = sa[rk[i]-1] ;
		while(i+k <= n && j+k <= n && s[i+k]==s[j+k]) k++;
		height[rk[i]] = k;
	}
}
class MyDeque{
public:
	deque<int> q;
	void pop(int val){
		if(q.front() == val) q.pop_front();
	}	
	void push(int val){
		while(q.size() && q.back() > val) q.pop_back();
		q.push_back(val) ;
	}
	int getMin(){
		return q.front();
	}
};

int main(){
	cin >> n >> k ;
	for(int i=1;i<=n;++i) cin >> s[i] ; 
	get_sa() ; get_height() ;
	MyDeque que; int ans = 0; k -= 1;
	for(int i=1;i<=n;++i){
		if(i<k) que.push(height[i]);
		else{
			que.push(height[i]);
			ans = max(ans,que.getMin()) ;
			que.pop(height[i-k+1]);
		}
	}
	cout << ans << endl ;
	system("pause");
}
```

### 不可重叠最长重复子串

[字符串----不可重叠的最长重复子串 - |旧市拾荒| - 博客园 (cnblogs.com)](https://www.cnblogs.com/xiaoyh/p/10328219.html)

### 本质不同的子串数量

所有子串都是某个**后缀的前缀**

所有后缀的所有前缀就是所有子串

**题目：[P2408 不同子串个数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2408)**

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6+10;

char s[N] ; int n ;
int height[N] , sa[N] , rk[N] , oldrk[N] ;
void get_sa(){
    for(int i=1;i<=n;++i) sa[i] = i , rk[i] = s[i] ;
    for(int k=1;k<n;k<<=1){
        sort(sa+1,sa+n+1,[&](int x,int y){
            return rk[x]==rk[y] ? rk[x+k]<rk[y+k] : rk[x]<rk[y] ;
        });
        memcpy(oldrk,rk,sizeof(rk)); int p = 0;
        for(int i=1;i<=n;++i){
            if(oldrk[sa[i]]==oldrk[sa[i-1]] && oldrk[sa[i]+k]==oldrk[sa[i-1]+k])
                rk[sa[i]] = p;
            else rk[sa[i]] = ++p ;
        }
        if(p == n) break;
    }
}
void getHeight(){
    int k = 0;
    for(int i=1;i<=n;++i){
        if(rk[i] == 1) continue;
        if(k) k--;
        int j = sa[rk[i]-1] ;
        while(i+k <=n && j+k <= n && s[i+k]==s[j+k]) k++;
        height[rk[i]] = k;
    }
}

signed main(){
    cin >> n ; cin >> s+1 ;
    get_sa(); getHeight();
    int tp = 0 ;
    for(int i=1;i<=n;++i) tp += height[i] ;
    cout << n*(n+1)/2 - tp << endl ;
    system("pause");
}
```

**rank: 1~N**

**sa: 1~N**

**height:1~N,height[1] = 0**

**h : 1~N**



# 最小表示法

**参考：[最小表示法 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/string/minimal-string/)**

**模板题目：[P1368 【模板】最小表示法 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1368)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e7+1;
int n ;
int s[N];
int getmin(int* s){
    for(int i=1;i<=n;++i) s[n+i] = s[i];
    int i = 1 ,j = 2 ; 
    while(i <= n && j <= n){
        int k = 0;
        while(k < n && s[i + k] == s[j + k]) ++k;
        s[i + k] > s[j + k] ? i = i + k + 1 : j = j + k + 1;
        if(i == j) j++;
    }
    return min(i,j);
}
int main(){
    cin >> n;
    for(int i=1;i<=n;++i) cin >> s[i] ;
    int k = getmin(s) ;
    for(int i=k;i<=(k+n-1);++i) cout << s[i] << " ";
    system("pause");
}
```

# 数学

## 高精度运算

### 高精度加法

**题目：[P1601 A+B Problem（高精） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1601)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 501 ;
int la , lb , lc ; int a[N] , b[N] , c[N] ;
void add(string& s1,string& s2){
    memset(a,0,sizeof(a)) ; memset(b,0,sizeof(b)) ; memset(c,0,sizeof(c)) ;
    la = s1.size() ; lb = s2.size() ; lc = max(la , lb) ;
    for(int i=la-1;i>=0;--i) a[la-i-1] = s1[i] - '0' ;
    for(int i=lb-1;i>=0;--i) b[lb-i-1] = s2[i] - '0' ;
    for(int i=0;i<lc;++i){
        c[i] += a[i] + b[i] ;
        c[i+1] += c[i] / 10 ;
        c[i] %= 10 ;
    }
    if(c[lc]) lc++; // 最高位处理
}
int main(){
    string s1 , s2 ; cin >> s1 >> s2 ; 
    add(s1,s2) ;
    for(int i=lc-1;i>=0;--i) cout << c[i] ;
    system("pause") ;
}
```

### 高精度减法

**题目：[P2142 高精度减法 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2142)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 10087 ;
int la , lb , lc ; int a[N] , b[N] , c[N] ;
void sub(string& s1,string& s2){
    memset(a,0,sizeof(a)) ; memset(b,0,sizeof(b)) ; memset(c,0,sizeof(c)) ;
    la = s1.size() ; lb = s2.size() ; lc = max(la , lb) ;
    for(int i=la-1;i>=0;--i) a[la-i-1] = s1[i] - '0' ;
    for(int i=lb-1;i>=0;--i) b[lb-i-1] = s2[i] - '0' ;
    if(!(la!=lb?la>lb:s1>=s2)) swap(a,b), cout << '-' ;
    for(int i=0;i<lc;++i){
        if(a[i] < b[i])
            a[i+1] -- , a[i] += 10 ;
        c[i] = a[i] - b[i] ;
    }
    while(lc-1 && c[lc-1]==0) lc-- ; 
}
int main(){
    string s1,s2 ; cin>> s1 >> s2 ;
    sub(s1,s2) ;
    for(int i=lc-1;i>=0;--i) cout << c[i] ;
    system("pause") ;
}
```

### 高精度乘法  

**题目：[P1303 A*B Problem - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1303)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 10087 ;
int la , lb , lc ; int a[N] , b[N] , c[N] ;
void mul(string& s1,string& s2){
    memset(a,0,sizeof(a)) ; memset(b,0,sizeof(b)) ; memset(c,0,sizeof(c)) ;
    la = s1.size() ; lb = s2.size() ; lc = la + lb ;
    // 也可以不需要倒序
    for(int i=la-1;i>=0;--i) a[la-i-1] = s1[i] - '0' ;
    for(int i=lb-1;i>=0;--i) b[lb-i-1] = s2[i] - '0' ;
    for(int i=0;i<la;++i) for(int j=0;j<lb;++j) {
        c[i+j] += a[i] * b[j] ;
        c[i+j+1] += c[i+j] / 10 ;
        c[i+j] %= 10 ; 
    }
    while(lc-1 && c[lc-1]==0) lc-- ; 
}
int main(){
    string s1,s2 ; cin>> s1 >> s2 ;
    mul(s1,s2) ;
    for(int i=lc-1;i>=0;--i) cout << c[i] ;
    system("pause") ;
}
```

### 高精度除法

**题目：[P1480 A/B Problem - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1480)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 10087 ;
int la , lc ; int a[N] , c[N] ;
void div(string& s1,int b){
    memset(a,0,sizeof(a)) ; ; memset(c,0,sizeof(c)) ;
    la = lc = s1.size() ; long long r = 0 ;
    for(int i=0;i<la;++i) a[i] = s1[i] - '0' ;
    for(int i=0;i<la;++i) {
        r = r * 10 + a[i] ; 
        c[i] = r / b ;
        r %= b ;
    }
    reverse(c,c+lc) ;
    while(lc-1 && c[lc-1]==0) lc-- ; 
}
int main(){
    string s1 ; int b ; cin>> s1 >> b ;
    div(s1,b) ;
    for(int i=lc-1;i>=0;--i) cout << c[i] ;
    system("pause") ;
}
```

## 快速幂

### **普通快速幂**

**题目：[P1226 【模板】快速幂||取余运算 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1226)**

```c++
#include <bits/stdc++.h>
typedef long long ll ;
using namespace std ; 
const int N= 1e5+10 ; 
ll quickpow(ll a,ll b,ll p){
    ll res = 1 ; a %= p ;
    while(b){
        if(b & 1) res = ( res * a ) % p ;
        a = ( a * a ) % p ;
        b >>= 1 ;
    }
    return res ;
}
int main(){
    ll a , b , p ; cin >> a >> b >> p ;
    cout << a << "^" << b << " mod " << p << "=" << quickpow(a,b,p) << endl ;
    system("pause") ;
}
```

### 高精度快速幂

**题目：[P1045 [NOIP2003 普及组\] 麦森数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1045)**

```c++
#include <bits/stdc++.h>
using namespace std ; 
const int N= 1e3 + 10 ; 
vector<int> a(N) , res(N) ;
vector<int> mul(vector<int>& a,vector<int>& b){
    vector<int> c(N) ;
    for(int i=0;i<500;++i) for(int j=0;j<500;++j){
        c[i+j] += a[i] * b[j] ;
        c[i+j+1] += c[i+j] / 10 ;
        c[i+j] %= 10 ;
    }
    return c ; 
}
void quickpow(int A, int B){
    res[0] = 1 ; a[0]= A ;
    while(B){
        if(B & 1) res = mul(res , a) ;
        a = mul(a , a) ;
        B >>= 1 ;
    }
}
int main(){
    int p ; cin >> p ;
    cout << (int)(p * log10(2)) + 1 << endl ;
    quickpow(2,p) ; res[0] -- ;
    for(int i=499;i>=0;--i){
        cout << res[i] ;
        if(i%50==0 && i) cout << endl ;
    }
    system("pause") ;
}
```

### 矩阵快速幂

**矩阵相乘注意先后顺序**

**题目：[P3390 【模板】矩阵快速幂 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3390)**

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std ; 
const int N= 1e2 + 10 , P = 1e9+7 ; 
int n , k ; 
struct matrix{
    int c[N][N] ; 
    matrix(){memset(c,0,sizeof(c)) ;}
};
matrix operator*(matrix& a,matrix& b){
    matrix c ; 
    for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) for(int k=1;k<=n;++k){
        c.c[i][j] = ( c.c[i][j] + a.c[i][k] * b.c[k][j] ) % P ;
    }
    return c ;
}
matrix quickpow(matrix& a , int b){
    matrix res ; for(int i=1;i<=n;++i) res.c[i][i] = 1 ;
    while(b){
        if(b & 1) res = res * a ;
        a = a * a ;
        b >>= 1 ;
    }
    return res ;
}
signed main(){
    matrix m ;  cin >> n >> k ;
    for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) cin >> m.c[i][j] ;
    matrix res = quickpow(m,k) ;
    for(int i=1;i<=n;++i){
        for(int j=1;j<=n;++j){
            cout << res.c[i][j] << " " ;
        }
        cout << endl ;
    }
    system("pause") ;
}
```

### 矩阵快速幂加速递推

**题目：[P1962 斐波那契数列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1962)**

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std ; 
const int P = 1e9 + 7 ;
int n ;
struct matrix{
    int c[2][2] ; 
    matrix(){memset(c,0,sizeof(c)) ;}
};
matrix operator*(matrix& a,matrix& b){
    matrix c ; 
    for(int i=0;i<2;++i) for(int j=0;j<2;++j) for(int k=0;k<2;++k){
        c.c[i][j] = (c.c[i][j] + a.c[i][k] * b.c[k][j]) % P;
    }
    return c ;
}
matrix quickpow(matrix& a , int b){
    matrix res ; 
    for(int i=0;i<2;++i) res.c[i][i] = 1 ;
    while(b){
        if(b & 1) res = res * a ;
        a = a * a ;
        b >>= 1 ;
    }
    return res ;
}
signed main(){
    matrix m ; m.c[0][0] = m.c[0][1] = m.c[1][0] = 1 ; 
    matrix t ; t.c[0][0] = t.c[0][1] = 1 ; 
    cin >> n ; if(n <= 2) return cout << 1 << endl , 0 ;
    matrix q = quickpow(m,n-2) ;
    matrix res = t * q ;  // 矩阵相乘注意先后顺序
    cout << res.c[0][0] % P << endl ;
    system("pause") ;
}
```



## 最大公约数与最小公倍数

**性质： pq = gcd(p,q)*lcm(p,q)**

```c++
ll gcd(ll a,ll b){ // a>b
    return b==0? a:gcd(b,a%b) ; 
}
ll lcm(ll a ,ll b){
    return a * b / gcd(a,b) ;
}
```

**例题：[P1029 [NOIP2001 普及组\] 最大公约数和最小公倍数问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1029)**

```c++
#include <bits/stdc++.h>
using namespace std ;
typedef long long ll ;
const int N = 1e6 + 10 ;
int x , y ; int ans ;
ll gcd(ll a,ll b){ // a>b
    return b==0? a:gcd(b,a%b) ; 
}
ll lcm(ll a ,ll b){
    return a * b / gcd(a,b) ;
}
int main(){
    cin >> x >> y ; 
    if(x == y) return cout << 1 << endl , 0 ;
    int t = x * y ;
    for(int i=1;i<=sqrt(t);++i){
        if(t % i == 0 && gcd(i,t/i) == x) ans += 2 ;
    }
    cout << ans << endl ;
    system("pause") ;
}
```



## 质数

### 判定质数（试除法）

**题目：[P5736 【深基7.例2】质数筛 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5736)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e5+10 ;
int n ;
bool isPrime(int x){
    if(x == 1) return false ;
    int t = sqrt(x) ;
    for(int i=2;i<=t;++i) if(x % i == 0) return false ;
    return true ;
}
int main(){
    cin >> n ; int x ;
    for(int i=1;i<=n;++i){
        cin >> x ; if(isPrime(x)) cout << x << " " ;
    }
    system("pause") ;
}
```

### 埃氏筛法

**题目：[P3383 【模板】线性筛素数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3383)**

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std ;
const int N = 1e8+10 ;
int n , q ; bool vis[N] ; int prime[N] , cnt ;  // vis 是否是合数
void get_prime(){
    for(int i=2;i<=n;++i){
        if(vis[i]) continue ;
        prime[++cnt] = i ;
        for(int j=i*i;j<=n;j+=i) vis[j] = true ;
    }
}
signed main(){
    scanf("%d %d",&n,&q) ; int k ; get_prime() ;
    for(int i=1;i<=q;++i) scanf("%d",&k) , printf("%d\n",prime[k]) ;
    system("pause") ;
}
```

### 欧拉筛法（线性筛法）

**题目：[P3383 【模板】线性筛素数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3383)**

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std ;
const int N = 1e8+10 ;
int n , q ; bool vis[N] ; int prime[N] , cnt ;  // vis 是否是合数
void get_prime(){
    for(int i=2;i<=n;++i){
        if(!vis[i]) prime[++cnt] = i ; ;
        for(int j=1;prime[j]*i<=n;++j){
            vis[i*prime[j]] = true ;
            if(i % prime[j] == 0) break ;
        }
    }
}
signed main(){
    scanf("%d %d",&n,&q) ; int k ; get_prime() ;
    for(int i=1;i<=q;++i) scanf("%d",&k) , printf("%d\n",prime[k]) ;
    system("pause") ;
}
```

### 分解质因数（唯一分解定理）

![屏幕截图_20230103_191639](初学上课笔记.assets\屏幕截图_20230103_191639.png)

**题目：[P2043 质因子分解 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2043)**

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std ;
const int N = 1e5+10 ;
int n ; int a[N] ; // a[i]质数i的个数
void decompose(int x){  // 分解质因数
    for(int i=2;i<=sqrt(x);++i) while(x%i==0) a[i]++ , x /= i ;
    if(x > 1) a[x]++ ; // 剩下就是质数
}
signed main(){
    scanf("%d",&n) ;
    for(int i=1;i<=n;++i) decompose(i) ;
    for(int i=1;i<=n;++i) if(a[i]) printf("%d %d\n",i,a[i]) ;
    system("pause") ;
}
```

### 欧拉筛法求欧拉函数

![屏幕截图_20230103_191925](初学上课笔记.assets\屏幕截图_20230103_191925.png)

```c++
// 欧拉筛
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e6+10 ;
int n ;
int prime[N] , cnt , vis[N] ;
int phi[N] ;  // 欧拉函数，1~n中与n与互质的个数
void get_phi(){
    for(int i=2;i<=n;++i){
        if(!vis[i]) prime[++cnt] = i , phi[i] = i - 1 ;
        for(int j=1;j<=cnt && i*prime[j]<=n;++j){
            int m = i * prime[j] ;
            vis[m] = 1 ;
            if(i % prime[j] == 0){
                phi[m] = phi[i] * prime[j] ;
                break ;
            } else {
                phi[m] = phi[i] * phi[prime[j]] ;
            }
        }
    }
}
int main(){
    scanf("%d",&n) ; get_phi() ;
    system("pause") ;
}
```

```c++
// 试除法
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e6+10 ;
int n ;
int phi(int x){  // 公约数只有 1 的个数
    int res = x ;
    for(int i=2;i<=sqrt(x);++i){
        if(x%i==0){
            res = res / i * (i-1) ;
            while(x%i == 0) x /= i ; 
        }
    }
    if(x > 1) res = res / x * (x-1) ;
    return res ;
}
int main(){
    scanf("%d",&n) ; printf("%d",phi(n)) ;
    system("pause") ;
}
```

### 欧拉筛法求约数个数

![屏幕截图_20230103_204943](初学上课笔记.assets\屏幕截图_20230103_204943.png)

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e6+10 ;
int n ;
int prime[N] , cnt , vis[N] ;
int a[N] , d[N] ; // a[i]:记录i的最小质因数的次数 ，d[i]：记录i的约数个数
void get_divisor(){
    for(int i=2;i<=n;++i){
        if(!vis[i]){
            prime[++cnt] = i ;
            a[i] = 2 ; d[i] = 1 ;
        }
        for(int j=1;j<=cnt && i*prime[j]<=n;++j){
            int m = i * prime[j] ;
            if(i % prime[i] == 0) {
                a[m] = a[i] + 1 ; d[m] = d[i] / a[m] * (a[m] + 1) ;
            }else{
                a[m] = 1 ; d[m] = d[i] * 2 ;
            }
        }
    }
}
int main(){
    scanf("%d",&n) ; get_divisor() ;
    system("pause") ;
}
```

### 欧拉筛法求约数和

![屏幕截图_20230103_210018](初学上课笔记.assets\屏幕截图_20230103_210018.png)

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e6+10 ;
int n ;
int prime[N] , cnt , vis[N] ;
int g[N] , f[N] ; // g[i]:记录i的最小质因数的p^0+p^1+...+p^k ，f[i]：记录i的约数和
void get_divisor(){
    for(int i=2;i<=n;++i){
        if(!vis[i]){
            prime[++cnt] = i ;
            g[i] = 1 + i ; f[i] = 1 + i ;
        }
        for(int j=1;j<=cnt && i*prime[j]<=n;++j){
            int m = i * prime[j] ;
            if(i % prime[i] == 0) {
                g[m] = g[i] * prime[j] + 1 ; 
                f[m] = f[i] / g[i] * g[m] ;
            }else{
                g[m] = 1 + prime[j] ;
                f[m] = g[m] * f[i] ;
            }
        }
    }
}
int main(){
    scanf("%d",&n) ; get_divisor() ;
    system("pause") ;
}
```



### 欧拉筛法求莫比乌斯函数

## 组合问题

### 隔板法

[巧用隔板法快速攻破行测排列组合难题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/144997851)

**例题：[1735. 生成乘积数组的方案数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-ways-to-make-array-with-product/)**

```c++
基本： C[n-1][m-1] 每个堆至少一个的方案数
```

### 递推求解组合数

```c++
for(int i=1;i<N;++i){
    for(int j=0;j<=i;++j){
        if(j == 0 || j == i) C[i][j] = 1 ;
        else C[i][j] = C[i-1][j-1] + C[i-1][j] ;
    }
}
```

### 公式法

```c++
class Solution {
public:
    static const int N = 10100 ;
    static const int P = 1e9+7 ;
    static array<int,N> A ; static bool inited ;
    ll mod(ll x){return (x + P) % P ;}
    ll quickpow(ll a,ll b,ll p){
        ll res = 1 ; a %= p ;
        while(b){
            if(b&1) res = (res * a) % p ;
            a = (a * a) % p ;
            b >>= 1 ;
        }
        return res ;
    }
public:
    int C(int n,int m){
        return mod(1LL * A[n] * quickpow(1LL * A[m] * A[n - m] , P - 2 , P)) ;
    }
```



## 乘法逆元

**[2514. 统计同位异构字符串数目 - 力扣（LeetCode）](https://leetcode.cn/problems/count-anagrams/)**

```c++
#include <bits/stdc++.h>
#define debug cout << "__LINE__ : " << __LINE__ <<endl ;
using namespace std ;


using ll = long long ;
class Solution {
private:
    static const int P = 1e9+7 ;
    static const int N = 1e5+1 ;
    ll mod(ll x){return (x%P + P)%P;}
    ll A[N] , B[N] ;  // 组合数和乘法逆元
public:
    ll quickpow(ll a,ll b,ll p){
        ll res = 1 ; a %= p ;
        while(b){
            if(b & 1) res = (res * a) % p ;
            a = (a * a) % p ;
            b >>= 1 ;
        }
        return res ;
    }
    Solution(){
        A[1] = 1 ; B[1] = 1 ;
        for(int i=2;i<N;++i) A[i] = mod(A[i-1] * i) , B[i] = quickpow(A[i] , P - 2 , P) ;
    }
    int countAnagrams(string s) {
        int i = 0 ; ll ans = 1 ; int pre = 0 ;
        while(i < s.size()){
            unordered_map<char,int> mp ;
            while(i < s.size() && s[i] != ' ') mp[s[i ++ ]] ++ ;
            ll tp = A[i - pre] ;
            for(auto e : mp){
                tp = mod(tp * B[e.second]) ;
            }
            //debug ; cout << mp.size() << " " << tp << endl ; cout << i << " " << pre << endl ;
            ans = mod(ans * tp) ; i ++ ; pre = i ;
        }
        return mod(ans) ;
    }
};
```



# 其他

## 二进制子集生成与排列组合

**参考：[二进制子集生成与排列组合_木木不会的博客-CSDN博客_二进制排列组合cn排序和二进制](https://blog.csdn.net/qq_43514659/article/details/111597289)**

**所有的子集**

[递归实现指数型枚举 (nowcoder.com)](https://ac.nowcoder.com/acm/problem/50911)

[递归实现组合型枚举 (nowcoder.com)](https://ac.nowcoder.com/acm/problem/50918)

[费解的开关 (nowcoder.com)](https://ac.nowcoder.com/acm/problem/50920)

```c++
#include<bits/stdc++.h>
using namespace std;
int main() {
    int n,a[100];
    cin >> n;
    for(int i=0;i<n;i++) cin>>a[i];
    for(int i=0;i<(1<<n);++i){   // 生成a[0..n-1]的所有子集
        for(int j=0;j<n;++j){
            if(i&(1<<j)) cout<<a[j]<<" ";
        }
        cout<<endl;
    }
    system("pause");
    return 0;
}

```

**所有的排列**

```c++
#include<bits/stdc++.h>
using namespace std;
int main() {
  int n,a[100];
  cin >> n;
  for(int i=0;i<n;i++) cin>>a[i];
  do{
      for(int i=0;i<n;++i) cout<<a[i]<<" ";
      cout<<endl;
  }while(next_permutation(a,a+n));
  system("pause");
  return 0;
}

```

## 哈希函数

```c++
hash<string> h;
cout << h("123456789") << endl; 
```

**c++添加hash**

```c++
struct node {
    int x, y ;
    bool operator==(const node& rhs) const {
        return x == rhs.x && y == rhs.y ;
    }
} ;

namespace std {
    template<>
    struct hash<node> {
        size_t operator()(const node& x) const noexcept {
            return std::hash<int>()(x.x) ^ std::hash<int>()(x.y) << 1 ;
        }
    } ;
}

void solve(){
    unordered_map<node, int> mp ;
    mp[{1,1}] = 1 ;
}
```

**模板：[P3370 【模板】字符串哈希 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3370)**

```c++
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int N = 1e4+1;
vector<ull> a;
ull P = 131;
ull has(string& s){
    ull ha=0;
    for(int i=0;i<s.size();++i){
        ha = ha*P + (ull)s[i];
    }
    return ha;
} 
int main(){
    int n;string s;
    cin >> n ;
    hash<string> h;
    for(int i=1;i<=n;++i){ 
        cin >> s;
        a.push_back(h(s));
    }
    sort(a.begin(),a.end());
    a.erase(unique(a.begin(),a.end()),a.end());
    cout << a.size() << endl;
    system("pause");
}
```



# =======================================================================================================================================

# 小技巧

``` c++
// 让cin，cout起飞
i0os::sync_with_stdio(0) ; cin.tie(nullptr) ; cout.tie(nullptr) ;
```

```c++
stringstream ss("")  // 这玩意看流向什么，就以什么作为结束标志，流向整数就以不是数字作为结束标志，流向字符串就以空格作为结束表标志 
```

[【总结】GCC内置函数 - 比特位计数 - 力扣（LeetCode）](https://leetcode.cn/problems/counting-bits/solution/by-gelei-k-fayv/)

```c++
// tuple 
struct node{
    int first , second ;
    bool operator<(const node& rhs){
        return std::tie(first,second) < std::tie(rhs.first,rhs.second) ;
    }
} ;
int second ;
std::tie(std::ignore , second) = make_pair(1,2) ;
cout << second ;
tuple<int,string,int,int> tp ;
```

# 排序

## [游戏中弱角色的数量](https://leetcode.cn/problems/the-number-of-weak-characters-in-the-game/)

```c++
class Solution {
public:
    int numberOfWeakCharacters(vector<vector<int>>& properties) {
        int ans = 0 ; int n = properties.size() ;
        int tp = INT_MIN ;
        sort(properties.begin(),properties.end(),[&](auto& e1,auto& e2){
            return e1[0] == e2[0] ? e1[1] < e2[1] : e1[0] > e2[0] ; 
        }) ;
        for(auto& e : properties){
            if(e[1] < tp) ans ++ ; 
            tp = max(tp , e[1]) ;
        }
        return ans ;
    }
};
```

## [数组中的 k 个最强值](https://leetcode.cn/problems/the-k-strongest-values-in-an-array/)

```c++
class Solution {
public:
    vector<int> getStrongest(vector<int>& arr, int k) {
        int n = arr.size() ;
        nth_element(arr.begin(),arr.begin() + (n - 1) / 2,arr.end()) ;
        int m = arr[(n - 1) / 2] ; 
        sort(arr.begin(),arr.end(),[&](auto& e1,auto& e2){
            int a = abs(e1 - m) , b = abs(e2 - m) ;
            return a == b ? e1 > e2 : a > b ;
        }) ;
        return vector<int>(arr.begin(),arr.begin()+k) ;
    }
};
```

## [两个最好的不重叠活动](https://leetcode.cn/problems/two-best-non-overlapping-events/)

```c++
struct Event {
    // 时间戳
    int ts;
    // op = 0 表示左边界，op = 1 表示右边界
    int op;
    int val;
    Event(int _ts, int _op, int _val): ts(_ts), op(_op), val(_val) {}
    bool operator< (const Event& that) const {
        return tie(ts, op) < tie(that.ts, that.op);
    }
};

class Solution {
public:
    int maxTwoEvents(vector<vector<int>>& events) {
        vector<Event> evs;
        for (const auto& event: events) {
            evs.emplace_back(event[0], 0, event[2]);
            evs.emplace_back(event[1], 1, event[2]);
        }
        sort(evs.begin(), evs.end());
        
        int ans = 0, bestFirst = 0;
        for (const auto& [ts, op, val]: evs) {
            if (op == 0) {
                ans = max(ans, val + bestFirst);
            }
            else {
                bestFirst = max(bestFirst, val);
            }
        }
        return ans;
    }
};
```



# 数学

## 序列中不同最大公约数的数目（LC 1819）

**题目：[1819. 序列中不同最大公约数的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-different-subsequences-gcds/)**

```c++
class Solution {
public:
    typedef long long ll ;
    ll gcd(ll a,ll b) {
        return b==0 ? a : gcd(b,a%b) ;
    }
    const int N = 2e5 + 1 ; int ans = 0 ;
    int countDifferentSubsequenceGCDs(vector<int>& nums) {
        unordered_set<int> set(nums.begin(),nums.end()) ;
        for(int i=1;i<N;++i) {
            int g = 0 ;
            for(int j=i;j<N;j+=i){
                if(set.count(j)) g = gcd(j,g) ;
                if(g == i) {ans ++ ; break ;}
            }
        }
        return ans ;
    }
};
```

## 只出现一次的数字|||（LC 260）

**题目：[260. 只出现一次的数字 III - 力扣（LeetCode）](https://leetcode.cn/problems/single-number-iii/)**

```c++
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        int xorsum = 0;
        for (int num: nums) {
            xorsum ^= num;
        }
        // 防止溢出
        int lsb = (xorsum == INT_MIN ? xorsum : xorsum & (-xorsum));
        int type1 = 0, type2 = 0;
        for (int num: nums) {
            if (num & lsb) {
                type1 ^= num;
            }
            else {
                type2 ^= num;
            }
        }
        return {type1, type2};
    }
};
```

## 生成乘积数组的方案数（LC 1735）

**题目：[1735. 生成乘积数组的方案数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-ways-to-make-array-with-product/)**

**知识点：乘法逆元，组合数，排列数，快速幂，质因数分解，费马小定理**

```c++
using ll = long long ;
class Solution {
public:
    static const int N = 10100 ;
    static const int P = 1e9+7 ;
    static array<int,N> A ; static bool inited ;
    ll mod(ll x){return (x + P) % P ;}
    ll quickpow(ll a,ll b,ll p){
        ll res = 1 ; a %= p ;
        while(b){
            if(b&1) res = (res * a) % p ;
            a = (a * a) % p ;
            b >>= 1 ;
        }
        return res ;
    }
public:
    int C(int n,int m){
        return mod(1LL * A[n] * quickpow(1LL * A[m] * A[n - m] , P - 2 , P)) ;
    }
    void decompose(unordered_map<int,int>& dec , int k){
        for(int i=2;i<=sqrt(k);++i){
            while(k % i == 0) k /= i , dec[i] ++ ;
        }
        if(k > 1) dec[k] ++ ;
    }
    void init(){
        if(inited) return ;
        A[0] = 1 ;
        for(int i=1;i<N;++i) A[i] = mod(1LL * A[i-1] * i) ;
        inited = true ;
    }
    vector<int> waysToFillArray(vector<vector<int>>& queries) {
        vector<int> ans(queries.size(),1) ; init() ;
        for (int i = 0; i < queries.size() ; ++i){
            auto n = queries[i][0] , k = queries[i][1] ;
            unordered_map<int,int> dec ; decompose(dec,k) ;
            for(auto& [u,v] : dec){
                ans[i] = mod(1LL * ans[i] * C(v+n-1,n-1)) ;
            }
        }
        return ans ;
    }
};
bool Solution::inited = false ;
array<int,Solution::N> Solution::A = {0} ; 
```

## 统计同位异构字符串的数目

**题目：[2514. 统计同位异构字符串数目 - 力扣（LeetCode）](https://leetcode.cn/problems/count-anagrams/)**

```c++
using ll = long long ;
class Solution {
private:
    static const int P = 1e9+7 ;
    static const int N = 1e5+1 ;
    ll mod(ll x){return (x%P + P)%P;}
    ll A[N] , B[N] ;  // 组合数和乘法逆元
public:
    ll quickpow(ll a,ll b,ll p){
        ll res = 1 ; a %= p ;
        while(b){
            if(b & 1) res = (res * a) % p ;
            a = (a * a) % p ;
            b >>= 1 ;
        }
        return res ;
    }
    Solution(){
        A[1] = 1 ; B[1] = 1 ;
        for(int i=2;i<N;++i) A[i] = mod(A[i-1] * i) , B[i] = quickpow(A[i] , P - 2 , P) ;
    }
    int countAnagrams(string s) {
        int i = 0 ; ll ans = 1 ; int pre = 0 ;
        while(i < s.size()){
            unordered_map<char,int> mp ;
            while(i < s.size() && s[i] != ' ') mp[s[i ++ ]] ++ ;
            ll tp = A[i - pre] ;
            for(auto e : mp){
                tp = mod(tp * B[e.second]) ;
            }
            ans = mod(ans * tp) ; i ++ ; pre = i ;
        }
        return mod(ans) ;
    }
};
```

## [不用加减乘除做加法](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

```c++
class Solution {
public:
    int add(int a, int b) {
        while (b != 0) {
            unsigned int carry = (unsigned int)(a & b) << 1;
            a = a ^ b;
            b = carry;
        }
        return a;
    }
};
```

## [检查「好数组」](https://leetcode.cn/problems/check-if-it-is-a-good-array/)

```C++
using ll = long long ;
class Solution {
public:
    ll gcd(ll a , ll b){return b == 0? a : gcd(b , a % b) ;}
    bool isGoodArray(vector<int>& nums) 
    {
        ll tp = nums[0] ;
        for(int i = 1 ; i < nums.size() ; ++ i)
        {
            tp = gcd(nums[i] , tp) ;
            if(tp == 1) return true ;
        }
        return tp == 1 ;
    }
};
```



# 字符串

## 字母异位词分组（LC 49）

**题目：[49. 字母异位词分组 - 力扣（LeetCode）](https://leetcode.cn/problems/group-anagrams/)**

```c++
class Solution {
public:
    long long prime[26] = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101};  // 每个质数对应一个字母，质数相乘不会重复
    const int P = 1e9+7;
    long long Hash(string& s){
        long long ans = 1 ;
        for(auto e:s) ans =(ans * prime[e-'a']) % P;
        return ans%P;
    }
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> ans ;
        unordered_map<int,vector<string>> m;
        for(auto& s : strs) m[Hash(s)].push_back(s);
        for(auto& e : m) ans.push_back(e.second);
        return ans;
    }
};
```

## 字符串相加（LC 415）

**题目：[415. 字符串相加 - 力扣（LeetCode）](https://leetcode.cn/problems/add-strings/)**

```c++
class Solution {
public:
    string addStrings(string num1, string num2) {
        string ans;
        int cnt = 0;
        int i = num1.size()-1 , j = num2.size()-1;
        while(i>=0 && j>=0){
            int a = num1[i] - '0' , b = num2[j] - '0' ;
            int sum = a + b + cnt ;
            cnt = sum / 10 ;
            ans += sum%10 + '0' ;
            i -- ; j -- ;
        }
        while(i>=0){
            int a = num1[i] - '0' + cnt;
            cnt = a / 10 ;
            ans += a%10 + '0' ;
            i -- ;
        }
        while(j>=0){
            int a = num2[j] - '0' + cnt;
            cnt = a / 10 ;
            ans += a%10 + '0' ;
            j -- ;
        }
        if(cnt) ans += cnt + '0' ;
        reverse(ans.begin(),ans.end());
        return ans;
    }
};
```

## 字符串相乘（LC 43）

**题目：[43. 字符串相乘 - 力扣（LeetCode）](https://leetcode.cn/problems/multiply-strings/)**

```c++
class Solution {
public:
    string add(string num1,string num2){
        string ans;
        int cnt = 0;
        int i = num1.size()-1 , j = num2.size()-1;
        while(i>=0 && j>=0){
            int a = num1[i] - '0' , b = num2[j] - '0' ;
            int sum = a + b + cnt ;
            cnt = sum / 10 ;
            ans += sum%10 + '0' ;
            i -- ; j -- ;
        }
        while(i>=0){
            int a = num1[i] - '0' + cnt;
            cnt = a / 10 ;
            ans += a%10 + '0' ;
            i -- ;
        }
        while(j>=0){
            int a = num2[j] - '0' + cnt;
            cnt = a / 10 ;
            ans += a%10 + '0' ;
            j -- ;
        }
        if(cnt) ans += cnt + '0' ;
        reverse(ans.begin(),ans.end());
        return ans;
    }
    string onemultiply(int a,string num){
        string ans;
        int i = num.size()-1;
        int cnt = 0 ;
        while(i >= 0){
            int sum = a * (num[i]-'0') + cnt ;
            cnt = sum / 10 ;
            ans += sum%10 + '0';
            i--;
        }
        if(cnt) ans += cnt + '0';
        reverse(ans.begin(),ans.end());
        return ans;
    }
    string multiply(string num1, string num2) {
        if(num1=="0"||num2=="0") return "0";
        string ans="0"; int n = num1.size() ; string cnt="";
        for(int i=n-1;i>=0;--i){
            ans = add(ans,onemultiply(num1[i]-'0',num2+cnt));
            cnt += "0";
        }
        return ans;
    }
};
```

## 检查句子中的数字是否递增（LC 2042）

**题目：[2042. 检查句子中的数字是否递增 - 力扣（LeetCode）](https://leetcode.cn/problems/check-if-numbers-are-ascending-in-a-sentence/)**

```c++
class Solution {
public:
    bool areNumbersAscending(string s) {
        stringstream ss(s); int cur = 0 ;
        while(ss >> s) {
            try{
                int x = stoi(s) ;
                if(x <= cur) return false ;
                cur = x ; 
            }catch(...){}
        }
        return true ;
    }
};
```

## 最长公共前缀（LC 14）

**题目：[14. 最长公共前缀 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-prefix/)**

```c++
class Solution {
public:
    int LCA(string& s1,string& s2){
        int p = 0 ;
        while(p < s1.size() && p < s2.size() && s1[p]==s2[p]) p ++ ;
        return p ;
    }
    string longestCommonPrefix(vector<string>& strs) {
        // 先排序，取首尾字符串求LCA
        string ans = "" ; sort(strs.begin(),strs.end()) ;
        return strs[0].substr(0,LCA(strs[0],strs[strs.size()-1])) ;
    }
};
```

## 替换字符串的中括号内容（LC 1807）

**题目：[1807. 替换字符串中的括号内容 - 力扣（LeetCode）](https://leetcode.cn/problems/evaluate-the-bracket-pairs-of-a-string/)**

```c++
class Solution {
public:
    string evaluate(string s, vector<vector<string>>& knowledge) {
        unordered_map<string,string> m ; 
        for(int i=0;i<knowledge.size();++i)
            m[knowledge[i][0]] = knowledge[i][1] ;
        for(int i=0;i<s.size();++i){
            if(s[i] == '(') {
                int p = i + 1 ; 
                while(s[p] != ')') p ++ ;
                if(m.count(s.substr(i+1,p-i-1))) s.replace(i,p-i+1,m[s.substr(i+1,p-i-1)]) ;
                else s.replace(i,p-i+1,"?") ; 
            }
        }
        return s ;
    }
};
```

## 句子的相似性|||（LC 1813）

**题目：[1813. 句子相似性 III - 力扣（LeetCode）](https://leetcode.cn/problems/sentence-similarity-iii/)**

```c++
class Solution {
public:
    bool areSentencesSimilar(string sentence1, string sentence2) {
        vector<string> v1,v2 ;
        for(int i=0;i<sentence1.size();++i){
            int j = i + 1 ;
            while(j<sentence1.size()&&sentence1[j]!=' ') j++ ;
            v1.push_back(sentence1.substr(i,j-i));
            i=j;
        }
        for(int i=0;i<sentence2.size();++i){
            int j = i + 1 ;
            while(j<sentence2.size()&&sentence2[j]!=' ') j++ ;
            v2.push_back(sentence2.substr(i,j-i));
            i=j;
        }

        if(v1.size()>v2.size()) swap(v1,v2);

        int j=0,tag=0;
        for(int i=0;i<v1.size();++i){
            if(tag==0){
                if(v1[i]!=v2[j]) {tag=1;j=v2.size()-(v1.size()-i);}  // 找到第一个不相同的单词，跳转到下一匹配阶段
                else j++ ;
            }
            if(tag==1){
                if(v1[i]!=v2[j]) return false ;
                else j++ ;
            }
        }
        return true;
    }
};
```

## [得分最高的单词集合](https://leetcode.cn/problems/maximum-score-words-formed-by-letters/)

```c++
class Solution {
public:
    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {
        array<int,26> cnt{} ; 
        for(auto c : letters) cnt[c - 'a'] ++ ;
        vector<array<int,26>> wdcnt(words.size()) ;
        for(int i=0;i<words.size();++i) for(auto c : words[i]) wdcnt[i][c - 'a'] ++ ;
        int ans = 0 ; int t = 0 ;
        function<void(int)> dfs = [&](int s){
            bool ok = false ;
            for(int i=s;i<words.size();++i){
                for(int j=0;j<26;++j) {
                    if(cnt[j] - wdcnt[i][j] < 0) ok = true ;
                    cnt[j] -= wdcnt[i][j] ; t += wdcnt[i][j] * score[j] ;
                }
                if(!ok) ans = max(ans , t) , dfs(i + 1) ; ok = false ;
                for(int j=0;j<26;++j) cnt[j] += wdcnt[i][j] , t -= wdcnt[i][j] * score[j] ;
            }
        } ;
        dfs(0) ;
        return ans ;
    }
};
```



# 数组

## 旋转图像（LC 48）

**题目：[48. 旋转图像 - 力扣（LeetCode）](https://leetcode.cn/problems/rotate-image/)**

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        // 先转置 再翻转
        int n = matrix.size();
        for(int i=0;i<n;++i) for(int j=i+1;j<n;++j){
            swap(matrix[i][j],matrix[j][i]);
        }
        int m = n%2? n/2+1:n/2;
        for(int i=0;i<n;++i) for(int j=0;j<m;++j){
            swap(matrix[i][j],matrix[i][n-1-j]);
        }
    }
};
```

 

# 双指针

## 删除链表的倒数第N个节点（LC 19）

**题目：[19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(head->next == NULL){
            delete head;
            return NULL;
        }
        auto p1=head,p2=head;
        for(int i=0;i<n;i++){
            p2 = p2->next;
        }
        for(p1=head;p2!=NULL&&(p2->next)!=NULL;p2=p2->next){
            p1 = p1->next;
        }
        if((p1 == head) && (p2 ==head->next)){delete head->next;head->next=NULL;return head;}
        if(p1 == head && p2==NULL) return head->next;
        auto temp = p1->next->next;
        delete p1->next;
        p1->next = temp;
        return head;
    }
};
```

## （hard）接雨水（LC 42）

**题目：[42. 接雨水 - 力扣（LeetCode）](https://leetcode.cn/problems/trapping-rain-water/)**

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        // 解法四 按列栈模拟 

    }
    // 解法一 按行求
        /* auto height_max = *max_element(height.begin(),height.end());
        int rainSum=0;
        stack<int> st;  // 存放height的下标
        for(int i=1;i<=height_max;i++){
            for(int j=0;j<height.size();j++){
                if(st.empty() && height[j]>=i) st.push(j);
                else if(!st.empty() && height[j]>=i){
                    rainSum += j-st.top()-1;
                    st.pop();
                    st.push(j);
                }
            }
            while(!st.empty()) st.pop();
        }
        return rainSum; */

    // 解法二 按列求
        /* int rainSum=0;
        for(int i=1;i<height.size()-1;i++){
            int leftMax=0;  // 左边的最大高度的下标
            int rightMax=height.size()-1;  // 右边的最大高度的下标
            for(int j=0;j<i;j++){
                if(height[j]>height[leftMax]) leftMax=j;
            }
            for(int j=height.size()-1;j>i;j--){
                if(height[j]>height[rightMax]) rightMax=j;
            }
            int minHeight = min(height[leftMax],height[rightMax]);
            if(minHeight>height[i]) rainSum += minHeight-height[i]; 
        }
        return rainSum; */

    // 解法三 动态规划
        /* int n = height.size();
        int *dpLeftMax = new int[n];  // 第i个下标左边的最大高度
        int *dpRightMax = new int[n];  // 第i个下标右边的最大高度
        // 初始化
        dpLeftMax[0] = height[0];
        dpRightMax[n-1] = height[n-1];
        // 填表
        for(int i=1;i<n;i++)
            dpLeftMax[i] = max(dpLeftMax[i-1],height[i]);
        for(int i=n-2;i>=0;i--)
            dpRightMax[i] = max(dpRightMax[i+1],height[i]);
        // 计算雨水量
        int rainSum=0;
        for(int i=1;i<n-1;i++){
            int minHeight = min(dpLeftMax[i],dpRightMax[i]);
            if(minHeight>height[i]) rainSum += minHeight-height[i];
        }
        return rainSum; */
};
```

## 旋转链表（LC 61）

**题目：[61. 旋转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/rotate-list/)**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        int len=0;
        for(ListNode* it=head;it!=NULL;it=it->next)
            len++;
        if(len==0) return NULL;  // 空链表返回
        k = k%len;  // 求模防止重复计算
        if(k==0 || len==1) return head;  // 边界条件控制
        auto pre = head;
        for(int i=0;i<(len-k-1);i++) pre = pre->next;  // 移动到“头节点”的前一个节点
        auto temp_head = pre->next;  // 保存头节点
        pre->next = NULL;  // 链表改变后的尾部置空
        for(pre=temp_head;pre->next!=NULL;pre=pre->next){}  // 移动节点到尾部
        pre->next = head;
        return temp_head;
    }
};
```

## 删除排序链表中的重复元素||（LC 82）

**题目：[82. 删除排序链表中的重复元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)**

```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head==NULL) return NULL;
        if(head->next==NULL) return head;
        ListNode* H = new ListNode(-1);  // 创建头节点
        auto pre = H;
        pre->next = head;
        for(auto curr=head;curr!=NULL;curr=curr->next){
            if(curr->next && curr->next->val==curr->val){
                do{
                    curr = curr->next;
                }while(curr->next && curr->next->val==curr->val);
                pre->next = curr->next;
            }
            else pre = pre->next;
        }
        return H->next;
    }
};
```

## 合并两个有序数组（LC 88）

**题目：[88. 合并两个有序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-sorted-array/)**

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        for(int i=m-1;i>=0;i--){
            nums1[i+n] = nums1[i];
        }
        int p1=n;
        int p2=0;int k=0;
        while(p1<=m-1+n&&p2<=n-1){
            if(nums1[p1] < nums2[p2]){
                nums1[k++] = nums1[p1++];
            }
            else{
                nums1[k++] = nums2[p2++];
            }
        }
        while(p1<=m-1+n){
            nums1[k++] = nums1[p1++];
        }
        while(p2<=n-1){
            nums1[k++] = nums2[p2++];
        }
        
    }
};
```

## 环形链表（LC 141）

**题目：[141. 环形链表 - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle/)**

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        auto slow=head;
        auto fast=head;
        while(!(slow==NULL || fast==NULL || fast->next==NULL)){   // 无环退出
            slow = slow->next;
            fast = fast->next->next;
            if(slow==fast) break;  // 有环退出
        }
        if(slow==NULL || fast==NULL || fast->next==NULL) return false;  // 无环
        return true;  // 有环
    }
};
```

## 两数之和||-输入有序数组（LC 167）

**题目：[167. 两数之和 II - 输入有序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)**

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        vector<int> ans;
        int n = numbers.size();
        int i=0,j=n-1;
        while(i<=j){
            if((numbers[i]+numbers[j])==target){
                ans.push_back(i+1);
                ans.push_back(j+1);
                return ans;
            }
            if((numbers[i]+numbers[j]) > target){
                j--;
            }
            if((numbers[i]+numbers[j])<target){
                i++;
            }

        }
        return ans;
    }
};
```

## 轮转数组（LC 189）

**题目：[189. 轮转数组 - 力扣（LeetCode）](https://leetcode.cn/problems/rotate-array/)**

```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        reverse(nums.begin(),nums.end());
        int n = nums.size();
        k = k % n;
        reverse(nums.begin(),nums.begin()+k);
        reverse(nums.begin()+k,nums.end());
    }
};
```

## 快乐数（LC 202）

**题目：[202. 快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/)**

```c++
class Solution {
public:
    int getSum(int n) {
        int sum = 0;
        while (n) {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        unordered_set<int> set;
        set.insert(n);
        while(n != 1){
            n = getSum(n);
            //cout<<n<<" ";
            if(set.find(n)==end(set)) set.insert(n);
            else return false;
        }
        return true;
    }
};
```

## 移动零（LC 283）

**题目：[283. 移动零 - 力扣（LeetCode）](https://leetcode.cn/problems/move-zeroes/)**

```c++
class Solution {
public:
    void swap(vector<int> &v,int i,int j){
        int temp = v[i];
        v[i] = v[j];
        v[j] = temp;
    }
    void moveZeroes(vector<int>& nums) {
        int p1=-1,p2=0;
        int n=nums.size();
        if(nums.empty()) return;
        while(p2<n){
            if(nums[p2]!=0){
                swap(nums,++p1,p2++);
            }
            else{
                p2++;
            }
        }
    }
};
```

## 反转字符串（LC 344）

**题目：[344. 反转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string/)**

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int n=s.size();
        int left = 0,right = n-1;
        while(left<right) swap(s[left++],s[right--]);
    }
};
```

## 两个数组的交集（LC 349）

**题目：[349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/)**

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set(begin(nums1),end(nums1));
        unordered_set<int> res;
        for_each(begin(nums2),end(nums2),[&](auto elem){
            if(set.find(elem)!=end(set)) res.insert(elem);
        });
        return vector<int>(begin(res),end(res));
    }
};
```

## 两个数组的交集||（LC 350）

**题目：[350. 两个数组的交集 II - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)**

```c++
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        sort(nums1.begin(),nums1.end());
        sort(nums2.begin(),nums2.end());
        vector<int> v;
        int i=0,j=0;
        while(i<nums1.size()&&j<nums2.size()){
            if(nums1[i] == nums2[j]){
                v.push_back(nums1[i]);
                i++;j++;continue;
            }
            if(nums1[i] > nums2[j]){j++;continue;}
            if(nums1[i] < nums2[j]){i++;continue;}
        }

        return v;
    }
};
```

## 分发饼干（LC 455）

**题目：[455. 分发饼干 - 力扣（LeetCode）](https://leetcode.cn/problems/assign-cookies/)**

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int p1=0,p2=0;
        int res=0;
        while(p1!=g.size() && p2!=s.size()){
            if(s[p2]>=g[p1]) res++,p2++,p1++;
            else p2++;
        }
        return res;
    }
};
```

## 神奇字符串（LC 481）

**题目：[481. 神奇字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/magical-string/)**

```c++
class Solution {
public:
    int magicalString(int n) {
        if (n < 4) {
            return 1;
        }
        string s(n, '0');
        s[0] = '1', s[1] = '2', s[2] = '2';
        int res = 1;
        int i = 2;
        int j = 3;
        while (j < n) {
            int size = s[i] - '0';
            int num = 3 - (s[j - 1] - '0');
            while (size > 0 && j < n) {
                s[j] = '0' + num;
                if (num == 1) {
                    ++res;
                }
                ++j;
                --size;
            }
            ++i;
        }
        return res;
    }
};
```

## 反转字符串中的单词|||（LC 557）

**题目：[557. 反转字符串中的单词 III - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-words-in-a-string-iii/)**

```c++
class Solution {
public:
    string reverseWords(string s) {
        int n=s.size();
        int left = 0,right = n-1;
        for(int i=0;i<n;i++){
            if(s[i] == ' '){
                right = i-1;
                while(left<right) swap(s[left++],s[right--]);
                left = i+1;
            }
            if(i==n-1){
                right = n-1;
                while(left<right) swap(s[left++],s[right--]);
            }
        }
        return s;
    }
};
```

## 字符串的排列（LC 567）

**题目：[567. 字符串的排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutation-in-string/)**

```c++
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        int n1 = s1.size();
        int n2 = s2.size();
        queue<char> que;
        int left=0;
        bool tag=false;
        for(int right=0;right<n2;){
            auto it = s1.find(s2[right]);
            while(it != string::npos){
                que.push(s1[it]);
                s1.erase(it,1);
                right++;tag=true;
                if(right>n2-1) break;
                it = s1.find(s2[right]); 
            }   
            if(s1.empty()) return true;
            if(right==left) tag = false;
            if(tag==true){ 
                left++;
                s1+=que.front();
                que.pop();   
                continue;
            } 
            left++;right++;
        }
        return false;
    }
};
```

## 两数之和IV-输入二叉搜索树（LC 653）

**题目：[653. 两数之和 IV - 输入二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/)**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> arr;
    void DFS(TreeNode* root){
        if(root==NULL) return;
        DFS(root->left);
        arr.push_back(root->val);
        DFS(root->right);
    }
    bool findTarget(TreeNode* root, int k) {
        bool tag=false;
        DFS(root);
        if(arr.size()==0) return false;
        int i=0,j=arr.size()-1;
        while(i<j){
            int sum=arr[i]+arr[j];
            cout<<sum<<endl;
            if(sum == k) return true;
            if(sum>k) j--;
            if(sum<k) i++;
        }
        return false;
    }
};
```

## 划分母区间（LC 763）

**题目：[763. 划分字母区间 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-labels/)**

```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        auto res = vector<int>();  
        int idxMax=0;  // 当前划分区间的最大值下标
        for(int i=0;i<s.size();++i){
            idxMax = max(idxMax,(int)s.rfind(s[i]));
            if(idxMax==i) {
                res.push_back(i);  // 该区间最后一个的下标
                idxMax = i+1;
            }
        } 
        // 转换成为答案
        for(int i=res.size()-1;i>0;--i) res[i] -= res[i-1];
        res[0] += 1;
        
        return res;
    }
};
```

## 优势洗牌（LC 870）

**题目：[870. 优势洗牌 - 力扣（LeetCode）](https://leetcode.cn/problems/advantage-shuffle/)**

```c++
class Solution {
public:
    
    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        int id[n];  // 储存下标
        vector<int> ans(n);
        iota(id,id+n,0);  // 赋值
        sort(id,id+n,[&nums2](int i,int j){
            return nums2[i]<nums2[j];  // 将id排序
        });
        sort(nums1.begin(),nums1.end());
        
        int left = 0,right = n-1;
        for(int e:nums1){
            ans[e>nums2[id[left]]?id[left++]:id[right--]] = e;
        }
        return ans;
    }
    // vector<int> advantageCount(vector<int> &nums1, vector<int> &nums2) {
    //     int n = nums1.size(), ids[n];
    //     vector<int> ans(n);
    //     sort(nums1.begin(), nums1.end());
    //     iota(ids, ids + n, 0);
    //     sort(ids, ids + n, [&](int i, int j) { return nums2[i] < nums2[j]; });
    //     int left = 0, right = n - 1;
    //     for (int x : nums1)
    //         ans[x > nums2[ids[left]] ? ids[left++] : ids[right--]] = x;
    //     return ans;
    // }

};
```

## 链表的中间节点（LC 876）

**题目：[876. 链表的中间结点 - 力扣（LeetCode）](https://leetcode.cn/problems/middle-of-the-linked-list/)**

```c++
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        auto begin=head;
        auto end=head;
        while(!(end == NULL || end->next == NULL)){
            begin = begin->next;
            end = end->next->next;
        }
        
        return begin;
    }
};
```

## 有序数组的平方（LC 977）

**题目：[977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/)**

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n=nums.size();
        int  p1 = 0;
        int p2 = n-1;
        vector<int> v(n);
        int k=n-1;
        while(p2>=p1){
            if(abs(nums[p1])>abs(nums[p2])){
                v[k--] = nums[p1]*nums[p1];
                p1++;
            }
            else{
                v[k--] = nums[p2]*nums[p2];
                p2--; 
            }
        }
        return v;
    }
};
```

## 检查整数及其两倍数是否存在（LC 1346）

**题目：[1346. 检查整数及其两倍数是否存在 - 力扣（LeetCode）](https://leetcode.cn/problems/check-if-n-and-its-double-exist/)**

```c++
class Solution {
public:
    
    bool checkIfExist(vector<int>& arr) {
        sort(arr.begin(),arr.end());
        if(count(arr.begin(),arr.end(),0)>=2) return true;
        for(auto e:arr){
            int left=-1;
            int right=arr.size();
            int temp=e*2;
            if(temp==0) continue;
            while(left+1 != right){
                int mid=(left+right)>>1;
                if(arr[mid]==temp) return true;
                if(arr[mid]>temp) right=mid;
                else left=mid;
            }
        }
        return false;
    }
};
```

## 两个数组间的距离值（LC 1385）

**题目：[1385. 两个数组间的距离值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/)**

```c++
class Solution {
public:
    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {
        sort(arr2.begin(),arr2.end());
        int ans = 0;
        for(int i=0;i<arr1.size();i++){
            bool tag = true;
            int left = 0,right = arr2.size()-1;
            while(left<=right){
                int mid = left + (right-left)/2;
                if(abs(arr2[mid]-arr1[i])<=d) {tag = false;break;}
                else if((arr2[mid]-arr1[i])>d) right = mid-1;
                else if((arr1[i]-arr2[mid])>d) left = mid +1;
            }
            ans += tag;
        }
        return ans;
    }
};
```

## 统计同构子字符串的数量（LC 1759）

```c++
const int P = 1e9+7;
class Solution {
public:
    int a[100010];
    void init(int n){
        a[1] = 1;
        for(int i=2;i<=n;++i) a[i] = (a[i-1] + i) % P ;
    }
    int countHomogenous(string s) {
        init(s.size());
        int ans = 0;
        for(int i=0;i<s.size();++i){
            int j = i;
            while(j < s.size() && s[i] == s[j+1]) j++;
            ans = (ans + a[j-i+1]) % P;
            i = j;
        }
        return ans;
    }
};
```

## 删除字符串两端相同字符后的最短长度（LC 1750）

**题目：[1750. 删除字符串两端相同字符后的最短长度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/)**

```C++
class Solution {
public:
    int minimumLength(string s) {
        int l = 0 , r = s.size() - 1 ; 
        while(l <= r) {
            if(s[l]!=s[r]) break;
            // 移动左
            while(l+1<r && s[l+1]==s[r]) l++;
            // 移动右
            while(r-1>l && s[l]==s[r-1]) r--;
            if(r - l + 1 == 1) return 1 ;
            else if(r - l + 1 == 2) return 0 ;
            r -- ; l ++ ;
        } 
        return r - l + 1 ;
    }
};
```

## 盛最多水的容器（LC 11）

**题目：[11. 盛最多水的容器 - 力扣（LeetCode）](https://leetcode.cn/problems/container-with-most-water/)**

```c++
class Solution {
public:
    int maxArea(vector<int>& h) {
        int n = h.size() , ans = 0 ;
        int i = 0 , j = n - 1 ;
        while(i < j){
            int mi = min(h[i] , h[j]) ;
            ans = max( ans , (j - i) * mi ) ;
            if(h[i] == mi) i++ ;
            else j-- ;
        }
        return ans ;
    }
};
```

## 将x减到0的最小操作数（LC 1658）

**题目：[1658. 将 x 减到 0 的最小操作数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)**

```c++
class Solution {
public:
    int minOperations(vector<int>& nums, int x) {
        int n = nums.size() ; vector<int> pix(n+1) ;
        for(int i=1;i<=n;++i) pix[i] = pix[i-1] + nums[i-1] ;
        if(pix[n] == x) return n ;
        int y = pix[n] - x ;  // 转换目标，寻找中间最长子数组的和为y
        int i = 1 , j = 1 ; int ans = -1 ;
        while( j <= n && i >= 1 && i <= j) {
            int sum = pix[j] - pix[i-1] ;
            if(sum == y) ans = max(ans , j - i + 1) , j++ , i ++ ;
            else if(sum < y) j ++ ;
            else{ i ++ ; if(i > j) j ++ ;}
        }
        return ans == -1 ? -1 : n - ans ;
    }
};
```

## 三数之和（LC 15）

**题目：[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/)**

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size() ; sort(nums.begin(),nums.end()) ; 
        vector<vector<int>> ans ; int pre = INT_MAX ;
        for(int i=0;i<n-2;++i){
            if(nums[i] == pre) continue ;
            int l = i + 1 , r = n - 1 ;
            while(l < r){
                if(nums[i] + nums[l] + nums[r] == 0) {
                    ans.push_back({nums[i],nums[l],nums[r]}) ;
                    while(l+1 < r && nums[l] == nums[l+1]) l ++ ;
                    while(r-1 > l && nums[r] == nums[r-1]) r -- ;
                    l ++ , r -- ;
                } else if(nums[i] + nums[l] + nums[r] < 0) l ++ ;
                else r -- ;
            }
            pre = nums[i] ;
        }
        return ans ;
    }
};


// 回溯暴搜，超时
/* class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    vector<int> nums;
    int sum=0;
    void helper(int start){
        if(path.size()==3){
            if(sum==0)
                res.push_back(path);
            return;
        }
        for(int i=start;i<nums.size() && sum;++i){
            if(i>start && nums[i]==nums[i-1]) continue;
            sum += nums[i];
            path.push_back(nums[i]);
            helper(i+1);
            path.pop_back();
            sum -= nums[i];
        }
    }
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(begin(nums),end(nums));
        this->nums = nums;
        helper(0);
        return res;
    }
}; */
```

## 最接近的三数之和（LC 16）

**题目：[16. 最接近的三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum-closest/)**

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        int n = nums.size() ; sort(nums.begin(),nums.end()) ; 
        int ans = INT_MAX , dif = INT_MAX ;
        for(int i=0;i<n-2;++i){
            int l = i + 1 , r = n - 1 ;
            while(l < r){
                int sum = nums[i] + nums[l] + nums[r] ;
                int diff = abs(sum - target) ;
                if(diff < dif) dif = diff , ans = sum ; 
                if(sum > target) r -- ;
                else l ++ ;
            }
        }
        return ans ;
    }
};
```

## 四数之和（LC 18）

**题目：[18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/)**

```c++
class Solution {
public:
    typedef long long ll ;
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        int n = nums.size() ; sort(nums.begin(),nums.end()) ; 
        vector<vector<int>> ans ; int pre1 = INT_MAX ;
        for(int i=0;i<n-3;++i){
            if(nums[i] == pre1) continue ;
            int pre2 = INT_MAX ;
            for(int j=i+1;j<n-2;++j){
                if(nums[j] == pre2) continue ;
                int l = j + 1 , r = n - 1 ;
                while(l < r){
                    if((ll)nums[i] + (ll)nums[j] + (ll)nums[l] + (ll)nums[r] == target) {
                        ans.push_back({nums[i],nums[j],nums[l],nums[r]}) ;
                        while(l+1 < r && nums[l] == nums[l+1]) l ++ ;
                        while(r-1 > l && nums[r] == nums[r-1]) r -- ;
                        l ++ , r -- ;
                    } else if((ll)nums[i] + (ll)nums[j] + (ll)nums[l] + (ll)nums[r] < target) l ++ ;
                    else r -- ;
                }
                pre2 = nums[j] ;
            }
            pre1 = nums[i] ;
        }
        return ans ;
    }
};
```

## 统计好子数组的数目（LC 2537）

**题目;[2537. 统计好子数组的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/count-the-number-of-good-subarrays/)**

```c++
using ll = long long ;
class Solution {
public:
    long long countGood(vector<int>& nums, int k) {
    	ll ans = 0 ; ll temp = 0 ;
        int j = -1 ; unordered_map<int,int> mp ; 
        for(int i=0;i<nums.size();++i){
        	while(j+1 < (int)nums.size() && temp < k){
        		if(++ mp[nums[++j]] >= 2){
        			int x = mp[nums[j]] ;
        			temp += x * (x - 1 ) / 2 - (x - 1) * (x - 2) / 2;
        		} 
        	}
        	if(temp >= k) ans += nums.size() - j ; 
            int x = mp[nums[i]] --  ;
    		if(x >= 2) {
    			temp += (x - 1) * (x - 2) / 2 - x * (x - 1) / 2 ;
    		}
        }
        return ans ;
    }
};
```

## 等差数列的划分

**题目:[413. 等差数列划分 - 力扣（LeetCode）](https://leetcode.cn/problems/arithmetic-slices/)**

```c++
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        if(nums.size() <= 2) return 0 ;
        int ans = 0 ; int i = 0 , j = 1 ; int d = nums[j] - nums[i] ;
        while(j < nums.size()){
            while(j < nums.size() && d == nums[j] - nums[j - 1]) {
                j ++ ;
            }
            //cout << j << endl ;
            int len = j - i ;
            if(len >= 3) ans += (len - 2) * (len - 1) / 2 ;
            if(j < nums.size()) d = nums[j] - nums[j - 1] ;
            i = j - 1;
        }
        return ans ; 
    }
};
```

## [合并区间](https://leetcode.cn/problems/merge-intervals/)

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(),intervals.end(),[&](auto& e1,auto& e2){
            return e1[0] == e2[0] ? e1[1] < e2[1] : e1[0] < e2[0] ;
        }) ;
        vector<vector<int>> ans ;
        for(int i=0;i<intervals.size();++i){
            int j = i + 1 ; int r = intervals[i][1] , l = intervals[i][0] ;
            while(j < intervals.size() && intervals[j][0] <= r) {
                r = max(r , intervals[j][1]) ;
                j ++ ;
            }
            ans.push_back({intervals[i][0],r}) ;
            i = j - 1 ; 
        }
        return ans ;
    }
};
```

## 两个线段获得的最多奖品

**题目：[两个线段获得的最多奖品 - 力扣 (LeetCode) 竞赛](https://leetcode.cn/contest/biweekly-contest-97/problems/maximize-win-from-two-segments/)**

```c++
class Solution {
public:
    int maximizeWin(vector<int>& prizePositions, int k) {
        int i = 0 , j = 0 ; int n = prizePositions.size() ; 
        vector<int> pre(n + 1) ;  // 右端点为i的最多奖品
        int ans = 0 ; int tp = 0 ;
        while(i < n && j < n)
        {
            while(i < n && prizePositions[j] - prizePositions[i] > k) i ++ , tp = max(tp , pre[i]);
            while(j < n && prizePositions[j] - prizePositions[i] <= k)
            {
                pre[j + 1] = max(pre[j + 1] , j - i + 1) ;
                j ++ ;
            }
            tp = max(tp , pre[i]) ;
            ans = max(ans , tp + pre[j]) ;  // 左边最大的加上现在区间长度为k的
            i ++ ;
        }   
        return ans ;
    }
};
```



# 链表

## 删除链表的倒数第N个节点（LC 19）

**题目：[19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)**

```C++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        int len=0;
        // 计算长度
        for(auto it=head;it!=NULL;it=it->next) len++;
        if(len==0) return NULL;  // 删除空链表的情况
        if(n==len) return head->next;  // 删除头指针的情况
        auto pre = head;  // 移动到删除节点的前一个节点
        for(int i=0;i<(len-n-1);i++) pre=pre->next;
        pre->next = pre->next->next;  // 删除节点
        return head;
    }
};
```

## 合并两个有序的链表（LC 21）

**题目：[21. 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/submissions/)**

```C++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* head= new ListNode(0);  //头节点
        auto p = head;  // 保存头节点
        auto head1 = list1;
        auto head2 = list2;
        while(head1 && head2){  // 二路归并
            if(head1->val < head2->val){
                head->next = head1;
                head1 = head1->next;
                head = head->next;
            }else {
                head->next = head2;
                head2 = head2->next;
                head = head->next;
            }
        }
        while(head1){
            head->next = head1;
            head1 = head1->next;
            head = head->next;
        }
        while(head2){
            head->next = head2;
            head2 = head2->next;
            head = head->next;
        }
        return p->next;
    }
};
```



## 两两交换链表中的节点（LC 24）

**题目：[24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/)**

```C++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head == NULL || head->next == NULL) return head;
        ListNode* temp = head->next;
        head->next = swapPairs(temp->next);
        temp->next = head;
        return temp;
    }
};
```



## 旋转链表（LC 61）

**题目：[61. 旋转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/rotate-list/submissions/)**

```c++
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        int len=0;
        for(ListNode* it=head;it!=NULL;it=it->next)
            len++;
        if(len==0) return NULL;  // 空链表返回
        k = k%len;  // 求模防止重复计算
        if(k==0 || len==1) return head;  // 边界条件控制
        auto pre = head;
        for(int i=0;i<(len-k-1);i++) pre = pre->next;  // 移动到“头节点”的前一个节点
        auto temp_head = pre->next;  // 保存头节点
        pre->next = NULL;  // 链表改变后的尾部置空
        for(pre=temp_head;pre->next!=NULL;pre=pre->next){}  // 移动节点到尾部
        pre->next = head;
        return temp_head;
    }
};
```



## 删除排序链表中的重复元素 |（LC 83）

**题目：[83. 删除排序链表中的重复元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)**

```c++
class Solution {
public:
    void erase(ListNode* head){  // 删除下一个节点
        auto it = head->next->next;
        delete head->next;
        head->next = it;
    }
    ListNode* deleteDuplicates(ListNode* head) {
        auto pre = head;
        if(head == NULL) return NULL;
        for(auto it=head->next;it!=NULL;it=it->next){
            if(pre->val == it->val){
                erase(pre);
                it = pre;
            }
            pre = it;
        }
        return head;
    }
};
```



## 删除排序链表中的重复元素|| （LC 82）

**题目：[82. 删除排序链表中的重复元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)**

```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head==NULL) return NULL;
        if(head->next==NULL) return head;
        ListNode* H = new ListNode(-1);  // 创建头节点
        auto pre = H;
        pre->next = head;
        for(auto curr=head;curr!=NULL;curr=curr->next){
            if(curr->next && curr->next->val==curr->val){
                do{
                    curr = curr->next;
                }while(curr->next && curr->next->val==curr->val);
                pre->next = curr->next;
            }
            else pre = pre->next;
        }
        return H->next;
    }
};
```



## 有序链表转化为二叉搜索树（LC 109）

**题目：[109. 有序链表转换二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)**

```c++
class Solution {
public:
    int getLength(ListNode* head) {
        int ret = 0;
        for (; head != nullptr; ++ret, head = head->next);
        return ret;
    }

    TreeNode* buildTree(ListNode*& head, int left, int right) {
        if (left > right) return NULL;
        int mid = (left + right) >>1 ;
        TreeNode* root = new TreeNode;
        root->left = buildTree(head, left, mid - 1);
        root->val = head->val;
        head = head->next;
        root->right = buildTree(head, mid + 1, right);
        return root;
    }

    TreeNode* sortedListToBST(ListNode* head) {
        int length = getLength(head);
        return buildTree(head, 0, length - 1);
    }
};
```



## 二叉搜索树展开为链表（LC 114）

**题目：[114. 二叉树展开为链表 - 力扣（LeetCode）](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)**

```c++
class Solution {
public:
    vector<int> v;
    void DFS(TreeNode* root){
        if(root == NULL) return;
        v.push_back(root->val);
        DFS(root->left);
        DFS(root->right);
    }
    void clear(TreeNode* &root){
        if(root == NULL) return;
        clear(root->left);
        clear(root->right);
        delete root;
        root = NULL;
    }
    void flatten(TreeNode* root) {
        if(root==NULL) return;
        DFS(root);
        if(root->left) clear(root->left);
        if(root->right) clear(root->right);
        root->val = v[0];
        for(int i=1;i<v.size();i++){
            root->right = new TreeNode(v[i]);
            root = root->right;
        }   
    }
};
```



## 环形链表（LC 141）

**题目：[141. 环形链表 - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle/)**

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        auto slow=head;
        auto fast=head;
        while(!(slow==NULL || fast==NULL || fast->next==NULL)){   // 无环退出
            slow = slow->next;
            fast = fast->next->next;
            if(slow==fast) break;  // 有环退出
        }
        if(slow==NULL || fast==NULL || fast->next==NULL) return false;  // 无环
        return true;  // 有环
    }
};
```



## 移除链表元素（LC 203）

**题目：[203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)**

```c++
class Solution {
public:
    void erase(ListNode* head){
        auto temp=head->next->next;
        delete head->next;
        head->next = temp;
    }
    ListNode* removeElements(ListNode* head, int val) {
        auto pre = head;
        if(head == NULL) return NULL;
        
        for(auto it=head->next;it!=NULL;it=it->next){
            if(it->val == val){
                erase(pre);
                it=pre;
            }
            pre = it;
        }
        if(head->val == val){
            auto it = head->next;
            delete head;
            head = it;
        }
        return head;
    }
};
```



## 反转链表（LC 206）

**题目：[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/)**

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = NULL;
        ListNode* curr = head;
        while (curr) {
            ListNode* next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
};
```



## 链表组件（LC 817）

**题目：[817. 链表组件 - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-components/)**

```c++
class Solution {
public:
    int numComponents(ListNode* head, vector<int>& nums) {
        unordered_set<int> numsSet;
        for (int num : nums) {
            numsSet.emplace(num);
        }
        bool inSet = false;
        int res = 0;
        while (head != nullptr) {
            if (numsSet.count(head->val)) {
                if (!inSet) {   // 不是在这个组件之中
                    inSet = true;
                    res++;
                }
            } else {  
                inSet = false;
            }
            head = head->next;
        }
        return res;
    }
};
```



## 链表的中间节点（LC 876）

**题目：[876. 链表的中间结点 - 力扣（LeetCode）](https://leetcode.cn/problems/middle-of-the-linked-list/)**

```c++
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        auto begin=head;
        auto end=head;
        while(!(end == NULL || end->next == NULL)){
            begin = begin->next;
            end = end->next->next;
        }  
        return begin;
    }
};
```

## K个一组翻转链表（LC 25）

**题目：[25. K 个一组翻转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-nodes-in-k-group/)**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    void rev(ListNode* p,ListNode* q){
        stack<ListNode*> st ;
        for(auto it=p;it!=q->next;it=it->next) st.push(it) ;
        while(st.size()) {
            auto it = st.top() ; st.pop() ;
            if(st.size()) it->next = st.top() ;
        }
    }
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* H = new ListNode(-1) ; H->next = head ;  // 头节点
        ListNode* pre = H ;  // 前指针
        for(auto it=head;it!=nullptr;){
            auto p = it ;  // 起点
            for(int i=1;i<k && it;++i) it = it->next ;
            if(!it) continue ;
            auto q = it ;  it = it->next ;// 终点 
            rev(p,q) ;
            pre->next = q ; p->next = it ; pre = p ;
        }
        return H->next ;
    }
};
```



# 栈

## （hard）接雨水（LC 42）

**题目：[42. 接雨水 - 力扣（LeetCode）](https://leetcode.cn/problems/trapping-rain-water/)**

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        // 解法四 按列栈模拟 

    }
    // 解法一 按行求
        /* auto height_max = *max_element(height.begin(),height.end());
        int rainSum=0;
        stack<int> st;  // 存放height的下标
        for(int i=1;i<=height_max;i++){
            for(int j=0;j<height.size();j++){
                if(st.empty() && height[j]>=i) st.push(j);
                else if(!st.empty() && height[j]>=i){
                    rainSum += j-st.top()-1;
                    st.pop();
                    st.push(j);
                }
            }
            while(!st.empty()) st.pop();
        }
        return rainSum; */

    // 解法二 按列求
        /* int rainSum=0;
        for(int i=1;i<height.size()-1;i++){
            int leftMax=0;  // 左边的最大高度的下标
            int rightMax=height.size()-1;  // 右边的最大高度的下标
            for(int j=0;j<i;j++){
                if(height[j]>height[leftMax]) leftMax=j;
            }
            for(int j=height.size()-1;j>i;j--){
                if(height[j]>height[rightMax]) rightMax=j;
            }
            int minHeight = min(height[leftMax],height[rightMax]);
            if(minHeight>height[i]) rainSum += minHeight-height[i]; 
        }
        return rainSum; */

    // 解法三 动态规划
        /* int n = height.size();
        int *dpLeftMax = new int[n];  // 第i个下标左边的最大高度
        int *dpRightMax = new int[n];  // 第i个下标右边的最大高度
        // 初始化
        dpLeftMax[0] = height[0];
        dpRightMax[n-1] = height[n-1];
        // 填表
        for(int i=1;i<n;i++)
            dpLeftMax[i] = max(dpLeftMax[i-1],height[i]);
        for(int i=n-2;i>=0;i--)
            dpRightMax[i] = max(dpRightMax[i+1],height[i]);
        // 计算雨水量
        int rainSum=0;
        for(int i=1;i<n-1;i++){
            int minHeight = min(dpLeftMax[i],dpRightMax[i]);
            if(minHeight>height[i]) rainSum += minHeight-height[i];
        }
        return rainSum; */
};
```



## 有效的括号（LC 20）

**题目：[20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/)**

```c++
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        for(auto e: s){
            if(e == '(' || e == '[' || e == '{'){st.push(e);}
            else if(e==')' && !st.empty() && st.top()=='(') st.pop();
            else if(e==']' && !st.empty() && st.top()=='[') st.pop();
            else if(e=='}' && !st.empty() && st.top()=='{') st.pop();
            else return false;
        }
        if(st.empty()) return true;
        return false;
    }
};
```



## 使括号有效的最少添加（LC 921）

**题目：[921. 使括号有效的最少添加 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/)**

```c++
class Solution {
public:
    int minAddToMakeValid(string s) {
        int a =0;
        stack<char> st;
        for(int i=0;i<s.size();i++){
            if(s[i] == '(') st.push(s[i]);
            if(s[i] == ')') {
                if(st.empty()){
                    a++;
                }
                else{
                    st.pop();
                }
            }
        }
        a += st.size();
        return a;
    }
};
```



## 最多能完成排序的块（LC 769）

**题目：[769. 最多能完成排序的块 - 力扣（LeetCode）](https://leetcode.cn/problems/max-chunks-to-make-sorted/)**

```c++
class Solution {
public:
    int maxChunksToSorted(vector<int>& arr) {
        int n = arr.size();
        stack<int> st;
        int cnt=0;
        for(int i=0;i<n;i++){
            if(st.empty()){st.push(arr[i]);}
            if(st.top()<arr[i]){
                st.pop();st.push(arr[i]);
            }
            if(st.top()<=i){
                cnt++;st.pop();
            }
            
        }
        if(!st.empty()) cnt++;
        return cnt;
    }
};
```



## 括号的分数（LC 856）

**题目：[856. 括号的分数 - 力扣（LeetCode）](https://leetcode.cn/problems/score-of-parentheses/)**

```c++
class Solution {
public:
    int sum=0;
    int scoreOfParentheses(string s) {
        stack<int> st;
        st.push(0);
        for(auto e : s){
            if(e == '('){
                st.push(0);
            }
            else{
                int top = st.top();st.pop();
                int top1 = st.top();st.pop();
                st.push(top1+((top*2)>1?(top*2):1));
            }
        }
        return st.top();
    }
};
```



## 无法吃午饭的学生数量（LC 1700）

**题目：[1700. 无法吃午餐的学生数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/)**

```c++
class Solution {
public:
    int countStudents(vector<int>& students, vector<int>& sandwiches) {
        int s1 = accumulate(students.begin(), students.end(), 0);
        int s0 = students.size() - s1;
        for (int i = 0; i < sandwiches.size(); i++) {
            if (sandwiches[i] == 0 && s0 > 0) {
                s0--;
            } else if (sandwiches[i] == 1 && s1 > 0) {
                s1--;
            } else {
                break;
            }
        }
        return s0 + s1;
    }
};
```

## [移除无效的括号](https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/)

```c++
class Solution {
public:
    string minRemoveToMakeValid(string s) {
        stack<int> st ; unordered_map<int,int> vis ;
        for(int i = 0 ; i < s.size() ; ++ i){
            char c = s[i] ;
            if(c == '(') st.push(i) ;
            if(c == ')') {
                if(st.size()) st.pop() ;
                else vis[i] = 1 ;
            }
        }
        while(st.size()) vis[st.top()] = 1 , st.pop() ;
        string ans ;
        for(int i = 0 ; i < s.size() ; ++ i){
            if(vis[i]) continue ;
            ans += s[i] ;
        }
        return ans ;
    }
};
```

## [字符串解码](https://leetcode.cn/problems/decode-string/)

```c++
class Solution {
public:
    string decodeString(string s) {
        stack<int> num ; stack<int> ch ; stack<string> st ; 
        int n = s.size() ; string ans ; 

        function<string(int&)> dfs = [&](int& i){
            string res ;
            while(i < n){
                if(s[i] >= 'a' && s[i] <= 'z') res += s[i ++ ] ;
                else if(s[i] >= '0' && s[i] <= '9') {
                    int num = 0 ;
                    while(i < n && s[i] >= '0' && s[i] <= '9') {
                        num = num * 10 + s[i] - '0' ; i ++ ;
                    }
                    string tp = dfs(++ i) ;
                    while(num -- ) res += tp ;
                    i ++ ;
                }else if(s[i] == ']'){
                    return res ;
                }
            }
            return res ;
        } ; 
        int i = 0 ;
        return dfs(i) ;
    }
};
```

## [后缀表达式](https://leetcode.cn/problems/8Zf90G/)

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> num ; int res = 0 ; 
        for(int i=0;i<tokens.size();++i){
            if(tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/"){
                if(tokens[i] == "+"){
                    int b = num.top() ; num.pop() ;
                    int a = num.top() ; num.pop() ;
                    num.push(a + b) ;
                }else if(tokens[i] == "-"){
                    int b = num.top() ; num.pop() ;
                    int a = num.top() ; num.pop() ;
                    num.push(a - b) ;
                }else if(tokens[i] == "*"){
                    int b = num.top() ; num.pop() ;
                    int a = num.top() ; num.pop() ;
                    num.push(a * b) ;
                }else if(tokens[i] == "/"){
                    int b = num.top() ; num.pop() ;
                    int a = num.top() ; num.pop() ;
                    num.push(a / b) ;
                }
            }else{
                num.push(stoi(tokens[i])) ;
            }
        }
        return num.top() ;
    }
};
```



# 队列

## 字符串中的第一个唯一字符（LC 387）

**题目：[387. 字符串中的第一个唯一字符 - 力扣（LeetCode）](https://leetcode.cn/problems/first-unique-character-in-a-string/)**

```c++
class Solution {
public:
    int firstUniqChar(string s) {
        unordered_map<char, int> frequency;
        for (char ch: s) {
            ++frequency[ch];
        }
        for (int i = 0; i < s.size(); ++i) {
            if (frequency[s[i]] == 1) {
                return i;
            }
        }
        return -1;
    }
};
```



## 环形子数组的最大和（LC 918）

**题目：[918. 环形子数组的最大和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-sum-circular-subarray/)**

```c++
class Solution {
public:
    int maxSubarraySumCircular(vector<int>& nums) {
        int n= nums.size();
        if(n==1) return nums[0];

        // 不是环形数组的最大值
        vector<int> dp(n) ;  // 状态方程转移，以第i个结尾的前i个的最大和
        dp[0] = nums[0];
        int sum=nums[0];
        for(int i=1;i<n;i++){
            sum+=nums[i];
            if(dp[i-1]>0) dp[i] = dp[i-1]+nums[i];  // 前i-1个和是正数，就加上
            else dp[i] = nums[i];  // 前i个和为负数，就不加上
        }
        auto max1 = *max_element(dp.begin(),dp.end());  // 找出里面的最大值，返回迭代器
    
        // 不是环形数组的最小值
        vector<int> nums2 = nums;
        nums2.erase(nums2.begin());
        nums2.pop_back();
        vector<int> dp1(nums2.size());
        dp1[0] = nums2[0];
        for(int i=1;i<nums2.size();i++){
            if(dp1[i-1]>0) dp1[i] = nums2[i];
            else dp1[i] = dp1[i-1]+nums2[i];
        }
        auto min = *min_element(dp1.begin(),dp1.end());
        int max2 = sum-min;  // 转化成为包含nums[n-1]和nums[0]的最大值
        return max(max2,max1);
    }
};
```

# 单调队列

## Milk Patterns G (LG P2852)

**题目：[P2852 [USACO06DEC\]Milk Patterns G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2852)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 4e4 + 10 ;
int sa[N],rk[N << 1],oldrk[N << 1],height[N];
int n , k ; int s[N] ;
void get_sa(){
	for(int i=1;i<=n;++i) sa[i] = i , rk[i] = s[i] ;
	for(int k=1;k<n;k<<=1){
		sort(sa+1,sa+1+n,[&](int x,int y){
			return rk[x]==rk[y]?rk[x+k]<rk[y+k]:rk[x]<rk[y];
		});
		memcpy(oldrk,rk,sizeof(rk)); int p = 0 ;
		for(int i=1;i<=n;++i){
			if(oldrk[sa[i]]==oldrk[sa[i-1]]&&oldrk[sa[i]+k]==oldrk[sa[i-1]+k])
				rk[sa[i]] = p;
			else rk[sa[i]] = ++p ;
		}
		if(p == n) break;
	}
}
void get_height(){
	int k = 0;
	for(int i=1;i<=n;++i) {
		if(rk[i]==1) continue ;
		if(k) k-- ;
		int j = sa[rk[i]-1] ;
		while(i+k <= n && j+k <= n && s[i+k]==s[j+k]) k++;
		height[rk[i]] = k;
	}
}
class MyDeque{
public:
	deque<int> q;
	void pop(int val){
		if(q.front() == val) q.pop_front();
	}	
	void push(int val){
		while(q.size() && q.back() > val) q.pop_back();
		q.push_back(val) ;
	}
	int getMin(){
		return q.front();
	}
};

int main(){
	cin >> n >> k ;
	for(int i=1;i<=n;++i) cin >> s[i] ; 
	get_sa() ; get_height() ;
	MyDeque que; int ans = 0; k -= 1;
	for(int i=1;i<=n;++i){
		if(i<k) que.push(height[i]);
		else{
			que.push(height[i]);
			ans = max(ans,que.getMin()) ;
			que.pop(height[i-k+1]);
		}
	}
	cout << ans << endl ;
	system("pause");
}
```

## 滑动窗口最大值（LC 239）

**题目：[239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/)**

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> dq ; vector<int> ans ; 
        for(int i=0;i<nums.size();++i){
            if(i < k - 1) {
                while(dq.size() && nums[dq.back()] <= nums[i]) dq.pop_back() ;  // 处理后端
                dq.push_back(i) ;
                continue ;
            }
            if(dq.size() && i - dq.front() + 1 > k) dq.pop_front() ;  // 处理前端
            while(dq.size() && nums[dq.back()] <= nums[i]) dq.pop_back() ;  // 处理后端
            dq.push_back(i) ; ans.push_back(nums[dq.front()]) ;
        }
        return ans;
    }
};
```

## 带限制的子序列和（LC 1425）

**题目：[1425. 带限制的子序列和 - 力扣（LeetCode）](https://leetcode.cn/problems/constrained-subsequence-sum/)**

```c++
class Solution {
public:
    int constrainedSubsetSum(vector<int>& nums, int k) {
        int n = nums.size() ; auto f = vector<int>(n) ; deque<int> dq ;
        for(int i=0;i<n;++i) f[i] = nums[i] ; int ans = INT_MIN ;
        for(int i=0;i<n;++i) {
            if(dq.size() && i - dq.front() > k) dq.pop_front() ;  // 处理前端
            if(dq.size()) f[i] = max(f[i], f[dq.front()] + nums[i]) ;
            while(dq.size() && f[dq.back()] <= f[i]) dq.pop_back() ; // 处理后端
            dq.push_back(i) ; ans = max(ans , f[i]) ;
        }
        return ans ;
    }
};
```

## 和至少为K的最短子数组（LC 862）

**题目：[862. 和至少为 K 的最短子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)**

```c++
class Solution {
public:
    int shortestSubarray(vector<int>& arr, int k) {
        vector<long> nums(arr.size() + 1);
        for (int i = 0; i < arr.size(); i++) {
            nums[i + 1] = nums[i] + arr[i];
        }
        deque<int> dq ; dq.push_back(0) ; int ans = INT_MAX ;
        for(int i=1;i<nums.size();++i) {
            while(dq.size() && nums[dq.back()] >= nums[i]) {
                dq.pop_back() ;
            }  // 处理后端
            dq.push_back(i) ;
            while(dq.size() && nums[dq.back()] - nums[dq.front()] >= k) {
                ans = min(ans,dq.back()-dq.front()) ;
                dq.pop_front() ;
            }  // 处理前端
        }
        return ans==INT_MAX? -1 : ans ;
    }
};
```

## 绝对差不超过限制的最长连续子数组（LC 1438）

**题目：[1438. 绝对差不超过限制的最长连续子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)**

```c++
class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        deque<int> queMax, queMin;
        int n = nums.size();
        int left = 0, right = 0;
        int ret = 0;
        while (right < n) {
            while (!queMax.empty() && queMax.back() < nums[right]) queMax.pop_back();
            while (!queMin.empty() && queMin.back() > nums[right]) queMin.pop_back();
            queMax.push_back(nums[right]);
            queMin.push_back(nums[right]);
            while (!queMax.empty() && !queMin.empty() && queMax.front() - queMin.front() > limit) {
                if (nums[left] == queMin.front()) queMin.pop_front();
                if (nums[left] == queMax.front()) queMax.pop_front();
                left++;
            }
            ret = max(ret, right - left + 1);
            right++;
        }
        return ret;
    }
};
```



# 单调栈

## [模板题]单调栈（LG P5788）

**模板题：[P5788 【模板】单调栈 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5788)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 3e6+10;
int ans[N] , n ,a[N] ;
class MyStack{  // 单调递减栈，存下标
public:
	stack<int> st;
	int size(){return st.size();}
	void pop(){st.pop();}
	int top(){return st.top();}
	void push(int idx){
		while(st.size() && a[st.top()] < a[idx]) {
			int id = st.top() ;  ans[id] = idx ;
			st.pop();
		}
		st.push(idx);
	}
};
int main(){
	cin >> n ; MyStack st; 
	for(int i=1;i<=n;++i){
		cin >> a[i] ;
		st.push(i);  
	}
	while(st.size()){
		int id = st.top() ; ans[id] = 0;
		st.pop();
	}
	for(int i=1;i<=n;++i) cout << ans[i] << " "; cout << endl ;
	system("pause");
}
```

## 子数组的最小值之和（LC 907）

**[907. 子数组的最小值之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-subarray-minimums/)**

```c++
class Solution {
public:
    int sumSubarrayMins(vector<int>& arr) {
        stack<int> st; int left[arr.size()] ,right[arr.size()] ;
        for(int i=0;i<arr.size();++i){
            while(st.size() && arr[st.top()] >= arr[i]) {  // 左边界强制大于等于arr[i]
                st.pop();
            }
            if(st.size()) left[i] = st.top();
            else left[i] = -1;
            st.push(i);
        }
        while(st.size()) st.pop();
        for(int i=0;i<arr.size();++i) cout << left[i] << " " ; cout << endl ;
        for(int i=0;i<arr.size();++i){
            while(st.size() && arr[st.top()] >= arr[i]){  // 右边界强制大于arr[i]
                right[st.top()] = i ; st.pop();
            }
            st.push(i);
        }
        while(st.size()) right[st.top()] = arr.size() , st.pop() ;
        for(int i=0;i<arr.size();++i) cout << right[i] << " " ; cout << endl ;
        const int P = 1e9+7; long long ans = 0LL;
        for(int i=0;i<arr.size();++i){
            ans += ((long long)arr[i] * (long long)(i-left[i]) * (long long)(right[i]-i))%P ;
        }
        return ans%P;
    }
};
```

```c++
// 合并写在一起
class Solution {
public:
    int sumSubarrayMins(vector<int>& arr) {
        stack<int> st; int left[arr.size()] ,right[arr.size()] ;
        for(int i=0;i<arr.size();++i){
            while(st.size() && arr[st.top()] >= arr[i]) {
                right[st.top()] = i ; st.pop();
            }
            if(st.size()) left[i] = st.top();
            else left[i] = -1;
            st.push(i);
        }
        while(st.size()) right[st.top()] = arr.size() , st.pop();
        const int P = 1e9+7; long long ans = 0LL;
        for(int i=0;i<arr.size();++i){
            ans += ((long long)arr[i] * (long long)(i-left[i]) * (long long)(right[i]-i))%P ;
        }
        return ans%P;
    }
};
```

## 下一个更大的元素 | (LC 496)

**题目：[496. 下一个更大元素 I - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-i/)**

```c++
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        int n = nums2.size() ; vector<int> RM(n) , ans ; stack<int> s ;
        for(int i=0;i<n;++i) {
            while(s.size() && nums2[s.top()] < nums2[i]) RM[s.top()] = nums2[i] , s.pop() ;
            s.push(i) ;
        }
        while(s.size()) RM[s.top()] = -1 , s.pop() ;
        unordered_map<int,int> m ;
        for(int i=0;i<n;++i) m[nums2[i]] = RM[i] ;
        for(auto e : nums1) ans.push_back(m[e]) ;
        return ans ;
    }
};
```

## 下一个更大的元素 ||（LC 503）

**题目：[503. 下一个更大元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-ii/)**

```c++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        int n = nums.size() ;
        for(int i=0;i<n;++i) nums.push_back(nums[i]) ;
        auto ans = vector<int>(n*2) ; stack<int> s ;
        for(int i=0;i<n*2;++i) {
            while(s.size() && nums[s.top()] < nums[i]) ans[s.top()] = nums[i] , s.pop() ;
            s.push(i) ;
        }
        while(s.size()) ans[s.top()] = -1 , s.pop() ;
        ans.erase(ans.begin() + n , ans.end()) ;
        return ans ;
    }
};
```

## 移掉K位数字（LC 402）

**题目：[402. 移掉 K 位数字 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-k-digits/)**

```c++
class Solution {
public:
    string removeKdigits(string num, int k) {
        int n = num.size() ; stack<int> s ; 
        bool flag = false ; string ans = "";
        for(int i=0;i<n;++i) {
            while(!flag && s.size() && num[s.top()] > num[i]) {
                s.pop() ; k -- ; if(k == 0) {flag = true ; break ;}
            }
            s.push(i) ;
        }
        while(s.size()) {  // 倒序存储进入ans
            if(k) k -- ;
            else ans += num[s.top()] ;
            s.pop() ;
        }
        int p = ans.size() - 1 ; 
        while(p >= 0 && ans[p] == '0') p -- ; if(p == -1) return "0" ;  // 去除前导零，因为此时的ans是倒序，所以从后面开始就行
        num = ans.substr(0,p+1) ; reverse(num.begin(),num.end()) ;  // 组装答案
        return num ;
    }
};
```

## 柱状图种最大的矩形（LC 84）

**题目：[84. 柱状图中最大的矩形 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-rectangle-in-histogram/)**

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& h) {
        // 总有一个会叠满，枚举每一个叠满的情况，求最大值
        // 如果要叠满，需要向右和向左寻找第一个小于该高度的柱子，单调栈O(n)实现
        int n = h.size() ; 
        vector<int> RM(n) ; // 储存向右第一个小于该高度的柱子的下标
        vector<int> LM(n) ; // 储存向左第一个小于等于该高度的柱子的下标
        stack<int> s ; // 单调递增栈处理 , 存储下标
        for(int i=0;i<n;++i){
            while(s.size() && h[s.top()] > h[i]) RM[s.top()] = i , s.pop() ;  // 单调处理
            if(s.size()) LM[i] = s.top() ;
            else LM[i] = -1 ;
            s.push(i) ;
        }
        while(s.size()) RM[s.top()] = n , s.pop() ;  // 处理右端没有比他小的
        int ans = 0 ; 
        for(int i=0;i<n;++i) ans = max(ans , h[i] * (RM[i] - LM[i] - 1) ) ; // 统计答案
        return ans ;
    }
};
```

## 接雨水（LC 42）

**题目：[42. 接雨水 - 力扣（LeetCode）](https://leetcode.cn/problems/trapping-rain-water/)**

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        // 解法四 单调栈模拟处理
        int ans = 0;
        stack<int> st;
        for (int i = 0; i < height.size(); i++)
        {
            while (!st.empty() && height[st.top()] < height[i])
            {
                int cur = st.top();
                st.pop();
                if (st.empty()) break;
                int l = st.top();
                int r = i;
                int h = min(height[r], height[l]) - height[cur];
                ans += (r - l - 1) * h;
            }
            st.push(i);
        }
        return ans;
    }
};
```

## 去除重复字母（LC 316）

**题目：[316. 去除重复字母 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicate-letters/)**

```c++
class Solution {
public:
    string removeDuplicateLetters(string s) {
        int n = s.size() ; vector<int> RM(26) , instk(26);  // 相同字母右边出现的最后一个位置，是否在栈中
        for(int i=0;i<n;++i) RM[s[i] - 'a'] = i ;
        stack<int> st ;
        for(int i=0;i<s.size();++i) {
            if(instk[s[i] - 'a']) continue ;  // 剔除重复的
            while(st.size() && s[st.top()] > s[i] && RM[s[st.top()] - 'a'] > i) 
                instk[s[st.top()] - 'a'] = 0 , st.pop() ;  // 只要后面有相同的并且当前有更优的选择
            st.push(i) ; instk[s[i] - 'a'] = 1 ;
        }
        string ans ; while(st.size()) ans += s[st.top()] , st.pop() ; reverse(ans.begin(),ans.end()) ;
        return ans ;
    }
};
```

## 找出最具竞争力的子序列（LC 1673）

**题目：[1673. 找出最具竞争力的子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-most-competitive-subsequence/)**

```c++
class Solution {
public:
    vector<int> mostCompetitive(vector<int>& nums, int k) {
        // 查询区间最小值的题目 ， 可以线段树 ， 可以树状数组 ， 可以ST表 , 可以单调栈
        stack<int> st ; bool ok = false ; int k1 = nums.size() - k ; if(k1 == 0) ok = true ; 
        for(int i=0;i<nums.size();++i){
            while(!ok && st.size() && nums[st.top()] > nums[i]) {
                st.pop() ; if(--k1 == 0) ok = true ;
            }
            st.push(i) ;
        } 
        //cout << nums.size() << " " << k << endl ;
        vector<int> ans ; while(st.size()) ans.push_back(nums[st.top()]) , st.pop() ;
        reverse(ans.end()-k,ans.end()) ;
        return  vector<int>(ans.end()-k,ans.end());
    }
};
```

## 最大宽度坡

**题目：[962. 最大宽度坡 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-width-ramp/)**

```c++
class Solution {
public:
    int maxWidthRamp(vector<int>& nums) {
        stack<int> S ; int n = nums.size() ;
        for(int i=0;i<n;++i){
            if(S.empty() || nums[S.top()] > nums[i]) S.push(i) ;
        } 
        int ans = 0 ;
        for(int i=n-1;i>=0;--i){
            while(S.size() && nums[i] >= nums[S.top()]) {
                ans = max(ans , i - S.top()) ;
                S.pop() ;
            }
            if(S.empty()) break ;
        }
        return ans ;
    }
};
```

## 表现良好的最长时间段

**题目：[1124. 表现良好的最长时间段 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-well-performing-interval/)**

```c++
class Solution {
public:
    int longestWPI(vector<int>& hours) {
        int n = hours.size() ;  if(n == 0) return 0 ;
        vector<int> nums(n + 1) ;
        for(int i=1;i<=n;++i) {
            if(hours[i - 1] > 8) nums[i] += nums[i - 1] + 1 ;
            else nums[i] += nums[i - 1] - 1 ;
        }

        stack<int> S ; n = nums.size() ;
        for(int i=0;i<n;++i){
            if(S.empty() || nums[S.top()] > nums[i]) S.push(i) ;
        } 
        int ans = 0 ;
        for(int i=n-1;i>=0;--i){
            while(S.size() && nums[i] > nums[S.top()]) {
                ans = max(ans , i - S.top()) ;
                S.pop() ;
            }
            if(S.empty()) break ;
        }
        return ans ;
    }
};
```

## [132 模式](https://leetcode.cn/problems/132-pattern/)

```c++
using ll = long long ;
class Solution {
public:
    bool find132pattern(vector<int>& nums) {
        int n = nums.size() ;
        // 寻找3左边最小值，右边比3小的最大值 
        vector<int> l(n) , r(n,INT_MAX) ; int tp = INT_MAX ;
        stack<int> st ; 
        for (int i = 0; i < n; ++i){
            l[i] = tp ; tp = min(tp , nums[i]) ;
        }
        for (int i = n-1; i >= 0; --i){
            while(st.size() && nums[st.top()] < nums[i]){
                r[i] = nums[st.top()] ;
                st.pop() ;
            }
            st.push(i) ;
        }
        for (int i = 1; i < n - 1; ++i){
            if(nums[i] > l[i] && nums[i] > r[i] && l[i] < r[i]) return true ;
        }
        return false ;
    }
};
```



# 堆

## 丑数II（LC 264）

**题目：[264. 丑数 II - 力扣（LeetCode）](https://leetcode.cn/problems/ugly-number-ii/)**

```c++
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> primes;
        primes.push_back(2);
        primes.push_back(3);
        primes.push_back(5);
        vector<int> idx(primes.size(),0);
        auto dp = vector<long long>(n);
        dp[0] = 1;
        for(int i=1;i<n;i++){
            dp[i] = INT_MAX;
            for(int j=0;j<primes.size();j++){
                dp[i] = min(dp[i],dp[idx[j]]*primes[j]);
            }
            for(int j=0;j<primes.size();j++){
                if(dp[i]==dp[idx[j]]*primes[j]) 
                    idx[j]++;
            }
        }
        return dp[n-1];
    }
};
```



## 根据字符出现频率排序（LC 451）

**题目：[451. 根据字符出现频率排序 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-characters-by-frequency/)**

```c++
class Solution {
public:
    int Hash(char A){  // 哈希映射
        if(A>='a' && A<='z') return A-'a';  // a~z 0~25
        if(A>='A' && A<='Z') return A-'A'+26;  // A~Z 26~51
        if(A>='0' && A<='9') return A-'0'+52;  // 0~9 52~61
        return -1;
    }
    string frequencySort(string s) {
        int n = s.size();
        vector<int> rank(62,0);
        for(int i=0;i<n;i++) rank[Hash(s[i])]++;
        sort(s.begin(),s.end(),[&](char a,char b){
            if(rank[Hash(a)]>rank[Hash(b)]) return true;
            else if(rank[Hash(a)]<rank[Hash(b)]) return false;
            else return a>b;
        });
        return s;
    }
};
```



## 排序数组（LC 912）

**题目：[912. 排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-an-array/)**

```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        return nums;
    }
};
```



## 矩阵中战斗力最弱的k行（LC 1337）

**题目：[1337. 矩阵中战斗力最弱的 K 行 - 力扣（LeetCode）](https://leetcode.cn/problems/the-k-weakest-rows-in-a-matrix/)**

```c++
class A{
public:
    int jun;
    int index;
    A(int a,int b):jun(a),index(b){};
    bool operator<(const A& a2) const{
        if(this->jun<a2.jun) return true;
        else if(this->jun>a2.jun) return false;
        else{
            return this->index<a2.index;
        }
        return 0; 
    }
};
class Solution {
public:
    vector<int> kWeakestRows(vector<vector<int>>& mat, int k) {
        vector<int> v;
        set<A> s;
        for(int i=0;i<mat.size();i++){
            int left=-1;  // 1的最后一个
            int right=mat[i].size();  // 0的第一个
            while(left+1 != right){
                int mid = (right+left)>>1;
                if(mat[i][mid] == 1) left = mid;
                else right =mid;
            }
            
            A temp(left+1,i); 
            s.insert(temp);
            
        } 
        for(auto e:s){
            v.push_back(e.index);
        }
        vector<int> res(v.begin(),v.begin()+k);
        return res;
    }
};
```

## 积压订单中的订单总数（LC 1801）

**题目：[1801. 积压订单中的订单总数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-orders-in-the-backlog/)**

```c++
class Solution {
public:
    const int P = 1e9+7;
    struct node1{
        int price ,amount ;
        bool operator<(const node1 & e1)const{return price > e1.price ;}
    };
    struct node2{
        int price ,amount ;
        bool operator<(const node2 & e1)const{return price < e1.price ;}
    };
    priority_queue<node1> q_mi ; // 销售订单
    priority_queue<node2> q_ma ;  // 采购订单
    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {
        for(auto& e : orders){
            int p = e[0] , m = e[1] ;
            if(e[2] == 0){
                while(q_mi.size() && p>=q_mi.top().price && m > 0){
                    if(q_mi.top().amount > m){
                        auto node = q_mi.top() ;
                        q_mi.pop() ;
                        q_mi.push({node.price,node.amount-m}) ;
                        m = 0 ;
                    }else if(q_mi.top().amount == m){
                        m = 0 ; q_mi.pop() ;
                    }else {
                        m -= q_mi.top().amount ; q_mi.pop() ;
                    }
                }
                if(m > 0) q_ma.push({p,m});
            }else {
                while(q_ma.size() && p<=q_ma.top().price && m > 0){
                    if(q_ma.top().amount > m){
                        auto node = q_ma.top() ;
                        q_ma.pop() ;
                        q_ma.push({node.price,node.amount-m});
                        m = 0 ;
                    }else if(q_ma.top().amount == m){
                        m = 0 ; q_ma.pop() ;
                    }else {
                        m -= q_ma.top().amount ; q_ma.pop() ;
                    }
                }
                if(m > 0) q_mi.push({p,m});
            }
        }
        int ans = 0 ;
        while(q_mi.size()){ans = (ans + q_mi.top().amount) % P ; q_mi.pop();}
        while(q_ma.size()){ans = (ans + q_ma.top().amount) % P ; q_ma.pop();}
        return ans ;
    }
};
```



# 哈希表

## 两个数组的交集（LC 349）

**题目：[349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/)**

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set(begin(nums1),end(nums1));
        unordered_set<int> res;
        for_each(begin(nums2),end(nums2),[&](auto elem){
            if(set.find(elem)!=end(set)) res.insert(elem);
        });
        return vector<int>(begin(res),end(res));
    }
};
```



## 有效的字母异位词（LC 242）

**题目：[242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/)**

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        unordered_map<char,int> mp1;
        unordered_map<char,int> mp2;
        for_each(begin(s),end(s),[&mp1](auto elem){mp1[elem]++;});
        for_each(begin(t),end(t),[&mp2](auto elem){mp2[elem]++;});
        //for_each(begin(mp1),end(mp1),[](auto num){cout<<num.second<<" ";});
        if(mp1==mp2) return true;
        return false;
    }
};
```



## 快乐数（LC 202）

**题目：[202. 快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/)**

```c++
class Solution {
public:
    int getSum(int n) {
        int sum = 0;
        while (n) {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        unordered_set<int> set;
        set.insert(n);
        while(n != 1){
            n = getSum(n);
            //cout<<n<<" ";
            if(set.find(n)==end(set)) set.insert(n);
            else return false;
        }
        return true;
    }
};
```



## 两数之和（LC 1）

**题目：[1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/)**

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> mp;
        for(int i=0;i<nums.size();++i){
            unordered_map<int,int>::iterator it = mp.find(target-nums[i]);
            if(it != mp.end()) return {it->second,i};
            mp[nums[i]] = i;
        }
        return {};
    }
};
```



## 赎金信（LC 383）

**题目：[383. 赎金信 - 力扣（LeetCode）](https://leetcode.cn/problems/ransom-note/)**

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int n=magazine.size();
        for(int i=0;i<n;i++){
            auto it=ransomNote.find(magazine[i]);
            if(it != string::npos){
                ransomNote.erase(it,1);
            }
        }
        if(ransomNote.empty()) return true;
        return false;
    }
};
```



## 三数之和（LC 15）

**题目：[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/)**

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        // 找出a + b + c = 0
        // a = nums[i], b = nums[left], c = nums[right]
        for (int i = 0; i < nums.size(); i++) {
            // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
            if (nums[i] > 0) return result;
            // 去重a方法
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int left = i + 1;
            int right = nums.size() - 1;
            while (left < right) {
                if (nums[i] + nums[left] + nums[right] > 0) right--;
                else if (nums[i] + nums[left] + nums[right] < 0) left++;
                else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;
                    // 找到答案时，双指针同时收缩
                    right--;left++;
                }
            }

        }
        return result;
    }
};


// 回溯暴搜，超时
/* class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    vector<int> nums;
    int sum=0;
    void helper(int start){
        if(path.size()==3){
            if(sum==0)
                res.push_back(path);
            return;
        }
        for(int i=start;i<nums.size() && sum;++i){
            if(i>start && nums[i]==nums[i-1]) continue;
            sum += nums[i];
            path.push_back(nums[i]);
            helper(i+1);
            path.pop_back();
            sum -= nums[i];
        }
    }
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(begin(nums),end(nums));
        this->nums = nums;
        helper(0);
        return res;
    }
}; */
```

## 字母异位词分组（LC 49）

**题目：[49. 字母异位词分组 - 力扣（LeetCode）](https://leetcode.cn/problems/group-anagrams/)**

```c++
class Solution {
public:
    long long prime[26] = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101};  // 每个质数对应一个字母，质数相乘不会重复
    const int P = 1e9+7;
    long long Hash(string& s){
        long long ans = 1 ;
        for(auto e:s) ans =(ans * prime[e-'a']) % P;
        return ans%P;
    }
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> ans ;
        unordered_map<int,vector<string>> m;
        for(auto& s : strs) m[Hash(s)].push_back(s);
        for(auto& e : m) ans.push_back(e.second);
        return ans;
    }
};
```

## 第一次出现两次的字母（LC 2351）

**题目：[2351. 第一个出现两次的字母 - 力扣（LeetCode）](https://leetcode.cn/problems/first-letter-to-appear-twice/)**

```c++
class Solution {
public:
    char repeatedCharacter(string s) {
        int state = 1 << 26 ;
        for(int i=0;i<s.size();++i) {
            int j = s[i] - 'a' ;
            if(state >> j & 1) return s[i];
            else state |= (1 << j) ;
        }
        return 'a' ;
    }
};
```

## 查找用户活跃分钟数（LC 1817）

**题目;[1817. 查找用户活跃分钟数 - 力扣（LeetCode）](https://leetcode.cn/problems/finding-the-users-active-minutes/)**

```c++
class Solution {
public:
    vector<int> findingUsersActiveMinutes(vector<vector<int>>& logs, int k) {
    	std::vector<int> ans(k) ;
    	std::sort(std::begin(logs),std::end(logs),[&](auto const & e1 , auto const & e2){
    		return e1[0] == e2[0] ? e1[1] < e2[1] : e1[0] < e2[0] ; 
    	}) ;
    	logs.erase(std::unique(std::begin(logs),std::end(logs)),std::end(logs)) ;
    	std::unordered_map<int,int> mp ;
    	for(auto e : logs){
    		mp[e[0]] ++ ;
    	}
    	for(auto& [u,v] : mp) {
    		ans[v - 1] ++ ;
    	}
    	return  ans ;
    }
};
```

## [最大相等频率](https://leetcode.cn/problems/maximum-equal-frequency/)

```c++
class Solution {
public:
    int maxEqualFreq(vector<int>& nums) {
        int n = nums.size() ; int ans = 0 ; 
        unordered_map<int,int> cnt , mp ; 
        for(int i = 0 ; i < nums.size() ; ++ i){
            int tp = cnt[nums[i]] ++ ;
            if(tp != 0) {
                if(-- mp[tp] == 0) mp.erase(tp) ; 
            }
            mp[tp + 1] ++ ;
            if(mp.size() == 2){
                int Max = INT_MIN , Min = INT_MAX ;
                for(auto& e : mp) Max = max(Max , e.first) , Min = min(Min , e.first);
                if((Min == 1 && mp[Min] == 1) || (Max == Min + 1 && mp[Max] == 1)) ans = i + 1 ;
            }else if(mp.size() == 1 && (mp.begin()->second == 1 || mp.begin()->first == 1)) ans = i + 1 ;
        }
        return ans ;
    }
};
```

## [检查数组对是否可以被 k 整除](https://leetcode.cn/problems/check-if-array-pairs-are-divisible-by-k/)

```c++
class Solution {
public:
    int mod(int x,int k){return (x % k + k) % k ;}
    bool canArrange(vector<int>& arr, int k) {
        vector<int> cnt(k) ;
        for(int i=0;i<arr.size();++i) arr[i] = (arr[i] % k + k ) % k , cnt[arr[i]] ++ ;
        int i = 1 , j = k - 1 ;
        if(cnt[0] % 2 == 1) return false ;
        while(i < j){
            if(cnt[i] != cnt[j]) return false ;
            i ++ , j -- ;
        }
        if(i == j && cnt[i] % 2 == 1) return false ; 
        return true ;
    }
};
```

## 清楚姐姐逛街

**题目：[H-清楚姐姐逛街(Hard Version)_2023牛客寒假算法基础集训营4 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/46812/H)**

```c++
#include <bits/stdc++.h>
#define int long long
#define x first
#define y second 
#define debug cout << "__LINE__" << __LINE__ << endl ;
using namespace std ; typedef long long ll ; typedef pair<int,int> pii ;
const int INF = 0x3f3f3f3f3f3f3f3f ; const double eps=1e-6 ; const int P = 1e9 + 7 ;
inline ll gcd(ll a, ll b) { return b == 0 ? a : gcd(b,a%b);}
inline ll lcm(ll a, ll b) { return a / gcd(a, b) * b;}
inline ll mod(ll x,ll p=P) { return (x%p + p)%p;}
inline ll qpow(ll a,ll b,ll p=P) { ll res = 1;a=mod(a,p); while (b) { if (b&1) res=mod(res*a,p);a=mod(a*a,p);p>>=1;}return res;}

#define LOGN 20

void solve(){
	int n , m , sx , sy , q ;
	cin >> n >> m >> sx >> sy >> q ;

	vector<vector<char>> grid(n , vector<char>(m)) ;
	for(int i = 0 ; i < n ; ++ i) 
        for(int j = 0 ; j < m ; ++ j) cin >> grid[i][j] ;

	int dx[5] = {0,-1,1,0,0} , dy[5] = {0,0,0,-1,1} ;
	int dis[n][m] ; memset(dis,0x3f,sizeof(dis)) ;
	function<void(int,int)> bfs = [&](int x,int y)
	{
		queue<pii> q ; q.push({x , y}) ; dis[x][y] = 0 ;
		while(q.size())
		{
			auto u = q.front() ; q.pop() ;
			for(int i = 1 ; i <= 4 ; ++ i)
			{
				int xx = u.x + dx[i] , yy = u.y + dy[i] ;
				if(xx < 0 || yy < 0 || xx >= n || yy >= m || dis[xx][yy] != INF || grid[xx][yy] == '#') continue ;
				dis[xx][yy] = dis[u.x][u.y] + 1 ;
				q.push({xx , yy}) ; 
			}
		}		
	} ;
	bfs(sx,sy) ;  // 距离

	pii f[n][m][LOGN+1] ;  // 跳表
	for(int x = 0 ; x < n ; ++ x)
		for(int y = 0 ; y < m ; ++ y)
		{
			if(grid[x][y] == 'L')
			{
				if(grid[x][y-1] == '#') f[x][y][0] = {x,y} ;
				else f[x][y][0] = {x , y-1} ; 
			} 
			else if(grid[x][y] == 'R')
			{
				if(grid[x][y+1] == '#') f[x][y][0] = {x,y} ;
				else f[x][y][0] = {x , y+1} ; 
			}
			else if(grid[x][y] == 'U')
			{
				if(grid[x-1][y] == '#') f[x][y][0] = {x,y} ;
				else f[x][y][0] = {x-1 , y} ; 
			}
			else if(grid[x][y] == 'D')
			{
				if(grid[x+1][y] == '#') f[x][y][0] = {x,y} ;
				else f[x][y][0] = {x+1 , y} ; 
			}
			else f[x][y][0] = {x,y} ;
		}
    // 构建跳表
	for(int k = 1 ; k <= LOGN ; ++ k)
	{
		for(int i = 0 ; i < n ; ++ i)
			for(int j = 0 ; j < m ; ++ j)
			{
				auto it = f[i][j][k-1] ;
				f[i][j][k] = f[it.x][it.y][k-1] ;
			}
	}

	while(q -- )
	{
		int qx , qy ; cin >> qx >> qy ;

		auto check = [&](int x)
		{
			pii it = {qx , qy} ;
			for(int i = LOGN ; i >=0 ; -- i)
			{
				if(x >> i & 1) it = f[it.x][it.y][i] ;
			}
			if(dis[it.x][it.y] <= x) return true ;
			return false ;
		} ;
        
        // 二分查找答案
		int l = 0 , r = n * m , ans = -1 ;
		while(l <= r)
		{
			int mid = (l + r) >> 1 ;
			if(check(mid)) ans = mid , r = mid - 1 ;
			else l = mid + 1 ;
		}
		cout << ans << endl ;
	}
}

signed main(){
	ios::sync_with_stdio(false) ; 
	cin.tie(nullptr) ; cout.tie(nullptr) ;
	int t = 1 ; // cin >> t ;
	while( t -- ) solve() ;
	return 0 ;
}
```

## [警告一小时内使用相同员工卡大于等于三次的人](https://leetcode.cn/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/)

```c++
class Solution {
public:
    vector<string> alertNames(vector<string>& keyName, vector<string>& keyTime) {
        unordered_map<string, vector<int>> timeMap;
        int n = keyName.size();
        for (int i = 0; i < n; i++) {
            string name = keyName[i];
            string time = keyTime[i];
            int hour = (time[0] - '0') * 10 + (time[1] - '0');
            int minute = (time[3] - '0') * 10 + (time[4] - '0');
            timeMap[name].emplace_back(hour * 60 + minute);
        }
        vector<string> res;
        for (auto &[name, list] : timeMap) {
            sort(list.begin(), list.end());
            int size = list.size();
            for (int i = 2; i < size; i++) {
                int time1 = list[i - 2], time2 = list[i];
                int difference = time2 - time1;
                if (difference <= 60) {
                    res.emplace_back(name);
                    break;
                }
            }
        }
        sort(res.begin(), res.end());
        return res;
    }
};
```



# 二分查找

## （hard）寻找两个正序数组的中位数（LC 4）

**题目：[4. 寻找两个正序数组的中位数 - 力扣（LeetCode）](https://leetcode.cn/problems/median-of-two-sorted-arrays/)**

```C++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        vector<int> v;
        int i=0,j=0;
        while(i<nums1.size()&&j<nums2.size()){
            if(nums1[i]<= nums2[j]){
                v.push_back(nums1[i]);
                i++;
            }
            else{
                v.push_back(nums2[j]);
                j++;
            }
        }
        while( i != nums1.size() ){
            v.push_back(nums1[i]);
                i++;
        }
        while( j != nums2.size() ){
            v.push_back(nums2[j]);
                j++;
        }
        if(v.size()%2 == 1){
            return v[v.size()/2];
        }
        else{
            return (double)(v[v.size()/2]+v[v.size()/2-1])/2;
        }
    }
};
```



## 在排序数组中查找元素的第一个位置和最后一个位置（LC 34）

**题目：[34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)**

```C++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int n=nums.size();
        int left=-1;
        int right=n;
        bool tag=false;
        while(left+1 != right){
            int mid = (right+left)>>1;
            if(nums[mid] == target) tag = true;
            if(target>nums[mid]) left = mid;  // 始终在比target小的第一个位置
            else right = mid;
        }
        int left1=-1;
        int right1=n;
        while(left1+1 != right1){
            int mid = (right1+left1)>>1;
            if(target<nums[mid]) right1 = mid;  // 始终在比target大的第一个位置
            else left1 = mid;
        }
        vector<int> v;
        if(!tag){
            v.push_back(-1);
            v.push_back(-1);
        } 
        else{
            v.push_back(left+1);
            v.push_back(right1-1);
        }
        return v;  
    }
};
```



## 搜索插入位置（LC 35）

**题目：[35. 搜索插入位置 - 力扣（LeetCode）](https://leetcode.cn/problems/search-insert-position/)**

```C++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0,right = n-1;
        int mid = 0;
        while(left<=right){
            mid = left + (right-left)/2;
            if(nums[mid] == target) return mid;
            if(nums[mid]<target) left = mid+1;
            if(nums[mid]>target) right = mid-1;   
        }
        return left;
        
    }
    
};
```



## x的平方根（LC 69）

**题目：[69. x 的平方根 - 力扣（LeetCode）](https://leetcode.cn/problems/sqrtx/)**

```C++
class Solution {
public:
    int mySqrt(int x) {
        int n=x;
        long long left=0;
        unsigned long long right=n;  
        while(left<=right){
            long long mid=(left+right)/2;
            if(mid*mid == x) return mid;
            if(mid*mid>x && (mid-1)*(mid-1)<x) return mid-1;
            else if(mid*mid<x) left=mid+1;
            else right=mid-1;
        }
        return -1;
    }
};
```



## 搜索二维矩阵（LC 74）

**题目：[74. 搜索二维矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/search-a-2d-matrix/)**

```C++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int left = -1,right = matrix.size();
        int i=-1,j=-1;
        while(left+1 != right){
            int mid=(left+right)>>1;
            if(matrix[mid][0]<=target && matrix[mid][matrix[0].size()-1]>=target){
                i=mid;break;
            }
            if(matrix[mid][matrix[0].size()-1]<target) left=mid;
            else right=mid;
        }
        if(i==-1) return false;
        left=-1,right=matrix[0].size();
        while(left+1 != right){
            int mid=(left+right)>>1;
            if(matrix[i][mid]==target){j=mid;break;}
            if(matrix[i][mid]>target) right=mid;
            else left=mid;
        }
        if(j==-1) return false;
        return true;
    }
};
```



## 两数之和||-输入有序数组（LC 167）

**题目：[167. 两数之和 II - 输入有序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)**

```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        vector<int> ans;
        int n = numbers.size();
        int i=0,j=n-1;
        while(i<=j){
            if((numbers[i]+numbers[j])==target){
                ans.push_back(i+1);
                ans.push_back(j+1);
                return ans;
            }
            if((numbers[i]+numbers[j]) > target){
                j--;
            }
            if((numbers[i]+numbers[j])<target){
                i++;
            }

        }
        return ans;
    }
};
```



## 长度最小的子数组（LC 209）

**题目：[209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/)**

```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        queue<int> que;
        int sum = 0;
        int minLen = nums.size();
        int tag = 0;
        for(int i=0;i<nums.size();i++){
            if(sum<target){
                que.push(nums[i]);
                sum+=nums[i];
                
            }
            
                while(sum>=target){
                    minLen = que.size()>minLen?minLen:que.size();
                    sum-=que.front();
                    que.pop();
                    tag = 1;
                }
            
            

        }
        if(tag == 0) return 0;
        return minLen;
    }
};
```



## 第一个错误的版本（LC 278）

**题目：[278. 第一个错误的版本 - 力扣（LeetCode）](https://leetcode.cn/problems/first-bad-version/)**

```C++
// The API isBadVersion is defined for you.
// bool isBadVersion(int version);

class Solution {
public:
    int firstBadVersion(int n) {
        int left = 1,right = n-1;
        while(left<=right){
            int mid = left+(right-left)/2;
            if(isBadVersion(mid) == false) left = mid+1;
            else right = mid-1;
        }
        return left;
    }
};
```



## 两个数组的交集（LC 349）

**题目：[349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/)**

```C++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set(begin(nums1),end(nums1));
        unordered_set<int> res;
        for_each(begin(nums2),end(nums2),[&](auto elem){
            if(set.find(elem)!=end(set)) res.insert(elem);
        });
        return vector<int>(begin(res),end(res));
    }
};
```



## 两个数组的交集||（LC 350）

**题目：[350. 两个数组的交集 II - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)**

```C++
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        sort(nums1.begin(),nums1.end());
        sort(nums2.begin(),nums2.end());
        vector<int> v;
        int i=0,j=0;
        while(i<nums1.size()&&j<nums2.size()){
            if(nums1[i] == nums2[j]){
                v.push_back(nums1[i]);
                i++;j++;continue;
            }
            if(nums1[i] > nums2[j]){j++;continue;}
            if(nums1[i] < nums2[j]){i++;continue;}
        }

        return v;
    }
};
```



## 有效的完全平方数（LC 367）

**题目：[367. 有效的完全平方数 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-perfect-square/)**

```C++
class Solution {
public:
    bool isPerfectSquare(int num) {
        int left=1,right=num;
        unsigned long long mid =0;
        while(left<=right){
            mid = left + (right-left)/2;
            if(mid*mid == num) return true;
            if(mid*mid < num) left = mid+1;
            else right = mid-1; 
        }
        return false;
    }
};
```



## 猜数字大小（LC 374）

**题目：[374. 猜数字大小 - 力扣（LeetCode）](https://leetcode.cn/problems/guess-number-higher-or-lower/)**

```C++
class Solution {
public:
    int guessNumber(int n) {
        int left=1,right=n;
        while(left<=right){
            int mid = left + (right - left)/2;
            if(guess(mid) == 0) return mid;
            if(guess(mid) == 1) left = mid+1;
            else right = mid-1;
        }
        return -1;
    }
};
```



## 排列硬币（LC 441）

**题目：[441. 排列硬币 - 力扣（LeetCode）](https://leetcode.cn/problems/arranging-coins/)**

```C++
class Solution {
public:
    int arrangeCoins(int n) {
        long long  sum=0;
        int i=0;
        for(i=0;i<1000000007;i++){
            sum+=i;
            if(sum == n) return i;
            if(sum+i+1>n) return i;
        }
        return -1;
    }
};
```



## 二分查找（LC 704）

**题目：[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/)**

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        int ans = 0 ;int left =0;int right = n-1;
        while(left<=right){
            ans = left + (right-left)/2;
            if(nums[ans] == target) return ans;
            if(nums[ans]>target) right = ans-1;
            else left = ans+1;
        }
        return -1;
    }
};
```



## 寻找比目标字母大的最小字母（LC 744）

**题目：[744. 寻找比目标字母大的最小字母 - 力扣（LeetCode）](https://leetcode.cn/problems/find-smallest-letter-greater-than-target/)**

```C++
class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) {
        for(int i=0;i<letters.size();i++){
            if(letters[i]>target) return letters[i];
        }
        return letters[0];
    }
};
```



## 山脉数组的峰顶索引（LC 852）

**题目：[852. 山脉数组的峰顶索引 - 力扣（LeetCode）](https://leetcode.cn/problems/peak-index-in-a-mountain-array/)**

```C++
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int n = arr.size();
        int left = 0,right = n-1;
        int mid = 0;
        if(n<3) return 0;
        while(left<=right){
            mid = left + (right-left)/2;
            if(mid == 0){
                if(arr[mid]>arr[mid]) return mid;
                else return mid+1;
            }
            if(mid == n-1){
                if(arr[mid]>arr[mid-1]) return mid;
                else return mid-1;
            }
            if(arr[mid]>arr[mid+1] && arr[mid]>arr[mid-1]) return mid;
            if(arr[mid]>arr[mid-1] && arr[mid]<arr[mid+1]) left = mid+1;
            if(arr[mid]<arr[mid-1] && arr[mid]>arr[mid+1]) right = mid-1;
        }
        return mid;
    }
};
```



## 矩阵中战斗力最弱的k行（LC 1337）

**题目：[1337. 矩阵中战斗力最弱的 K 行 - 力扣（LeetCode）](https://leetcode.cn/problems/the-k-weakest-rows-in-a-matrix/)**

```C++
class A{
public:
    int jun;
    int index;
    A(int a,int b):jun(a),index(b){};
    bool operator<(const A& a2) const{
        if(this->jun<a2.jun) return true;
        else if(this->jun>a2.jun) return false;
        else{
            return this->index<a2.index;
        }
        return 0; 
    }
};
class Solution {
public:
    vector<int> kWeakestRows(vector<vector<int>>& mat, int k) {
        vector<int> v;
        set<A> s;
        for(int i=0;i<mat.size();i++){
            int left=-1;  // 1的最后一个
            int right=mat[i].size();  // 0的第一个
            while(left+1 != right){
                int mid = (right+left)>>1;
                if(mat[i][mid] == 1) left = mid;
                else right =mid;
            }
            
            A temp(left+1,i); 
            s.insert(temp);
            
        } 
        for(auto e:s){
            v.push_back(e.index);
        }
        vector<int> res(v.begin(),v.begin()+k);
        return res;
    }
};
```



## 检查整数及其二倍数是否存在（LC 1346）

**题目：[1346. 检查整数及其两倍数是否存在 - 力扣（LeetCode）](https://leetcode.cn/problems/check-if-n-and-its-double-exist/)**

```C++
class Solution {
public:
    
    bool checkIfExist(vector<int>& arr) {
        sort(arr.begin(),arr.end());
        if(count(arr.begin(),arr.end(),0)>=2) return true;
        for(auto e:arr){
            int left=-1;
            int right=arr.size();
            int temp=e*2;
            if(temp==0) continue;
            while(left+1 != right){
                int mid=(left+right)>>1;
                if(arr[mid]==temp) return true;
                if(arr[mid]>temp) right=mid;
                else left=mid;
            }
        }
        return false;
    }
};
```



## 统计有序矩阵中的负数（LC 1351）

**题目：[1351. 统计有序矩阵中的负数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-negative-numbers-in-a-sorted-matrix/)**

```C++
class Solution {
public:
    int countNegatives(vector<vector<int>>& grid) {
        int cnt=0;
        for(int i=0;i<grid.size();i++){
            int left=-1,right=grid[0].size();
            while(left+1 != right){
                int mid=(left+right)>>1;
                if(grid[i][mid]>=0) left = mid;
                else right = mid;
            }
            cnt = cnt+grid[0].size()-left-1;
        }
        return cnt;


        // int cnt=0;
        // for(int i=0;i<grid.size();i++){
        //     for(int j=0;j<grid[i].size();j++){
        //         if(grid[i][j]<0) cnt++;
        //     }
        // }
        // return cnt;
    }
};
```



## 两个数组间的距离值（LC 1385）

**题目：[1385. 两个数组间的距离值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/)**

```C++
class Solution {
public:
    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {
        sort(arr2.begin(),arr2.end());
        int ans = 0;
        for(int i=0;i<arr1.size();i++){
            bool tag = true;
            int left = 0,right = arr2.size()-1;
            while(left<=right){
                int mid = left + (right-left)/2;
                if(abs(arr2[mid]-arr1[i])<=d) {tag = false;break;}
                else if((arr2[mid]-arr1[i])>d) right = mid-1;
                else if((arr1[i]-arr2[mid])>d) left = mid +1;
            }
            ans += tag;
        }
        return ans;
    }
};
```



## 特殊数组的特征值（LC 1608）

**题目：[1608. 特殊数组的特征值 - 力扣（LeetCode）](https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/)**

```c++
class Solution {
public:
    int isSpecial(vector<int> & nums,int n){
        int cnt=0;
        for(int i=0;i<nums.size();i++){
            if(nums[i]>=n) cnt++;
        }
        return cnt;
    }
    int specialArray(vector<int>& nums) {
        auto it=max_element(nums.begin(),nums.end());
        int left=-1,right=*it+1;
        while(left+1 != right){
            int mid=(left+right)/2;
            auto cnt=isSpecial(nums,mid);
            if(cnt == mid) return mid;
            if(cnt > mid) left=mid;
            else right = mid;                     
        }
        return -1;
    }
};
```

## 袋子里最少数目的球（LC 1760）

**题目：[1760. 袋子里最少数目的球 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/)**

```c++
class Solution {
public:
    int minimumSize(vector<int>& nums, int maxOperations) {
        int P = 0，ans = 0;
        int r = 1e9,l = 1;
        while(l <= r) {
            P = 0;
            int m = (l+r) >> 1;
            for(auto e:nums) 
                if(e > m) P += (e-1)/m;
            if(P <= maxOperations) r = m-1,ans=m;
            else l = m+1;
        }
        return ans;
    }
};
```

## 最小化两个数组中的最大值

**题目：[6295. 最小化两个数组中的最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/minimize-the-maximum-of-two-arrays/)**

```c++
class Solution {
public:
     unsigned long long gcd(unsigned long long a, unsigned long long b)
    {
        return b == 0 ? a : gcd(b, a % b);
    }
    unsigned long long lcm2(unsigned long long a, unsigned long long b)
    {
        return a / gcd(a, b) * b;
    }
    int minimizeSet(int d1, int d2, int u1, int u2) {
        long long l = u1+u2, r = 1e15;
        long long d = lcm2(d1,d2);
        long long ans=0;
        while(l <= r){
            long long m = (l+r) >> 1;
            long long cnt1 = m - m / d1;// 不能被d1整除的数量
            long long cnt2 = m - m / d2; // 不能被d2整除的数量
            long long cnt  = m - m / d1 - m / d2 + m / d ;// 既不能d1整除又不能被d2整除的数量
            cnt1 -= cnt; cnt2 -= cnt;
            if(max(0LL,u1-cnt1)+max(0LL,u2-cnt2) <= cnt) ans = m,r = m-1;
            else l = m+1;
        }
        return ans;
    }
};
```

## 放置盒子（LC 1739）

**题目：[1739. 放置盒子 - 力扣（LeetCode）](https://leetcode.cn/problems/building-boxes/)**

```c++
const int N = 2001 ;
class Solution {
public:
    int a[N] , sum[N] ;
    Solution(){
        memset(a,0,sizeof(a)); memset(sum,0,sizeof(sum)) ;
        for(int i=1;i<=2000;++i){
            a[i] += a[i-1] + i ; 
            sum[i] += sum[i-1] + a[i] ;
        }
    }
    int minimumBoxes(int n) {   
        int l = 1 , r = 2000;
        while(l <= r) {  // 二分寻找层数
            int m = (l+r) >> 1;
            if(sum[m] < n) l = m+1;
            else r = m-1;
        }
        int p = n - sum[l-1] ; int t = a[l-1] ;
        int dis = ceil((sqrt(1+8*p)-1.0) / 2.0) ;  // 解方程
        return t+dis;
    }
};
```

## 同时运行N台电脑的最长时间（LC 2141）

**题目：[2141. 同时运行 N 台电脑的最长时间 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-running-time-of-n-computers/)**

```c++
class Solution {
public:
    typedef long long ll ;
    long long maxRunTime(int n, vector<int>& b) {
        if(b.size() < n) return 0LL ;
        ll sum = 0LL ; 
        for(auto e : b) {sum += e;} 
        ll l = 0LL , r = sum / n , ans;
        while(l <= r) {
            ll m = (l + r) >> 1 ; 
            ll s = 0 ;
            for(auto e : b) s += min((ll)e , m) ;
            if(n * m <= s) l = m + 1 , ans = m ;
            else r = m - 1 ;
        }
        return  ans ;
    }
};
```

## 有界数组中指定下标处的最大值（LC 1802）

**题目：[1802. 有界数组中指定下标处的最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-value-at-a-given-index-in-a-bounded-array/)**

```c++
class Solution {
public:
    typedef long long ll ;
    int maxValue(int n, int index, int maxSum) {
        /*
        4 2 6 : 0,1,2,3  1,2,3,2
        */
        /*
        i:4,v:4,  4:4 ,3:3 , 2:2 ,1:1 ,0:1  v*(1+v)/2 + (i - v + 1) 
        i+1 >= v : 1 1 1....v-2 v-1 v v-1 v-2 ... 
        i+1 <  v : v-i ... v-2 v-1 v v-1 v-2 ...  
        i:2,v:4  , 2:4, 1:3 ,0:2  , (v-i+v)*(i+1)/2 ; 
        n = 10 , i = 4 ,  0 ,1 ,2 ,3, 4, 5, 6, 7, 8, 9
        */
        ll l = 1 , r = maxSum ; ll ans = 1 ;
        while(l <= r){
            ll v = (l + r) >> 1 ;
            ll total = 0 ;
            // 计算前半段
            if(index+1 >= v) total += v * (1 + v) / 2 + (index - v + 1) ;
            else total += (v - index + v) * (index + 1) / 2 ;
            ll j = n + 1 - (index + 1) - 1 ;  // 计算后半段
            if(j+1 >= v) total += v * (1 + v) / 2 + (j - v + 1) ;
            else total += (v - j + v) * (j + 1) / 2 ;
            total -= v ;
            if(total <= maxSum) ans = v , l = v + 1 ;
            else r = v - 1 ;
        }
        return ans ;
    }
};
```

## 最大化城市的最小供电站数目（LC 2528）

**题目：[2528. 最大化城市的最小供电站数目 - 力扣（LeetCode）](https://leetcode.cn/problems/maximize-the-minimum-powered-city/)**

```c++
class Solution {
typedef long long ll ;
public:
    // 树状数组
    int lowbit(int x) {return x & -x ;}
    ll getNum(vector<ll>& tree,int x){
        ll res = 0;
        while(x > 0){
            res += tree[x];
            x -= lowbit(x);
        }
        return res;
    }
    void updata(vector<ll>& tree,int x,ll k){
        int n = tree.size() ;
        while(x < n){
            tree[x] += k;
            x += lowbit(x); 
        }
    }
    void modify(vector<ll>& tree,int x,int y,ll k){
        updata(tree,x,k);
	    updata(tree,y+1,-k);
    }
    ll maxPower(vector<int>& stations, int r, int k) {
        int n = stations.size() ; vector<ll> pix(n) , power(n) , dif(n+1) ;  // 前缀和，电量 , 差分的树状数组
        pix[0] = stations[0] ;
        for(int i=1;i<n;++i) pix[i] = pix[i-1] + stations[i] ;  // 处理前缀和
        for(int i=0;i<n;++i) power[i] = pix[min(n-1,i+r)] - (i - r > 0 ? pix[i-r-1] : 0 ) ;  // 处理每个城市的电量
        ll pre = 0 ;
        for(int i=1;i<=n;++i) updata(dif,i,power[i-1]-pre) , pre = power[i-1] ; // 处理树状数组
        // 二分答案，最小供电站为m时需要多少供电站，如果小于等于 k ，m就符合要求
        auto check = [&](ll m) -> bool {
            ll sum = 0 ; vector<ll> p = dif ; 
            for(int i=1;i<=n;++i) {
                ll temp = getNum(p,i) ;
                if(temp < m) {
                    sum += m - temp ; if(sum > k) return false ;
                    modify(p,i,min(n,2*r+i),m-temp) ;
                }
            }
            return true ;
        };
        ll left = 0 , right = 1e12 , ans = 0 ;
        while(left <= right) {
            ll m = (left + right) >> 1 ;
            if(check(m)) ans = m , left = m + 1 ;
            else right = m - 1 ;
        }
        return ans ;
    }
};
```

## 准时到达的列车的最小时速

**题目;[1870. 准时到达的列车最小时速 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/)**

```c++
class Solution {
public:
    int minSpeedOnTime(vector<int>& dist, double hour) {
        
        auto check = [&](double x){
            double res = 0 ;
            for(int i=0;i<dist.size();++i){
                if(i != dist.size()-1) {
                    res += ceil(dist[i] / x) ;
                }else {
                    res += dist[i] / x ;
                }
            }    
            if(res <= hour) return true ;
            else return false ;
        } ;
        
        if(dist.size() > ceil(hour)) return -1 ; 
        int l = 1 , r = 1e9 ; int ans = INT_MAX ;
        while(l <= r){
            int m = (l + r) >> 1 ;
            if(check(m)) r = m - 1 , ans = min(ans , m) ;
            else l = m + 1 ;
        }

        return ans ; 
    }
};
```

## [两个有序数组的第 K 小乘积](https://leetcode.cn/problems/kth-smallest-product-of-two-sorted-arrays/)

```c++
#include <bits/stdc++.h>
#define debug cout << "__LINE__ : " << __LINE__ - 9 <<endl ;
using namespace std ;

using ll = long long ;
class Solution {
public:
    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {
        auto check = [&](ll x){
            ll res = 0 ; 
            for(int i=0;i<nums1.size();++i){
                int a = nums1[i] ;
                if(a > 0){
                    int L = 0 , R = nums2.size() - 1 ; int t = -1 ;
                    while(L <= R){
                        int m = (L + R) >> 1 ;
                        if(1LL*nums2[m] * a <= x) L = m + 1 , t = m ;
                        else R = m - 1 ;
                    }
                    res += t + 1 ;
                }else if(a < 0){
                    int L = 0 , R = nums2.size() - 1 ; int t = nums2.size() ;
                    while(L <= R){
                        int m = (L + R) >> 1 ;
                        if(1LL*nums2[m] * a <= x) R = m - 1, t = m ;
                        else L = m + 1 ;
                    }
                    res += nums2.size() - t ;
                }else {
                    if(x >= 0) res += nums2.size() ;
                }
            }
            if(res >= k) return true ;
            else return false ;
        } ;
        ll ans = 0 , l = -1e5*1e5 , r = 1e5*1e5 ;
        while(l <= r){
            ll m = (l + r) >> 1 ;
            if(check(m)) ans = m , r = m - 1 ;
            else l = m + 1 ;
        }
        return ans ;
    }
};
```



# 二叉树

## 二叉树的最大路径和（LC 124）

**题目：[124. 二叉树中的最大路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)**

```c++
class Solution {
public:
    int maxPath=INT_MIN;
    int dfs(TreeNode* root){
        if(root==NULL) return 0;
        int left = dfs(root->left);
        int right = dfs(root->right);
        if(left < 0 && right < 0) {
            maxPath = max(maxPath,root->val);
            return root->val;
        }
        if(left < 0) {
            maxPath = max(maxPath,right+root->val);
            return right+root->val;
        }
        if(right < 0) {
            maxPath = max(maxPath,left+root->val);
            return left+root->val;
        }
        maxPath = max(maxPath,left+right+root->val);
        return max(left,right)+root->val;
    }
    int maxPathSum(TreeNode* root) {
        dfs(root);
        return maxPath;
    }
};
```



## 相同的树(LC 100)

**题目：[100. 相同的树 - 力扣（LeetCode）](https://leetcode.cn/problems/same-tree/)**

```c++
class Solution {
public:
    bool isSameTree(TreeNode* p,TreeNode* q){
        if(p==NULL&&q==NULL) return true;
        if(p==NULL||q==NULL) return false;
        if(p->val!=q->val) return false;
        return isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);
    }
};
```



## 对称二叉树(LC 101)

**题目：[101. 对称二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/symmetric-tree/)**

```c++
class Solution {
public:
    bool DFS(TreeNode* root1,TreeNode* root2){
        if(root1==NULL && root2==NULL) return true;
        if(root1==NULL || root2==NULL) return false;
        return root1->val == root2->val && DFS(root1->left,root2->right) && DFS(root2->left,root1->right);
    }
    bool isSymmetric(TreeNode* root) {  
        return DFS(root->left,root->right);
    }
};
```



## 二叉树的锯齿形层序遍历(LC 103)

**题目：[103. 二叉树的锯齿形层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)**

```c++
class Solution {
public:
    int getDepth(TreeNode*root){  // 获取深度
        if(root == NULL) return 0;
        int m = getDepth(root->left);
        int n = getDepth(root->right);
        return m>n? m+1:n+1;
    }
    int cou=0;
    void DFS(TreeNode* root,vector<vector<int>> & v){  // 每一层放进一个vector里面
        if(root == NULL) return;
        v[cou].push_back(root->val);
        cou++;
        DFS(root->left,v);
        DFS(root->right,v);
        cou--;
    }
    vector<vector<int>> v;
    void levelOrder(TreeNode* root) {  // 处理
        int depth = getDepth(root);
        for(int i=0;i<depth;i++){
            vector<int> temp;
            v.push_back(temp);
        }
        DFS(root,v);
    }
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        levelOrder(root);
        for(int i=0;i<v.size();i++){  // 奇数反转
            if(i%2 == 1) reverse(v[i].begin(),v[i].end());
        }
        return v;
    }
};
```



## 二叉树的最大深度(LC 104)

**题目：[104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)**

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == NULL) return 0;
        int m = maxDepth(root->left);
        int n = maxDepth(root->right);
        return max(m+1,n+1);
    }
};
```



## 从前序和中序遍历序列构造二叉树(LC 105)

**题目：[105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)**

```c++
class Solution {
public:
    TreeNode* CreatTree(vector<int>& pre,int l1,int r1,vector<int>& ino,int l2,int r2){
        if((r1<l1) || (r2<l2)) return NULL;
        TreeNode* root = new TreeNode(pre[l1]);
        int mid = l2;
        while(pre[l1]!=ino[mid]) mid++;
        root->left = CreatTree(pre,l1+1,l1+mid-l2,ino,l2,mid-1);
        root->right = CreatTree(pre,l1+mid-l2+1,r1,ino,mid+1,r2);
        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return CreatTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1);
    } 
};
```



## 从后序和中序遍历序列构造二叉树(LC 106)

**题目：[106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)**

```c++
class Solution {
public:
    TreeNode* CreatTree(vector<int>& pos,int l1,int r1,vector<int>& ino,int l2,int r2){
        if((r1<l1) || (r2<l2)) return NULL;
        TreeNode* root = new TreeNode(pos[r1]);
        int mid = l2;
        while(pos[r1]!=ino[mid]) mid++;
        root->left = CreatTree(pos,l1,l1+mid-l2-1,ino,l2,mid-1);
        root->right = CreatTree(pos,l1+mid-l2,r1-1,ino,mid+1,r2);
        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return CreatTree(postorder,0,postorder.size()-1,inorder,0,inorder.size()-1);
    }
};
```



## 平衡二叉树(LC 110)

**题目：[110. 平衡二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/balanced-binary-tree/)**

```c++
class Solution {
public:
    int height(TreeNode* root) {
        if (root == NULL) return 0;
        else return max(height(root->left), height(root->right)) + 1;
    }

    bool isBalanced(TreeNode* root) {
        if (root == NULL) return true;
        else return abs(height(root->left) - height(root->right)) <= 1 && isBalanced(root->left) && isBalanced(root->right);
    }
};
```



## （注意看看）二叉树的最小深度（LC 111）

**题目：[111. 二叉树的最小深度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)**

```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root == NULL) return 0;
        int m1 = minDepth(root->left);
        int m2 = minDepth(root->right);
        //1.如果左孩子和右孩子有为空的情况，直接返回m1+m2+1
        //2.如果都不为空，返回较小深度+1
        return root->left==NULL||root->right==NULL? m1+m2+1:min(m1,m2)+1;
    }
};
```



## 路径总和（LC 112）

**题目：[112. 路径总和 - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum/)**

```c++
class Solution {
public:
    bool hasPathSum(TreeNode *root, int sum) {
        if(root==NULL) return false;
        if(root->left==NULL && root->right==NULL)
            return sum == root->val;
        return hasPathSum(root->left,sum-root->val) ||
               hasPathSum(root->right,sum-root->val);
    }
};
```



## 路径总和 || （LC 113）

**题目：[113. 路径总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum-ii/submissions/)**

```c++
class Solution {
public:
    vector<vector<int>> ret;
    vector<int> path;

    void dfs(TreeNode* root, int targetSum) {
        if (root == nullptr) return;
        path.emplace_back(root->val);
        targetSum -= root->val;
        if (root->left == nullptr && root->right == nullptr && targetSum == 0)
            ret.emplace_back(path);
        dfs(root->left, targetSum);
        dfs(root->right, targetSum);
        path.pop_back();
    }
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        dfs(root, targetSum);
        return ret;
    }
};
```



## （注意看看）二叉树展开成为链表（LC 114）

**题目：[114. 二叉树展开为链表 - 力扣（LeetCode）](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)**

```c++
class Solution {
public:
    vector<int> v;
    void DFS(TreeNode* root){
        if(root == NULL) return;
        v.push_back(root->val);
        DFS(root->left);
        DFS(root->right);
    }
    void clear(TreeNode* &root){  //注意传入引用指针
        if(root == NULL) return;
        clear(root->left);
        clear(root->right);
        delete root;
        root = NULL;
    }
    void flatten(TreeNode* root) {
        if(root==NULL) return;
        DFS(root);
        if(root->left) clear(root->left);
        if(root->right) clear(root->right);
        root->val = v[0];
        for(int i=1;i<v.size();i++){
            root->right = new TreeNode(v[i]);
            root = root->right;
        }   
    }
};
```



## （注意看看）填充每一个节点的下一个右侧节点的指针（LC 116）

**题目：[116. 填充每个节点的下一个右侧节点指针 - 力扣（LeetCode）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)**

```c++
class Solution {
public:
    void levelTravel(Node* root){
        if(root == NULL) return;
        queue<Node*> q;
        q.push(root);
        Node* pre = NULL;  
        while(!q.empty()){  // 层序遍历
            pre = NULL;  // 每一层都置NULL
            int cnt = q.size();  // 记录个数
            for(int i=0;i<cnt;i++){  // 遍历每一层
                if(q.front()->left != NULL)
                    q.push(q.front()->left);
                if(q.front()->right != NULL)
                    q.push(q.front()->right);
                if(pre) 
                    pre->next = q.front();
                pre = q.front();
                q.pop();
            }
        }
    }
    Node* connect(Node* root) {
        levelTravel(root);
        return root;
    }
};
```



## 打家劫舍||| （LC 337）

**题目：[337. 打家劫舍 III - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-iii/)**

```c++
class Solution {
public:
    int* DFS(TreeNode* root){
        if(root == NULL) return new int[2]{0};
        int * result = new int[2]{0};
        int * left = DFS(root->left);
        int * right = DFS(root->right);
        result[0] = max(left[0],left[1])+max(right[0],right[1]);  // 不偷当前节点
        result[1] = left[0]+right[0]+root->val;  // 偷当前节点
        return result;
    }
    int rob(TreeNode* root) {
        int *money=DFS(root);
        return max(money[0],money[1]);
    }
};
```

## [节点与其祖先之间的最大差值](https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/)

```c++
class Solution {
public:
    int ans = 0 ; static const int inf = 1e9 ;
    pair<int,int> dfs(TreeNode* root){
        if(root == nullptr) return {inf,-inf} ;
        auto p1 = dfs(root->left) ;
        auto p2 = dfs(root->right) ;
        int Min = min(p1.first,p2.first) ;
        int Max = max(p1.second,p2.second) ;
        if(Min != inf && Max != -inf){
            ans = max(ans , max(abs(root->val - Min),abs(root->val - Max))) ;
        }else if(Min != inf){
            ans = max(ans , abs(root->val - Min)) ;
        }else if(Max != -inf){
            ans = max(ans , abs(root->val - Max)) ;
        }
        return {min(Min,root->val) , max(Max,root->val)} ;
    }
    int maxAncestorDiff(TreeNode* root) {
        dfs(root) ;
        return ans ;
    }
};
```

## [翻转二叉树以匹配先序遍历](https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/)

```c++
class Solution {
public:
    vector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {
        int n = voyage.size() ; int d = -1 ; 
        bool ok = false ; vector<int> ans ;
        function<void(TreeNode*)> dfs = [&](TreeNode* p){
            if(p == NULL) return ; d ++ ;
            if(p->val != voyage[d]) {ok = true ; return ;}
            if(ok) return ;
            if(p->left && p->left->val != voyage[d+1]) {
                swap(p->left,p->right) ;
                ans.push_back(p->val) ;
            }
            dfs(p->left) ;
            dfs(p->right) ;  
        } ;
        dfs(root) ;
        if(ok) return {-1} ;
        return ans ;
    }
};
```

## [二叉树着色游戏](https://leetcode.cn/problems/binary-tree-coloring-game/)

```c++
class Solution {
public:
    bool btreeGameWinningMove(TreeNode* root, int n, int x) {
        vector<int> siz(n + 1) ; int lc = 0 , rc = 0 ;
        auto dfs = [&](auto dfs,TreeNode* root)
        {
            if(root == nullptr) return 0 ;
            int a = dfs(dfs,root->left) ; int b = dfs(dfs,root->right) ;
            siz[root->val] = a + b + 1 ;
            if(root->val == x) lc = a , rc = b ;
            return siz[root->val] ;
        } ;
        dfs(dfs,root) ;
        int a = siz[root->val] - siz[x] ;
        if(a > siz[x]) return true ;
        if(lc > a + rc) return true ;
        if(rc > a + lc) return true ;
        return false ;
    }
};
```



# 二叉搜索树

## 验证二叉树搜索树(LC 98)

**题目：[98. 验证二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-binary-search-tree/)**

```c++
class Solution {
public:
    bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) return true;
        if (root -> val <= lower || root -> val >= upper) return false;
        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);
    }
};
```



## 恢复二叉搜索树（LC 99）

**题目：[99. 恢复二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/recover-binary-search-tree/)**

```c++
class Solution {
public:
    TreeNode *x = NULL;
    TreeNode *y = NULL;
    TreeNode* pre = NULL;
    void DFS(TreeNode* root){
        if(root == NULL) return;
        DFS(root->left);
        if(pre != NULL && pre->val>=root->val){
            y = root;
            if(x == NULL) x = pre;
        }
        pre = root;
        DFS(root->right);
    }
    void recoverTree(TreeNode* root) {
        DFS(root);
        if(x!=NULL && y!=NULL) {
            int temp = x->val;
            x->val = y->val;
            y->val = temp;
        }
    }
};
```



## 有序数组转换为二叉搜索树（LC 108）

**题目：[108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)**

```c++
class Solution {
public:
    TreeNode* helper(vector<int>& nums, int left, int right) {
        if (left > right) {
            return nullptr;
        }
        // 总是选择中间位置左边的数字作为根节点
        int mid = (left + right) / 2;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = helper(nums, left, mid - 1);
        root->right = helper(nums, mid + 1, right);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return helper(nums, 0, nums.size() - 1);
    }
};
```



## （方法巧妙）有序链表转换为二叉搜索树（LC 109）

**题目：[109. 有序链表转换二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)**

```c++
class Solution {
public:
    int getLength(ListNode* head) {
        int ret = 0;
        for (; head != nullptr; ++ret, head = head->next);
        return ret;
    }

    TreeNode* buildTree(ListNode*& head, int left, int right) {
        if (left > right) return NULL;
        int mid = (left + right) >>1 ;
        TreeNode* root = new TreeNode;
        root->left = buildTree(head, left, mid - 1);
        root->val = head->val;
        head = head->next;
        root->right = buildTree(head, mid + 1, right);
        return root;
    }

    TreeNode* sortedListToBST(ListNode* head) {
        int length = getLength(head);
        return buildTree(head, 0, length - 1);
    }
};
```



## 二叉搜索树中的第K小的元素（LC 230）

**题目：[230. 二叉搜索树中第K小的元素 - 力扣（LeetCode）](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)**

```c++
class Solution {
public:
    TreeNode* helper(TreeNode* root,int &K) {
        if(root==NULL) return NULL;
        TreeNode* right = helper(root->left,K);
        if(right) return right;
        K--;
        if(K<=0) return root;
        TreeNode* left = helper(root->right,K);
        if(left) return left;
        return NULL;
    }
    int kthSmallest(TreeNode* root, int k) {
        TreeNode* node = helper(root,k);
        if(node) return node->val;
        else return 0;
    }
};
```



## 二叉搜索树的最近公共祖先（LC 235）

**题目：[235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)**

```c++
class Solution {
public:
// 通用二叉树寻找公共祖先节点
    queue<TreeNode*> que1;  // 第一个节点的路径
    queue<TreeNode*> que2;  // 第二个节点的路径
    bool isExist(TreeNode* root,TreeNode* target){
        if(root==NULL) return false;
        if(root->val == target->val) return true;
        return isExist(root->left,target) || isExist(root->right,target);
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        TreeNode* temp=root;
        while(temp){  // 遍历p 的路径
            if(isExist(temp->left,p)){
                que1.push(temp);
                temp = temp->left;
            }else if(isExist(temp->right,p)){
                que1.push(temp);
                temp = temp->right;
            }else{  // 找到 p 跳出
                que1.push(temp);
                break;
            }
        }
        temp = root;
        while(temp){  // 遍历q 的路径
            if(isExist(temp->left,q)){
                que2.push(temp);
                temp = temp->left;
            }else if(isExist(temp->right,q)){
                que2.push(temp);
                temp = temp->right;
            }else{
                que2.push(temp);// 找到 q 跳出
                break;
            }
        }
        TreeNode* ans=NULL;
        while(!que1.empty() && !que2.empty()){
            if(que1.front()->val == que2.front()->val){
                ans = que1.front();
                que1.pop();
                que2.pop();
            }else break;  // 遇到第一个不相等的节点就跳出循环
        }
        return ans;
    }
};
```



## 序列化与反序列化二叉搜索树（LC 449）

**题目：[449. 序列化和反序列化二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/serialize-and-deserialize-bst/)**

```c++
class Codec {
public:
    string seq="";  // 先序遍历的结果
    void DFS(TreeNode* root){  // 树转字符串
        if(root==NULL) {seq += "#,";return;}  // '#'代表一个NULL ','代表每个节点的分割
        seq += to_string(root->val);
        seq += ",";
        DFS(root->left);
        DFS(root->right);
    }
    vector<string> v;  // 存储“#”和“Val”  先序遍历存储的
    void  stringToVector(string s){  // 字符串转数组
        for(int i=0;i<s.size();i++){
            string temp="";
            while(s[i]!=','){
                temp.append(1,s[i]);
                i++;
            }
            v.push_back(temp);
        }
    }
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if(root==NULL) return "";
        DFS(root);
        return seq;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if(data == "") return NULL;  // 空树直接返回；
        stringToVector(data);  // 字符串转数组
        TreeNode* root=new TreeNode(stoi(v[0]));  // 开辟根节点
        stack<TreeNode*> st;  // 栈顶为待插入节点的父节点，栈内为右子树还可以操作的节点
        st.push(root);
        for(int i=1;i<v.size();i++){
            if(v[i] == "#"){  // 如果遍历到空节点，一个#就会弹出一个节点
                while(i!=v.size()-1 && v[i+1]=="#"){  // 循环弹栈直到i指向数字的前一个#
                    st.pop();
                    i++;  // 指向下一个
                }
                if(i!=v.size()-1){  // 如果没到结尾，且此时i指向Val的前一个元素
                    st.top()->right = new TreeNode(stoi(v[i+1]));  // 开辟右子树
                    i++;  // 指向Val
                    TreeNode* temp1=st.top();  // 弹栈并且压入右子树
                    st.pop();
                    st.push(temp1->right);
                }
            }else{  // 如果遍历到数Val
                st.top()->left = new TreeNode(stoi(v[i]));
                st.push(st.top()->left);
            }
        }
        return root;  // 返回根节点
    }
};
```



## 删除二叉搜索树中的节点（LC 450）

**题目：[450. 删除二叉搜索树中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-node-in-a-bst/)**

```c++
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root==NULL) return NULL;
        if(root->val > key) root->left = deleteNode(root->left,key);
        else if(root->val < key) root->right = deleteNode(root->right,key);
        else if(root->val == key){
            if(root->left == NULL) return root->right;
            if(root->right == NULL) return root->left;
            TreeNode* node = root->left;  // node一定没有右子树
            TreeNode* pre = root;  // 保证pre的右子树存在
            while(node->right){
                pre = node;
                node = node->right;
            }
            root->val = node->val;
            if(pre->right->val == node->val) pre->right = node->left;
            else pre->left = node->left;
        }
        return root;
    }
};
```



## 二叉搜索树的最小绝对差（LC 530）

**题目：[530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)**

```c++
class Solution {
public:
    vector<int> arr;
    void DFS(TreeNode* root){
        if(root==NULL) return;
        DFS(root->left);
        arr.push_back(root->val);
        DFS(root->right);
    }
    int getMinimumDifference(TreeNode* root) {
        DFS(root);
        vector<int> difference;
        for(int i=0;i<arr.size()-1;i++){
            difference.push_back(arr[i+1]-arr[i]);
        }
        auto Min = *min_element(difference.begin(),difference.end());
        return Min;
    }
};
```



## 把二叉搜索树转换为累加树（LC 538）

**题目：[538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-bst-to-greater-tree/)**

```c++
class Solution {
public:
    int sum=0;
    void DFS(TreeNode* root){  // 遍历顺序：右子树 -> 根节点 -> 左子树
        if(root==NULL) return;
        DFS(root->right);
        sum += root->val;
        root->val = sum;
        DFS(root->left);
    }
    TreeNode* convertBST(TreeNode* root) {
        DFS(root);
        return root;
    }
};
```



## 修剪二叉搜索树（LC 669）

**题目：[669. 修剪二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/trim-a-binary-search-tree/)**

```c++
class Solution {
    public:
    TreeNode* trimBST(TreeNode* root, int L, int R) {
        if (root == NULL) return root;
        if (root->val < L)
            return trimBST(root->right, L, R);//返回修剪过的右子树。
        if (root->val > R)
            return trimBST(root->left, L, R);//返回修剪过的左子树。
        root->left = trimBST(root->left, L, R);
        root->right = trimBST(root->right, L, R);
        return root;
    }
};
```



## 二叉搜索树的插入操作（LC 701）

**题目：[701. 二叉搜索树中的插入操作 - 力扣（LeetCode）](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)**

```c++
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root==NULL) return new TreeNode(val);
        if(root->val>val) root->left=insertIntoBST(root->left,val);
        if(root->val<val) root->right=insertIntoBST(root->right,val);
        return root;
    }
};
```



## 递增顺序搜索树（LC 897）

**题目：[897. 递增顺序搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/increasing-order-search-tree/)**

```c++
class Solution {
public:
    TreeNode* pre = new TreeNode(-1);
    TreeNode* node = pre;
    void DFS(TreeNode* root){
        if(root==NULL) return;
        DFS(root->left);
        pre->right = root;
        root->left=NULL;
        pre = root;
        DFS(root->right);
    }
    TreeNode* increasingBST(TreeNode* root) {
        DFS(root);
        if(root==NULL) return NULL;
        return node->right;
    }
};
```



## 前序遍历构造二叉搜索树（LC 1008）

**题目：[1008. 前序遍历构造二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/)**

```c++
class Solution {
public:
    TreeNode* insert(TreeNode* root,int val){
        if(root==NULL) return new TreeNode(val);
        if(root->val>val) root->left=insert(root->left,val);
        else if(root->val<val) root->right=insert(root->right,val);
        return root;
    }
    TreeNode* bstFromPreorder(vector<int>& preorder) {
        TreeNode* root=NULL;
        for(int i=0;i<preorder.size();i++){
            root = insert(root,preorder[i]);
        } 
        return root;
    }
};
```



## 两棵二叉树中的所有元素（LC 1305）

**题目：[1305. 两棵二叉搜索树中的所有元素 - 力扣（LeetCode）](https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/)**

```c++
class Solution {
public:
    void mid(TreeNode* root, vector<int> &v) {
        if(root) {
            if(root->left) mid(root->left, v);
            v.push_back(root->val);
            if(root->right) mid(root->right, v);
        }
    }
    vector<int> getAllElements(TreeNode* root1, TreeNode* root2) {
        vector<int> v1, v2, ret;
        mid(root1, v1);
        mid(root2, v2);
        merge(v1.begin(),v1.end(), v2.begin(), v2.end(), back_inserter(ret));
        return ret;
    }
};
```



## 将二叉树变平衡（LC 1382）

**题目：[1382. 将二叉搜索树变平衡 - 力扣（LeetCode）](https://leetcode.cn/problems/balance-a-binary-search-tree/)**

```c++
class Solution {
public:
    vector<int> arr;
    void inorder(TreeNode* root){
        if(root==NULL) return;
        inorder(root->left);
        arr.push_back(root->val);
        inorder(root->right);
    }
    TreeNode* creatBST(vector<int>& arr,int low,int high){
        if(low>high) return NULL;
        int mid = (low+high)/2;
        TreeNode* root = new TreeNode(arr[mid]);
        root->left = creatBST(arr,low,mid-1);
        root->right = creatBST(arr,mid+1,high);
        return root;
    }
    TreeNode* balanceBST(TreeNode* root) {
        inorder(root);
        TreeNode* node=creatBST(arr,0,arr.size()-1);
        return node;
    }
};
```



# 平衡树

[P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)

[P6136 【模板】普通平衡树（数据加强版）](https://www.luogu.com.cn/problem/P6136)

[P3391 【模板】文艺平衡树](https://www.luogu.com.cn/problem/P3391)

[P3380 【模板】二逼平衡树（树套树）](https://www.luogu.com.cn/problem/P3380)

[P3835 【模板】可持久化平衡树 ](https://www.luogu.com.cn/problem/P3835)

[P5055 【模板】可持久化文艺平衡树 ](https://www.luogu.com.cn/problem/P5055)

## 书架（LG P2596）

**题目：[P2596 [ZJOI2006\]书架 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2596)**

```c++
#include <bits/stdc++.h>
#define lc(x) tr[x].lc
#define rc(x) tr[x].rc
#define pri(x) tr[x].pri
#define val(x) tr[x].val  // 代表节点x的权值
#define siz(x) tr[x].siz
#define id(x) tr[x].id
using namespace std ;
const int N = 2e5+10 ; 
int root , idx , val[N] ; int n , m ;  // 代表编号i的权值
struct node{int lc , rc , pri , val , id , siz;} tr[N] ; // FHQ Treap
void pushup(int p){
    siz(p) = siz(lc(p)) + siz(rc(p)) + 1 ;
}
int merge(int x,int y){
    if(!x || !y) return x + y ;
    if(pri(x) > pri(y)){
        rc(x) = merge(rc(x),y) ; pushup(x) ; return x ;
    } else {
        lc(y) = merge(x,lc(y)) ; pushup(y) ; return y ;
    }
}
void spilt(int p ,int& x,int& y,int val){
    if(!p) {x = y = 0 ; return ;}
    if(val(p) <= val) {
        x = p ; spilt(rc(x),rc(x),y,val) ; pushup(x) ; return ;
    } else {
        y = p ; spilt(lc(y),x,lc(y),val) ; pushup(y) ; return ;
    }
}
void insert(int val,int id){  
    int x , y , z ; tr[++idx] = {0,0,rand(),val,id,1} ; z = idx ;
    spilt(root,x,y,val) ; root = merge(merge(x,z),y) ;
}
int Kth(int p,int k){  // 返回排名k的编号
    if(!p) return 0 ;
    if(siz(lc(p)) >= k) return Kth(lc(p),k) ;
    else if(siz(lc(p)) + 1 == k) return p ;
    else return Kth(rc(p),k - siz(lc(p)) - 1) ;
}
int get_rank(int val){  // 返回val的排名(比val小的个数+1)
    int x , y , z ; 
    spilt(root,x,y,val-1) ; int rank_t = siz(x) + 1 ;
    root = merge(x,y) ; return rank_t ;
}
void inorder(int p){
    if(!p) return ;
    inorder(lc(p)) ;
    cout << id(p) << " " ;
    inorder(rc(p)) ;
}
int main() {
    scanf("%d %d",&n,&m) ; int l = 1 , r = n ;
    int x , y , z , x1 , y1 , z1 , s , t , id , pre , nex , now , k ; string op ; // 全是临时变量
    for(int i=1;i<=n;++i) {scanf("%d",&id) ; insert(i,id) ; val[id] = i ;}
    //inorder(root) ; cout << endl ;
    while(m--){
        cin >> op ; 
        if(op == "Top"){
            scanf("%d",&id) ;
            spilt(root,x,y,val[id]) ; spilt(x,x,z,val[id]-1) ;
            val(z) = -- l ; val[id] = l ; root = merge(merge(z,x),y) ;
            //inorder(root) ; cout << endl ;
        } else if(op == "Bottom"){
            scanf("%d",&id) ;
            spilt(root,x,y,val[id]) ; spilt(x,x,z,val[id]-1) ;
            val(z) = ++ r ; val[id] = r ; root = merge(merge(x,y),z) ;
            //inorder(root) ; cout << endl ;
        } else if(op == "Insert"){
            cin >> id >> t ;
            if(t == -1) {
                spilt(root,x,y,val[id]-1) ; pre = Kth(x,siz(x)) ; now = Kth(y,1) ;
                if(!pre) continue ;
                swap(val(now) , val(pre)) ;
                spilt(x,x,x1,val(pre)-1) ; spilt(y,y1,y,val(now)) ;  // 注意这里的操作
                root = merge(merge(x,y1),merge(x1,y)) ;
                swap(val[id(now)], val[id(pre)]) ;
            } else if(t == 1){
                spilt(root,x,y,val[id]) ; nex = Kth(y,1) ; now = Kth(x,siz(x)) ;
                if(!nex) continue ;
                swap(val(now) , val(nex)) ; 
                spilt(x,x,x1,val(now)-1) ; spilt(y,y1,y,val(nex)) ; // 注意这里的操作
                root = merge(merge(x,y1),merge(x1,y)) ;
                swap(val[id(now)], val[id(nex)]) ;
            }
            //inorder(root) ; cout << endl ;
        } else if(op == "Ask") {
            scanf("%d",&id) ;
            printf("%d\n",get_rank(val[id]) - 1) ;
        } else if(op == "Query") {
            scanf("%d",&k) ;
            printf("%d\n",id(Kth(root,k))) ;
        }
    }
    system("pause") ;
}

```

## 甲苯先生的滚榜（LG P5338）

**题目：[P5338 [TJOI2019\]甲苯先生的滚榜 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5338)**

```c++
#include <bits/stdc++.h>
#define lc(x) tr[x].lc
#define rc(x) tr[x].rc
#define pri(x) tr[x].pri
#define val(x) tr[x].val 
#define siz(x) tr[x].siz
#define id(x) tr[x].id
using namespace std ;
typedef unsigned int ui ;
const int N = 2e6 + 10 ;
int n , T , ria , rib ; ui seed , last = 7 , m ;
ui randNum( ui& seed , ui last , const ui m){ 
    seed = seed * 17 + last ; return seed % m + 1; 
}
int root , idx , penal[N] , AC[N] ;
struct node{
    int pen,ac ;
} ;
bool cmp(node& e1,node& e2){ // e1 >= e2 
    return e1.ac==e2.ac? e1.pen>=e2.pen : e1.ac<e2.ac ;
}
struct qwq{int lc , rc , pri , siz; node val;} tr[N] ; // FHQ Treap
void pushup(int p){
    siz(p) = siz(lc(p)) + siz(rc(p)) + 1 ;
}
int merge(int x,int y){
    if(!x || !y) return x + y ;
    if(pri(x) > pri(y)){
        rc(x) = merge(rc(x),y) ; pushup(x) ; return x ;
    } else {
        lc(y) = merge(x,lc(y)) ; pushup(y) ; return y ;
    }
}
void spilt(int p ,int& x,int& y,node val){
    if(!p) {x = y = 0 ; return ;}
    if(cmp(val,val(p))) {
        x = p ; spilt(rc(x),rc(x),y,val) ; pushup(x) ; return ;
    } else {
        y = p ; spilt(lc(y),x,lc(y),val) ; pushup(y) ; return ;
    }
}
void insert(node val){  
    int x , y , z ; tr[++idx] = {0,0,rand(),1,val} ; z = idx ;
    spilt(root,x,y,val) ; root = merge(merge(x,z),y) ;
}
void del(node val){
    int x , y , z ;
    spilt(root,x,y,val) ; spilt(x,x,z,{val.pen-1,val.ac}) ;
    z = merge(lc(z),rc(z)) ; root = merge(merge(x,z),y) ;
}
int Kth(int p,int k){  // 返回排名k的编号
    if(!p) return 0 ;
    if(siz(lc(p)) >= k) return Kth(lc(p),k) ;
    else if(siz(lc(p)) + 1 == k) return p ;
    else return Kth(rc(p),k - siz(lc(p)) - 1) ;
}
int get_rank(node val){  // 返回val的排名(比val小的个数+1)
    int x , y , z ; 
    spilt(root,x,y,{val.pen-1,val.ac}) ; int rank_t = siz(x) + 1 ;
    root = merge(x,y) ; return rank_t ;
}
void inorder(int p){
    if(!p) return ;
    inorder(lc(p)) ;
    cout << val(p).ac << " " <<val(p).pen << " || " ;
    inorder(rc(p)) ;
}
int main() {
    scanf("%d",&T) ; while(T--) {
    scanf("%d %d %d",&m,&n,&seed) ;
    idx = 0 ; root = 0 ; memset(penal,0,sizeof(penal)) ; memset(AC,0,sizeof(AC)) ;
    for(int i=1;i<=n;++i){
        ria = randNum(seed,last,m) ; 
        rib = randNum(seed,last,m) ;
        del({penal[ria] , AC[ria]}) ;
        penal[ria] += rib ; AC[ria] += 1 ;
        insert({penal[ria] , AC[ria]}) ;
        //inorder(root) ; cout << endl ;
        last = get_rank({penal[ria] , AC[ria]}) - 1 ;
        printf("%d\n",last) ;
    }
    }
    system("pause") ;
}

```

## 序列终结者（LG P4146）

**题目：[P4146 序列终结者 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4146)**

```c++
#include <bits/stdc++.h>
#define cin(x) cin >> x ;
#define cout(x) cout << x << endl ;
#define lc(x) tr[x].lc
#define rc(x) tr[x].rc
#define pri(x) tr[x].pri
#define val(x) tr[x].val
#define siz(x) tr[x].siz
#define add(x) tr[x].add
#define rev(x) tr[x].rev
#define mx(x) tr[x].mx 
#define int long long
using namespace std ;
const int N = 2e6 + 10 ;
typedef long long ll ;
/*--------------变量-------------------*/
int n , m ;
/*--------------FHQ Treap--------------*/
int root , idx , mx[N] ;  // mx[i] 子树i的最大值
struct qwq{int lc,rc,pri,val,siz,add,rev,mx;} tr[N] ;
void pushup(int p){
    siz(p) = siz(lc(p)) + siz(rc(p)) + 1 ;
    mx(p) = val(p) ;
    if(lc(p)) mx(p) = max(mx(p) , mx(lc(p))) ;  // 防止最大值为负数访问到空节点
    if(rc(p)) mx(p) = max(mx(p) , mx(rc(p))) ;
}
void pushdown(int p) {
    if(rev(p)) {
        swap(lc(p),rc(p)) ;
        rev(lc(p)) ^= 1 ; rev(rc(p)) ^= 1 ;
        rev(p) = 0 ;
    }
    if(add(p)) {
        if(lc(p)) add(lc(p)) += add(p) , val(lc(p)) += add(p) , mx(lc(p)) += add(p) ;
        if(rc(p)) add(rc(p)) += add(p) , val(rc(p)) += add(p) , mx(rc(p)) += add(p) ;
        add(p) = 0 ;
        //pushup(p) ;
    }
}
void spilt(int p,int& x,int& y,int k){ // 根据排名小于等于k的在x
    if(!p) {x = y = 0 ; return ;}
    pushdown(p) ;
    if(siz(lc(p)) + 1 <= k){
        x = p ; spilt(rc(x),rc(x),y,k-siz(lc(p))-1) ; pushup(x) ; return ;
    } else {
        y = p ; spilt(lc(y),x,lc(y),k) ; pushup(y) ; return ;
    }
}
int merge(int x,int y){
    if(!x || !y) return x+y;
    pushdown(x) ; pushdown(y) ;  // 下次注意了，两个都要写
    if(pri(x) < pri(y)) {
        rc(x) = merge(rc(x),y);
        pushup(x) ; return x ;
    }else{
        lc(y) = merge(x,lc(y));
        pushup(y) ; return y ;
    }
}
/*--------------main------------------*/
signed main(){
    int k , l , r , v , op , x , y , z ; cin(n) ; cin (m) ;
    for(int i=1;i<=n;++i) {
        x = ++idx ; tr[x] = {0,0,rand(),0,1,0,0,0} ; root = merge(root,x) ;
    }
    while(m--) {
        cin(op) ; cin(l) ; cin(r) ;
        if(op == 1) {
            cin(v) ;
            spilt(root,x,y,r) ; spilt(x,x,z,l-1) ;
            add(z) += v ; val(z) += v ; mx(z) += v ;
            root = merge(merge(x,z),y) ;
        } else if(op == 2) {
            spilt(root,x,y,r) ; spilt(x,x,z,l-1) ;
            rev(z) ^= 1 ; root = merge(merge(x,z),y) ;
        } else if(op == 3) {
            spilt(root,x,y,r) ; spilt(x,x,z,l-1) ;
            cout(mx(z)) ; root = merge(merge(x,z),y) ;
        }
    }
    system("pause") ;
}
```

## 总统选举（LG P3765）

**题目：[P3765 总统选举 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3765)**

```c++
#include <bits/stdc++.h>
#define cin(x) cin >> x
#define cout(x) cout << x << endl
#define Print for(int i=1;i<=n;++i) cout << vote[i] << " " ; cout << endl 
#define int long long
using namespace std ;
const int N = 2e6 + 10 ;
typedef long long ll ;
/*--------------变量-------------------*/
int n , m ; int vote[N] ; // 每个人的投票
/*--------------线段树-----------------*/
namespace Seg{
    #define ls (p << 1) 
    #define rs (p << 1 | 1)
    int mode[N << 2] , cnt[N << 2] ;  // 线段树的众数和出现的次数,用抵消方法，可以满足区间可加性
    void pushup(int p){
        if(mode[ls] == mode[rs]) mode[p] = mode[ls] , cnt[p] = cnt[ls] + cnt[rs] ;
        else{
            if(cnt[ls] >= cnt[rs]) mode[p] = mode[ls] , cnt[p] = cnt[ls] - cnt[rs] ;
            else mode[p] = mode[rs] , cnt[p] = cnt[rs] - cnt[ls] ;
        }
    }
    void build(int p,int l,int r){
        if(l == r) {mode[p] = vote[l] ; cnt[p] = 1 ; return ;}
        int m = l + r >> 1 ;
        build(ls,l,m) ; build(rs,m+1,r) ;
        pushup(p) ;
    }
    struct node{int m,c;} ;
    node query(int p,int l,int r,int x,int y){  // 返回最有可能是区间众数的人
        if(x <= l && y >= r) return {mode[p],cnt[p]} ;
        int m = l + r >> 1 ;
        if(x > m) return query(rs,m+1,r,x,y) ;
        else if(y <= m) return query(ls,l,m,x,y) ;
        else {
            node a = query(ls,l,m,x,y) ;
            node b = query(rs,m+1,r,x,y) ;
            if(a.m == b.m) return {a.m,a.c+b.c} ;
            else {
                if(a.c >= b.c) return {a.m , a.c - b.c} ;
                else return {b.m , b.c - a.c} ;
            }
        }
    }
    void updata(int p,int l,int r,int pos,int x) {  // 将pos人变成支持x
        if(l == r) {
            vote[l] = x ;
            mode[p] = vote[l] ; cnt[p] = 1 ;
            return ; 
        }
        int m = l + r >> 1 ;
        if(pos <= m) updata(ls,l,m,pos,x) ;
        else updata(rs,m+1,r,pos,x) ;
        pushup(p) ;
    }
}
/*--------------FHQ Treap--------------*/
namespace Treap{
    #define lson(x) tr[x].lson
    #define rson(x) tr[x].rson
    #define pri(x) tr[x].pri
    #define val(x) tr[x].val
    #define siz(x) tr[x].siz
    int root[N] , idx ;  // 每个人都开一个Treap
    struct qwq{int lson,rson,pri,val,siz;} tr[N] ;
    void pushup(int p){
        siz(p) = siz(lson(p)) + siz(rson(p)) + 1 ;
    }
    void spilt(int p,int& x,int& y,int val){
        if(!p) {x = y = 0 ; return ;}
        if(val(p) <= val){
            x = p ; spilt(rson(x),rson(x),y,val) ; pushup(x) ; return ;
        } else {
            y = p ; spilt(lson(y),x,lson(y),val) ; pushup(y) ; return ;
        }
    }
    int merge(int x,int y){
        if(!x || !y) return x+y;
        if(pri(x) < pri(y)) {
            rson(x) = merge(rson(x),y);
            pushup(x) ; return x ;
        }else{
            lson(y) = merge(x,lson(y));
            pushup(y) ; return y ;
        }
    }
    int x , y , z ; 
    void insert(int& root,int val){
        z = ++idx ; tr[z] = {0,0,rand(),val,1} ;
        spilt(root,x,y,val) ; 
        root = merge(merge(x,z),y) ;
    }
    void del(int& root,int val) {
        spilt(root,x,y,val) ; spilt(x,x,z,val-1) ;
        z = merge(lson(z),rson(z)) ; root = merge(merge(x,z),y) ;
    }
    int get_rank(int& root,int val){
        spilt(root,x,y,val) ; if(!x) return 0 ;
        int rank_t = siz(x); 
        root = merge(x,y) ; return rank_t ;
    }
    void inorder(int root){
        if(!root) return ;
        inorder(lson(root)) ;
        cout << val(root) << " " ;
        inorder(rson(root)) ;
    }
} ; 
/*--------------main------------------*/
signed main(){
    int l , r , s , k , x , y , z ;
    cin(n) ; cin(m) ;
    for(int i=1;i<=n;++i) {
        cin(x) ; Treap::insert(Treap::root[x],i) ; vote[i] = x ;
    }
    Seg::build(1,1,n) ;
    while(m--) {
        cin(l) ; cin(r) ; cin(s) ; cin(k) ;
        Seg::node a = Seg::query(1,1,n,l,r) ;
        x = Treap::get_rank(Treap::root[a.m],r) ; y = Treap::get_rank(Treap::root[a.m],l-1) ;
        if((x - y) > (r - l + 1) / 2) s = a.m ;
        //Print ; Treap::inorder(Treap::root[a.m]) ; cout << endl ;
        //cout << a.m << " " << x << " " << y << endl ;
        for(int i=1;i<=k;++i) {
            cin(y) ; 
            Treap::insert(Treap::root[s],y) ; Treap::del(Treap::root[vote[y]],y) ; 
            Seg::updata(1,1,n,y,s) ;
        }
        cout(s) ;    
        //cout << "---------------------------------------" << endl ;
    }
    Seg::node a = Seg::query(1,1,n,1,n) ;
    x = Treap::get_rank(Treap::root[a.m],n) ;
    if(x > n / 2) cout(x) ;
    else cout(-1) ;
    system("pause") ;
}
```

## 求出MK平均值

**题目;[1825. 求出 MK 平均值 - 力扣（LeetCode）](https://leetcode.cn/problems/finding-mk-average/)**

```c++
class Treap{
private:
    struct node{
        node* lc ; 
        node* rc ;
        int pri,val,siz;
        long long sum  ;
        node(int _val){
            lc = rc = nullptr ;
            pri = rand() ; val = _val ; siz = 1 ;
            sum = _val ;
        }
    } ;
    node* root ;
    int siz ;
public:
    Treap(){root = nullptr ; siz = 0 ;}
    void up(node* p){
        if(!p) return ;
        if(p->lc && p->rc) {
            p->sum = p->lc->sum + p->rc->sum + p->val ;
            p->siz = p->lc->siz + p->rc->siz + 1 ;
        } else if(p->lc){
            p->sum = p->lc->sum + p->val ;
            p->siz = p->lc->siz + 1 ;
        } else if(p->rc){
            p->sum = p->rc->sum + p->val ;
            p->siz = p->rc->siz + 1 ;
        } else {
            p->sum = p->val ;
            p->siz = 1 ;
        }
    }
    node* merge(node* x,node* y){
        if(!x) return y ;
        if(!y) return x ;
        if(x->pri > y->pri){
            x->rc = merge(x->rc , y) ;
            up(x) ;
            return x ;
        } else {
            y->lc = merge(x , y->lc) ;
            up(y) ;
            return y ;
        }
        return nullptr ;
    }

    void spilt(node* p,node*& x,node*& y,int val){
        if(!p){
            x = y = nullptr ; return ;
        }
        if(p->val <= val){
            x = p ; spilt(x->rc,x->rc,y,val) ; up(p) ; return ;
        } else {
            y = p ; spilt(y->lc,x,y->lc,val) ; up(p) ; return ;
        }
    }

    void add(int val) {
        siz ++ ;
        node* x ; node* y ;
        node* z = new node(val) ; 
        spilt(root,x,y,val) ;
        root = merge(merge(x,z),y) ;
        return ;
    }

    void del(int val) {
        siz -- ;
        node* x ; node* y ; node* z ;
        spilt(root,x,y,val) ;
        spilt(x,x,z,val-1) ;
        node* t = z ; 
        z = merge(z->lc,z->rc) ;
        delete t ;
        root = merge(merge(x,z),y) ;
        return ;
    }

    int size(){
        return siz ;
    }

    node* getK(node* p,int k){
        if(!p) return nullptr ;
        if(!p->lc) {
            if(k == 1) return p ;
            return getK(p->rc , k - 1) ;
        }
        if(p->lc->siz + 1 == k) return p ;
        else if(p->lc->siz >= k){
            return getK(p->lc , k) ;
        } else {
            return getK(p->rc , k - p->lc->siz - 1) ;
        }
    }

    int get(int m , int k){
        long long sum = 0 ;
        node* p1 = getK(root,k) ;
        node* p2 = getK(root,m-k+1) ;
        node* x ;  node* y ;
        spilt(root,x,y,p1->val - 1) ;
        if(x) {
            sum += x->sum ;
            if(x->siz < k){
                sum += p1->val * (k - x->siz) ;
            } 
        }else{
            sum += p1->val * k ;
        }
        root = merge(x,y) ;
        spilt(root,x,y,p2->val) ;
        if(y) {
            sum += y->sum ;
            if(y->siz < k){
                sum += p2->val * (k - y->siz) ;
            }
        }else{
            sum += p2->val * k ;
        }
        root = merge(x,y) ;
        return sum ;
    }

    void output(){
        function<void(node*)> output1 = [&](node* rt){
            if(rt == nullptr) return ;
            output1(rt->lc) ; 
            cout << rt->val << " " ;
            output1(rt->rc) ;
        } ;
        output1(root) ; cout << endl ;
    }
} ;

class MKAverage {
private:
    int m , k ;
    long long sum ; 
    Treap root ;
    deque<int> dq ;
public:
    MKAverage(int m, int k) {
        this->m = m ; 
        this->k = k ;
        sum = 0 ;
        dq = deque<int>() ;
        root = Treap() ;
    }
    
    void addElement(int num) {
        if(root.size() < m){
            sum += num ;
            root.add(num) ;
            dq.push_back(num) ;
            return ;
        }
        sum += num ;
        dq.push_back(num) ;
        root.add(num) ;
        root.del(dq.front()) ;
        sum -= dq.front() ;
        dq.pop_front() ;
    }
    
    int calculateMKAverage() {
        if(root.size() < m) return -1 ;
        return ( sum - root.get(m,k) ) / (m - 2 * k) ;
    }
};

/**
 * Your MKAverage object will be instantiated and called as such:
 * MKAverage* obj = new MKAverage(m, k);
 * obj->addElement(num);
 * int param_2 = obj->calculateMKAverage();
 */
```

# 树状数组

## lowbit理解

**题目：[F-清楚姐姐学树状数组_2023牛客寒假算法基础集训营4 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/46812/F)**

```c++
#include <bits/stdc++.h>
#define debug cout << "__LINE__" << __LINE__ < endl ;
#define int long long
using namespace std ;
using ll = long long ;

int root ;
int lowbit(int x){ return x & -x ; }
int rc(int x)
{
	if(lowbit(x) == 1|| x == root) return 0 ;
	return x ^ (lowbit(x) >> 1) ;
}
int lc(int x)
{
	if(lowbit(x) == 1) return 0 ;
	return x ^ lowbit(x) ^ (lowbit(x) >> 1) ;
}
int fa(int x)
{
	return !(x & (lowbit(x) << 1)) ? x + lowbit(x) : x - lowbit(x) ;
}
int size(int x)
{
	if(x == 0) return 0 ;
	if(x == root) return x ;
	return (lowbit(x) << 1) - 1 ;
}
int getpre(int x)
{
	int p = root ; int res = 0 ; 
	while(p != x)
	{
		if(x < p) p = lc(p) , res ++ ;
		else
		{
			res += size(lc(p)) + 1 ; 
			p = rc(p) ;
		}
	}
	return res + 1 ;
}
int getpos(int x)
{
	int p = root ; int res = 0 ;
	while(p != x)
	{
		if(x < p) p = lc(p) ;
		else 
		{
			res += size(lc(p)) ;
			p = rc(p) ;
		}
	}
	return res + size(x) ;
}
void solve(){
	int k , q ; cin >> k >> q ; root = 1LL << k ;

	for(int i = 0; i < q; ++i)
	{
		int x ; cin >> x ;
		cout << getpre(x) << " " << x << " " << getpos(x) << endl ;
	} 
}

signed main(){
	ios::sync_with_stdio(false) ; cin.tie(nullptr) ; cout.tie(nullptr) ;

	int t = 1 ; // cin >> t ;
	while( t -- )
    {
		solve() ;
	}

	return 0 ;
}
```

## 简单题

**题目：[P5057 [CQOI2006\]简单题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5057)**

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std ;
const int N = 1e5+10 ; 
int n , m ; int c[N] ;
#define lowbit(x) (x&-x)
int getsum(int x){
    int res = 0 ; 
    while(x > 0){
        res ^= c[x] ;
        x -= lowbit(x) ;
    }
    return res ;
}
void modify(int x){
    while(x <= n){
        c[x] ^= 1 ;
        x += lowbit(x) ;
    }
}
void updata(int x,int y){
    modify(x) ; modify(y+1) ;
}
signed main(){
    cin >> n >> m ; int op , a , b , pre = 0 ; 
    while(m--){
        cin >> op >> a ;
        if(op == 1){
            cin >> b ; updata(a,b) ;
        }else{
            cout << getsum(a) << endl ;
        }
    }
    system("pause") ;
}
```

## 【典】函数维护

**题目：[P4145 上帝造题的七分钟 2 / 花神游历各国 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4145)**

```c++
// DSU
#include <bits/stdc++.h>
#define maxn 100100
#define ll long long
using namespace std;
ll tree[maxn*4],a[maxn];int fa[maxn],m,n,q,l,r,t;
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}//并查集，路径压缩
void add(int x,ll y){while(x<=n)tree[x]+=y,x+=(x&-x);}
ll qry(int x){ll r=0;while(x)r+=tree[x],x-=(x&-x);return r;}
int main(){
	scanf("%d",&n);for (int i=1;i<=n;i++)
	scanf("%lld",&a[i]),add(i,a[i]),fa[i]=i;scanf("%d",&m);fa[n+1]=n+1;
	while(m--){scanf("%d%d%d",&q,&l,&r);if (l>r) swap(l,r); 
		if (q==1) printf("%lld\n",qry(r)-qry(l-1));
		else for (int i=l;i<=r;add(i,(t=(int)sqrt(a[i]))-a[i]),a[i]=t,fa[i]=(a[i]<=1)?i+1:i,i=(find(i)==i)?i+1:fa[i]);
	}
    //上面这行信息量很大。。。做了单点修改的操作，a数组保存了每个点的实际值，当a[i]<=1的时候，直接跳到下一个点，结束。可以手算一下，就能很快理解了。
}
```



# 线段树

## 统计和

**题目：[P2068 统计和 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2068)**

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std ;
const int N = 1e5+10 ; 
int n , m ; 
#define lc (p << 1)
#define rc (p << 1 | 1)
int sum[N << 2] ;
void updata(int p,int l,int r,int x,int k){
   if(l == r) {
       sum[p] += k ; return ;
   } 
   int m = l + r >> 1 ;
   if(x <= m) updata(lc,l,m,x,k) ;
   else updata(rc,m+1,r,x,k) ;
   sum[p] = sum[lc] + sum[rc] ;
}
int query(int p,int l,int r,int x,int y){
    if(x <= l && y >= r) return sum[p] ;
    int m = l + r >> 1 ; int res = 0 ;
    if(x <= m) res += query(lc,l,m,x,y) ;
    if(y > m) res += query(rc,m+1,r,x,y) ;
    return res ;
}
signed main(){
    cin >> n >> m ; char op ; int a , b ; 
    while(m--){
        cin >> op >> a >> b ;
        if(op == 'x'){
            updata(1,1,n,a,b) ;
        }else{
            cout << query(1,1,n,a,b) << endl ;
        }
    }
    system("pause") ;
}
```

## I Hate It

**题目;[P1531 I Hate It - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1531)**

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std ;
const int N = 2e5+10 ; 
int n , m ; int num[N] ;
#define lc (p << 1)
#define rc (p << 1 | 1)
int ma[N << 2] ;
void build(int p,int l,int r){
    if(l == r) {ma[p] = num[l] ; return ;}
    int m = l + r >> 1 ;
    build(lc,l,m) ; build(rc,m+1,r) ;
    ma[p] = max(ma[lc],ma[rc]) ;
}
void updata(int p,int l,int r,int x,int k){
   if(l == r) {
       ma[p] = max(ma[p],k) ; return ;
   } 
   int m = l + r >> 1 ;
   if(x <= m) updata(lc,l,m,x,k) ;
   else updata(rc,m+1,r,x,k) ;
   ma[p] = max(ma[lc] , ma[rc]) ;
}
int query(int p,int l,int r,int x,int y){
    if(x <= l && y >= r) return ma[p] ;
    int m = l + r >> 1 ; int res = 0 ;
    if(x <= m) res = max(res,query(lc,l,m,x,y)) ;
    if(y > m) res = max(res,query(rc,m+1,r,x,y)) ;
    return res ;
}
signed main(){
    cin >> n >> m ; char op ; int a , b ; 
    for(int i=1;i<=n;++i) cin >> num[i] ;
    build(1,1,n) ;
    while(m--){
        cin >> op >> a >> b ;
        if(op == 'U'){
            updata(1,1,n,a,b) ;
        }else{
            cout << query(1,1,n,a,b) << endl ;
        }
    }
    system("pause") ;
}
```

## 【典】最大值最小值维护

**题目：[P2880 [USACO07JAN\] Balanced Lineup G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2880)**

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std ;
const int N = 1e5+10 ; 
int n , m ; int num[N] ;
#define lc (p << 1)
#define rc (p << 1 | 1)
int ma[N << 2] , mi[N << 2] ;
void build(int p,int l,int r){
    if(l == r) {ma[p] = mi[p] = num[l] ; return ;}
    int m = l + r >> 1 ;
    build(lc,l,m) ; build(rc,m+1,r) ;
    ma[p] = max(ma[lc],ma[rc]) ;
    mi[p] = min(mi[lc],mi[rc]) ;
}
struct node{int ma,mi;};
node query(int p,int l,int r,int x,int y){
    if(x <= l && y >= r) return {ma[p],mi[p]} ;
    int m = l + r >> 1 ; int a = 0 , b = 1e9 ;
    if(x <= m) {
        auto nod = query(lc,l,m,x,y) ; 
        a = max(nod.ma,a) ; b = min(nod.mi,b) ;
    }
    if(y > m) {
        auto nod = query(rc,m+1,r,x,y) ;
        a = max(nod.ma,a) ; b = min(nod.mi,b) ;
    }
    return {a,b} ;
}
signed main(){
    memset(mi,0x3f,sizeof(mi)) ;
    cin >> n >> m ; int a , b ; 
    for(int i=1;i<=n;++i) cin >> num[i] ;
    build(1,1,n) ;
    while(m--){
        cin >> a >> b ;
        auto nod = query(1,1,n,a,b) ;
        cout << nod.ma - nod.mi << endl ;
    }
    system("pause") ;
}
```

## 借教室

**题目：[P1083 [NOIP2012 提高组\] 借教室 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1083)**

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std ;
const int N = 2e6+10 ;
int num[N] ; int n , m ; 
#define lc (p << 1)
#define rc (p << 1 | 1)
int mi[N << 2] , lz[N << 2] ;
void build(int p,int l,int r){
    if(l == r) {mi[p]=num[l] ; return ;}
    int m = l + r >> 1 ;
    build(lc,l,m) ; build(rc,m+1,r) ;
    mi[p] = min(mi[lc],mi[rc]) ;
}
void down(int p){
    if(!lz[p]) return ;
    mi[lc] -= lz[p] ; mi[rc] -= lz[p] ;
    lz[lc] += lz[p] ; lz[rc] += lz[p] ;
    lz[p] = 0 ;
}
bool updata(int p,int l,int r,int x,int y,int k){
    if(x <= l && y >= r) {mi[p] -= k ; lz[p] += k ; return mi[p] < 0 ;}
    int m = l + r >> 1 ; bool res = 0 ;
    down(p) ;
    if(x <= m) res = updata(lc,l,m,x,y,k) ? true : false ;
    if(y > m ) res = updata(rc,m+1,r,x,y,k) ? true : false ;
    mi[p] = min(mi[lc],mi[rc]) ;
    if(mi[p] < 0) return true ;
    return res ;
}
int d,s,t ;
signed main(){
    cin >> n >> m ;
    for(int i=1;i<=n;++i) cin >> num[i] ; build(1,1,n) ;
    for(int i=1;i<=m;++i){
        cin >> d >> s >> t ;
        if(updata(1,1,n,s,t,d)){
            cout << -1 << endl << i << endl ; return 0 ;
        }
    }
    cout << 0 << endl ;
    system("pause");
}
```

## 【典】等差数列

**题目：[P1438 无聊的数列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1438)**

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std ;
const int N = 1e5+10 ; 
int n , m , num[N] ;
/****************************************/
#define lc (p << 1)
#define rc (p << 1 | 1)
int sum[N << 2] , lz[N << 2] ;
void down(int p,int l,int r){
    if(!lz[p]) return ; int m = l + r >> 1 ;
    lz[lc] += lz[p] ; lz[rc] += lz[p] ;
    sum[lc] += lz[p] * (m - l + 1) ;
    sum[rc] += lz[p] * (r - m) ;
    lz[p]= 0 ;
}
void updata(int p,int l,int r,int x,int y,int k){
    if(x <= l && y >= r){sum[p] += k * (r - l + 1) ; lz[p] += k ; return ;}
    int m = l + r >> 1 ;
    down(p,l,r) ;
    if(x <= m) updata(lc,l,m,x,y,k) ;
    if(y > m ) updata(rc,m+1,r,x,y,k) ;
    sum[p] = sum[lc] + sum[rc] ;
}
int query(int p,int l,int r,int x,int y){
    if(x <= l && y >= r) return sum[p] ;
    down(p,l,r) ; 
    int m = l + r >> 1 ; int res = 0 ;
    if(x <= m) res += query(lc,l,m,x,y) ;
    if(y > m ) res += query(rc,m+1,r,x,y) ;
    sum[p] = sum[lc] + sum[rc] ;
    return res ;
}
/****************************************/
signed main(){
    cin >> n >> m ; int x = 0 , y , k , d , op ;
    for(int i=1;i<=n;++i) {
        cin >> num[i] ;
        updata(1,1,n,i,i,num[i] - x) ;
        x = num[i] ; 
    }
    while(m--){
        cin >> op ;
        if(op==1){
            cin >> x >> y >> k >> d ;
            updata(1,1,n,x,x,k) ; 
            if(x+1<=y) updata(1,1,n,x+1,y,d) ;
            if(y+1<=n) updata(1,1,n,y+1,y+1,-(k+d*(y-x))) ;
        }else{
            cin >> x ;
            cout << query(1,1,n,1,x) << endl ;
        }
    }
    system("pause") ;
}
```

## 【典】函数维护

**题目：[P4145 上帝造题的七分钟 2 / 花神游历各国 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4145)**

```c++
// DSU
#include <bits/stdc++.h>
#define maxn 100100
#define ll long long
using namespace std;
ll tree[maxn*4],a[maxn];int fa[maxn],m,n,q,l,r,t;
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}//并查集，路径压缩
void add(int x,ll y){while(x<=n)tree[x]+=y,x+=(x&-x);}
ll qry(int x){ll r=0;while(x)r+=tree[x],x-=(x&-x);return r;}
int main(){
	scanf("%d",&n);for (int i=1;i<=n;i++)
	scanf("%lld",&a[i]),add(i,a[i]),fa[i]=i;scanf("%d",&m);fa[n+1]=n+1;
	while(m--){scanf("%d%d%d",&q,&l,&r);if (l>r) swap(l,r); 
		if (q==1) printf("%lld\n",qry(r)-qry(l-1));
		else for (int i=l;i<=r;add(i,(t=(int)sqrt(a[i]))-a[i]),a[i]=t,fa[i]=(a[i]<=1)?i+1:i,i=(find(i)==i)?i+1:fa[i]);
	}
    //上面这行信息量很大。。。做了单点修改的操作，a数组保存了每个点的实际值，当a[i]<=1的时候，直接跳到下一个点，结束。可以手算一下，就能很快理解了。
}
```

```c++
// 线段树
#include <bits/stdc++.h>
#define int long long
#define ls k<<1
#define rs k<<1|1
using namespace std;

const int maxn=1000005;
int n,m;
int a[maxn],maxx[maxn<<2],sum[maxn<<2];

inline int read(){
    int x=0,w=1;
    char ch=getchar();
    for(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') w=-1;
    for(;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';
    return x*w;
}

inline void up(int k){
    maxx[k]=max(maxx[ls],maxx[rs]);
    sum[k]=sum[ls]+sum[rs];
}

inline void build(int k,int l,int r){
    if(l==r){
        sum[k]=maxx[k]=a[l];
        return;
    }
    int mid=(l+r)>>1;
    build(ls,l,mid);
    build(rs,mid+1,r);
    up(k);
}

inline void change(int k,int l,int r,int L,int R){
    if(l==r && l>=L && r<=R){
        sum[k]=maxx[k]=sqrt(sum[k]);
        return ;
    }   
    int mid=(l+r)>>1;
    if(L<=mid && maxx[ls]>1) change(ls,l,mid,L,R);
    if(mid<R && maxx[rs]>1) change(rs,mid+1,r,L,R);
    up(k);
}

inline int query(int k,int l,int r,int L,int R){
    if(L<=l && r<=R) return sum[k];
    int mid=(l+r)>>1;
    int ans=0;
    if(L<=mid) ans+=query(ls,l,mid,L,R);
    if(mid<R) ans+=query(rs,mid+1,r,L,R);
    return ans;
}

signed main(){
    n=read();
    memset(sum,0,sizeof sum);
    memset(maxx,0,sizeof maxx);
    for(int i=1;i<=n;i++) a[i]=read();
    build(1,1,n);
    m=read();
    while(m--){
        int op=read(),l=read(),r=read();
        if(l>r) swap(l,r);
        if(op==0) change(1,1,n,l,r);
        else cout<<query(1,1,n,l,r)<<endl;
    }
    cout<<endl;
}
```



# 回溯算法

**模板：**

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```



## 组合（LC 77）

**题目：[77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/)**

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    void helper(int k,int n,int start){
        if(path.size()==k){
            res.push_back(path);
            return;
        }
        for(int i=start;i<=n&&(i<=n-k+path.size()+1);++i){
            path.push_back(i);
            helper(k,n,i+1);
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combine(int n, int k) {
        res.clear();
        path.clear();
        helper(k,n,1);
        return res;
    }
};
```



## 组合总和（LC 39）

**题目：[39. 组合总和 - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum/)**

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    int sum=0;
    void helper(vector<int>& candidates,int target,int start){
        if(sum==target){
            res.push_back(path);
            return;
        }
        for(int i=start;i<candidates.size() && sum<target;++i){
            path.push_back(candidates[i]);
            sum += candidates[i];
            helper(candidates,target,i);
            path.pop_back();
            sum -= candidates[i];
        }
    }
public:

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        helper(candidates,target,0);
        return res;
    }
};
```



## 组合总合 ||（LC 40）

**题目：[40. 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/)**

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    int sum=0;
    vector<int> candidates;
    int target;
    void helper(int start){
        if(sum==target){
            res.push_back(path);
            return;
        }
        for(int i=start;i<candidates.size() && sum<target ;++i){
            if (i > start && candidates[i] == candidates[i - 1])
                continue;
            path.push_back(candidates[i]);
            sum += candidates[i];
            helper(i+1);
            path.pop_back();
            sum -= candidates[i];
        }
    }

public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(begin(candidates),end(candidates));
        this->candidates = candidates;
        this->target = target;
        helper(0);
        return res;
    }
};
```



## 组合总合 |||（LC 216）

**题目：[216. 组合总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iii/)**

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    int sum=0;
    void helper(int k,int n,int start){
        if(path.size()==k){
            if(sum==n)
                res.push_back(path);
            return;
        }
        for(int i=start;i<=9 && sum<n;++i){
            path.push_back(i);
            sum += i;
            helper(k,n,i+1);
            path.pop_back();
            sum -= i;
        }
    }


public:
    vector<vector<int>> combinationSum3(int k, int n) {
        if(n>45) return vector<vector<int>>();
        helper(k,n,1);
        return res;
    }
};
```



## 电话号码的字母组合（LC 17）

**题目：[17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/submissions/)**

```c++
class Solution {
private:
    vector<string> res;
    string path;
    void helper(string& digits,int start1){
        if(path.size()==digits.size()){
            res.push_back(path);
            return;
        }
        for(int i=start1;i<digits.size();++i){
            if(digits[i]=='2'){
                string s = "abc";
                for(int j=0;j<3;++j){
                    path += s[j];
                    helper(digits,i+1);
                    path.pop_back();
                }
            }else if(digits[i]=='3'){
                string s = "def";
                for(int j=0;j<3;++j){
                    path += s[j];
                    helper(digits,i+1);
                    path.pop_back();
                }
            }else if(digits[i]=='4'){
                string s = "ghi";
                for(int j=0;j<3;++j){
                    path += s[j];
                    helper(digits,i+1);
                    path.pop_back();
                }
            }else if(digits[i]=='5'){
                string s = "jkl";
                for(int j=0;j<3;++j){
                    path += s[j];
                    helper(digits,i+1);
                    path.pop_back();
                }
            }else if(digits[i]=='6'){
                string s = "mno";
                for(int j=0;j<3;++j){
                    path += s[j];
                    helper(digits,i+1);
                    path.pop_back();
                }
            }else if(digits[i]=='7'){
                string s = "pqrs";
                for(int j=0;j<4;++j){
                    path += s[j];
                    helper(digits,i+1);
                    path.pop_back();
                }
            }else if(digits[i]=='8'){
                string s = "tuv";
                for(int j=0;j<3;++j){
                    path += s[j];
                    helper(digits,i+1);
                    path.pop_back();
                }
            }else if(digits[i]=='9'){
                string s = "wxyz";
                for(int j=0;j<4;++j){
                    path += s[j];
                    helper(digits,i+1);
                    path.pop_back();
                }
            }
        }
    }
public:
    vector<string> letterCombinations(string digits) {
        if(digits.empty()) return vector<string>();
        helper(digits,0);
        return res;
    }
};
```



## 分割回文串（LC 131）

**题目：[131. 分割回文串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-partitioning/)**

```c++
class Solution {
private:
    vector<vector<string>> res;
    vector<string> path;
    string s;
    bool isPalindrome(int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) 
            if (s[i] != s[j]) return false;
        return true;
    }
    void helper(int startIndex){
        if(startIndex>=s.size()){
            res.push_back(path);
            return;
        }
        for(int i=startIndex;i<s.size();++i){
            if(!isPalindrome(startIndex,i)) continue;
            else{
                path.push_back(s.substr(startIndex,i-startIndex+1));
                helper(i+1);
                path.pop_back();
            }
        }
    }

public:
    vector<vector<string>> partition(string s) {
        this->s = s;
        helper(0);
        return res;
    }
};
```



## 复原IP地址（LC 93）

**题目：[93. 复原 IP 地址 - 力扣（LeetCode）](https://leetcode.cn/problems/restore-ip-addresses/)**

```c++
class Solution {
private:
    vector<string> res;
    string s;
    string path="";
    int k=0;
    void helper(int start){
        if(k==3){
            if(start<s.size() && isVaild(start, s.size()-start)){
                path += ("."+s.substr(start,s.size()-start));
                res.push_back(path);
                //cout<<path<<endl;
                path.erase(path.size()-(s.size()-start+1));
            }
            return;
        }
        for(int i=start;i<s.size();++i){
            if(isVaild(start,i-start+1)){
                if(k==0)
                    path += s.substr(start,i-start+1);
                else
                    path += ("."+s.substr(start,i-start+1));
                ++k;
                helper(i+1);
                --k;
                if(k==0)
                    path.erase(path.size()-(i-start+1));
                else 
                    path.erase(path.size()-(i-start+2));
            }else break;
        }
    }
    bool isVaild(int start,int len){
        if(s[start] == '0' && len>1) return false;
        else if(len>3) return false;
        else if(stoi(s.substr(start,len)) > 255) return false;
        return true;
    }
public:
    vector<string> restoreIpAddresses(string s) {
        this->s = s;
        helper(0);
        return res;
    }
};
```



## 子集（LC 78）

**题目：[78. 子集 - 力扣（LeetCode）](https://leetcode.cn/problems/subsets/)**

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    vector<int> nums;
    void helper(int start){
        res.push_back(path);
        if(start>=nums.size()) return;
        for(int i=start;i<nums.size();++i){
            path.push_back(nums[i]);
            helper(i+1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        this->nums = nums;
        helper(0);
        return res;
    }
};
```



## 子集||（LC 90）

**题目：[90. 子集 II - 力扣（LeetCode）](https://leetcode.cn/problems/subsets-ii/)**

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    vector<int> nums;
    void helper(int start){
        res.push_back(path);
        if(start>=nums.size()) return;
        for(int i=start;i<nums.size();++i){
            if(i > start && nums[i] == nums[i-1]) continue;  // 对本层去重
            path.push_back(nums[i]);
            helper(i+1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(begin(nums),end(nums));
        this->nums = nums;
        helper(0);
        return res;
    }
};
```



## 递增子序列（LC 491）

**题目：[491. 递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/increasing-subsequences/)**

```c++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    vector<int> nums;
    void helper(int start){
        if(path.size()>=2) res.push_back(path);
        unordered_set<int> set;  // 对本层去重
        for(int i=start;i<nums.size();++i){
            if((path.empty() || path[path.size()-1]<=nums[i]) && set.find(nums[i])==set.end()){
                path.push_back(nums[i]);
                set.insert(nums[i]);
                helper(i+1);
                path.pop_back();
            }
        }
    }
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        this->nums = nums;
        helper(0);
        return res;
    }
};
```



## 全排列（LC 46）

**题目：[46. 全排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutations/)**

```C++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    vector<int> nums;
    vector<int> tag;
    void helper(){
        if(path.size()==nums.size()){
            res.push_back(path);
            return;
        }
        for(int i=0;i<nums.size();++i){
            if(tag[i]==0){
                path.push_back(nums[i]);
                tag[i] = 1;
                helper();
                tag[i] = 0;
                path.pop_back();
            }
        }
    }
public:
    vector<vector<int>> permute(vector<int>& nums) {
        tag.resize(nums.size());
        this->nums = nums;
        helper();
        return res;
    }
};

/* class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    vector<int> nums;
    unordered_set<int> set;
    void helper(){
        if(path.size()==nums.size()){
            res.push_back(path);
            return;
        }
        for(auto num : nums){
            if(set.find(num)==set.end()){
                path.push_back(num);
                set.insert(num);
                helper();
                set.erase(set.find(num));
                path.pop_back();
            }
        }
    }
public:
    vector<vector<int>> permute(vector<int>& nums) {
        this->nums = nums;
        helper();
        return res;
    }
}; */
```



## 全排列||（LC 47）

**题目：[47. 全排列 II - 力扣（LeetCode）](https://leetcode.cn/problems/permutations-ii/)**

```C++
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    vector<int> nums;
    vector<int> tag;  // 对全排列去重
    void helper(){
        if(path.size()==nums.size()){
            res.push_back(path);
            return;
        }
        for(int i=0;i<nums.size();++i){
            if(i>0 && nums[i]==nums[i-1] && tag[i-1]==0) continue;// 对本层去重
            if(tag[i]==0){
                path.push_back(nums[i]);
                tag[i] = 1;
                helper();
                tag[i] = 0;
                path.pop_back();
            }
        }
    }
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        tag.resize(nums.size());
        this->nums = nums;
        helper();
        return res;
    }
};

/* class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    vector<int> nums;
    vector<int> tag;  // 对全排列去重
    void helper(){
        if(path.size()==nums.size()){
            res.push_back(path);
            return;
        }
        unordered_set<int> set;  // 对本层去重
        for(int i=0;i<nums.size();++i){
            if(tag[i]==0 && set.find(nums[i])==set.end()){
                set.insert(nums[i]);
                path.push_back(nums[i]);
                tag[i] = 1;
                helper();
                tag[i] = 0;
                path.pop_back();
            }
        }
    }
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        tag.resize(nums.size());
        this->nums = nums;
        helper();
        return res;
    }
}; */
```



## （hard）N皇后（LC 51）

**题目：[51. N 皇后 - 力扣（LeetCode）](https://leetcode.cn/problems/n-queens/)**

```C++
class Solution {
private:
    vector<vector<string>> res;
    vector<string> path;
    int n;
    void helper(){
        if(path.size()==n){
            res.push_back(path);
            return;
        }
        string s(n,'.');
        for(int i=0;i<n;++i){
            s[i] = 'Q';
            if(isVaild(path.size(),i)){
                path.push_back(s);
                helper();
                path.pop_back();
            }
            s[i] = '.';
        }
    }
    bool isVaild(int i,int j){  // 第i行第j列个皇后是否合法
        for(int k=i-1;k>=0;--k){
            if(path[k][j]=='Q') return false; // 检查列
            else if(j+(i-k)<n && path[k][j+(i-k)]=='Q') return false;  // 检查45°
            else if(j-(i-k)>=0 && path[k][j-(i-k)]=='Q') return false; // 检查135°
        }
        return true;
    }  
public:
    vector<vector<string>> solveNQueens(int n) {
        this->n = n;
        helper();
        return res;
    }
};
```



## （hard）解数独（LC 37）

**题目：[37. 解数独 - 力扣（LeetCode）](https://leetcode.cn/problems/sudoku-solver/)**

```C++
class Solution {
private:
    vector<vector<char>> board;
    vector<vector<char>> ans;
    int k=0;  // 记录递归深度
    int tag = false;
    void helper(){
        if(k==81){
            ans = board;
            tag = true;
            return;
        }
        if(board[k/9][k%9]=='.'){
            for(int i=1;i<=9 && !tag ;++i){
                board[k/9][k%9] = i+'0';
                if(isVaild(k/9,k%9)){
                    k++;
                    helper();
                    k--;
                }
                board[k/9][k%9] = '.';
            }
        }else{
            k++;
            helper();
            k--;
        }
        
    }
    bool isVaild(int i,int j){  // 检查（i，j）是否合法
        // 检查3X3
        if(i>=0 && i<=2){
            if(j>=0 && j<=2){
                for(int g=0;g<=2;++g)
                    for(int h=0;h<=2;++h)
                        if(board[g][h]==board[i][j] && g!=i && h!=j) return false;
            }else if(j>=3 && j<=5){
                for(int g=0;g<=2;++g)
                    for(int h=3;h<=5;++h)
                        if(board[g][h]==board[i][j] && g!=i && h!=j) return false;
            }else if(j>=6 && j<=8){
                for(int g=0;g<=2;++g)
                    for(int h=6;h<=8;++h)
                        if(board[g][h]==board[i][j] && g!=i && h!=j) return false;
            }
        }else if(i>=3 && i<=5){
            if(j>=0 && j<=2){
                for(int g=3;g<=5;++g)
                    for(int h=0;h<=2;++h)
                        if(board[g][h]==board[i][j] && g!=i && h!=j) return false;
            }else if(j>=3 && j<=5){
                for(int g=3;g<=5;++g)
                    for(int h=3;h<=5;++h)
                        if(board[g][h]==board[i][j] && g!=i && h!=j) return false;
            }else if(j>=6 && j<=8){
                for(int g=3;g<=5;++g)
                    for(int h=6;h<=8;++h)
                        if(board[g][h]==board[i][j] && g!=i && h!=j) return false;
            }
        }else if(i>=6 && i<=8){
            if(j>=0 && j<=2){
                for(int g=6;g<=8;++g)
                    for(int h=0;h<=2;++h)
                        if(board[g][h]==board[i][j] && g!=i && h!=j) return false;
            }else if(j>=3 && j<=5){
                for(int g=6;g<=8;++g)
                    for(int h=3;h<=5;++h)
                        if(board[g][h]==board[i][j] && g!=i && h!=j) return false;
            }else if(j>=6 && j<=8){
                for(int g=6;g<=8;++g)
                    for(int h=6;h<=8;++h)
                        if(board[g][h]==board[i][j] && g!=i && h!=j) return false;
            }
        }
        // 检查行
        for(int h=0;h<9;++h)
            if(board[i][h]==board[i][j] && h!=j) return false;
        // 检查列
        for(int g=0;g<9;++g)
            if(board[g][j]==board[i][j] && g!=i) return false;
        return true;
    }
public:
    void solveSudoku(vector<vector<char>>& board) {
        this->board = board;
        helper();
        board = this->ans;
    }
};
```







# 动态规划

## 不同类型

### 线性DP

[300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence)

[120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle)

[53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray)

[152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray)

[887. 鸡蛋掉落（DP+二分）](https://leetcode-cn.com/problems/maximum-product-subarray)

[354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes)

[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber)

[213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii)

[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)

[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii)

[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii)

[188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv)

[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)

[714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)

### 区间DP

```c++
memset(dp,0,sizeof(dp));
//初始dp数组
for(int len=2;len<=n;len++){
    //枚举区间长度
    for(int i=1;i<n;++i){//枚举区间的起点
        int j=i+len-1;//根据起点和长度得出终点
        if(j>n) break;//符合条件的终点
        for(int k=i;k<=j;++k)//枚举最优分割点
            dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+w[i][j]);//状态转移方程
        }
}
```

[516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence)

[730. 统计不同回文子字符串](https://leetcode-cn.com/problems/count-different-palindromic-subsequences)

[1039. 多边形三角剖分的最低得分](https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon)

[664. 奇怪的打印机](https://leetcode-cn.com/problems/strange-printer)

[312. 戳气球](https://leetcode-cn.com/problems/burst-balloons)

### 树形DP

**参考：[树形 dp 入门问题（理解「无后效性」和「后序遍历」）](https://leetcode.cn/problems/house-robber-iii/solution/shu-xing-dp-ru-men-wen-ti-by-liweiwei1419/)**

[124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum)

[543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree)

[2246. 相邻字符不同的最长路径 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/)

[337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii)

[P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)

### 状压DP

[1349. 参加考试的最大学生数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-students-taking-exam/)

[526. 优美的排列 - 力扣（LeetCode）](https://leetcode.cn/problems/beautiful-arrangement/)

[464. 我能赢吗 - 力扣（LeetCode）](https://leetcode.cn/problems/can-i-win/)（涉及博弈论，暂未解决）

[1799. N 次操作后的最大分数和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximize-score-after-n-operations/)

[K-本题主要考察了dp_2023牛客寒假算法基础集训营1 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/46800/K)

### 数位DP

度的数量

数字游戏 

Windy数 （不含前导零）

数字游戏II 

[233. 数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one)

[902. 最大为 N 的数字组合](https://leetcode-cn.com/problems/numbers-at-most-n-given-digit-set)（不含前导零）

### 计数型DP

### 递推型DP

## 优化

### 四边形优化

### 单调队列优化

[1425. 带限制的子序列和 - 力扣（LeetCode）](https://leetcode.cn/problems/constrained-subsequence-sum/)

## 买卖股票的最佳时期 |（LC 121）

**题目：[121. 买卖股票的最佳时机 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {  // 动态规划
        int n = prices.size();
        vector<int> dp(n);  // 第i天结束时的最大利润
        dp[0] = 0;
        int minPrice = prices[0];
        for(int i=1;i<n;i++){
            minPrice = min(minPrice,prices[i]);
            dp[i] = max(dp[i-1],prices[i]-minPrice);
        }
        return dp[n-1];
    }
};
// 滚动数组优化空间
class Solution {
public:
    int maxProfit(vector<int>& prices) {  // 动态规划
        int n = prices.size();
        int dp=0;  // 第i天卖股票的最大利润
        int minPrice = prices[0];
        for(int i=1;i<n;i++){
            minPrice = min(minPrice,prices[i]);
            dp = max(dp,prices[i]-minPrice);
        }
        return dp;
    }
};
```



## 买卖股票的最佳时期||（LC 122）

**题目：[122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n==0) return 0;
        if(n==1) return 0;
        int dp[n][2];// 每天交易结束后 没股票和有股票的最大利润
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for(int i=1;i<n;i++){
            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]);
        }
        return dp[n-1][0];
    }
};
```



## （hard）买卖股票的最佳时期|||（LC 123）

**题目：[123. 买卖股票的最佳时机 III - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)**

```c++
class Solution {
public:
    // 官方标准
    // int maxProfit(vector<int>& prices){
    //     int n = prices.size();
    //     int buy1 = -prices[0], sell1 = 0;
    //     int buy2 = -prices[0], sell2 = 0;
    //     for (int i = 1; i < n; ++i) {
    //         buy1 = max(buy1, -prices[i]);
    //         sell1 = max(sell1, buy1 + prices[i]);
    //         buy2 = max(buy2, sell1 - prices[i]);
    //         sell2 = max(sell2, buy2 + prices[i]);
    //     }
    //     return sell2;
    // }


    // 自己写的
    // int maxProfit(vector<int>& prices) {
    //     int n = prices.size();
    //     if(n==0) return 0;
    //     if(n==1) return 0;
    //     int dp[n][2][3];// 每天交易结束后 没股票和有股票,没交易和第一笔交易和第二笔交易的最大利润 
    //     dp[0][0][0] = 0;
    //     dp[0][0][1] = 0;
    //     dp[0][0][2] = 0;
    //     dp[0][1][0] = -prices[0];
    //     dp[0][1][1] = -prices[0];
    //     for(int i=1;i<n;i++){
    //         dp[i][1][0]=max(dp[i-1][1][0],dp[i-1][0][0]-prices[i]); // 买入
    //         dp[i][0][1]=max(dp[i-1][0][1],dp[i-1][1][0]+prices[i]); // 卖出
    //         dp[i][1][1]=max(dp[i-1][1][1],dp[i-1][0][1]-prices[i]); // 买入
    //         dp[i][0][2]=max(dp[i-1][0][2],dp[i-1][1][1]+prices[i]); // 卖出         
    //     }
    //     return dp[n-1][0][2];
    // }

    // 改成 k = 2
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n==0) return 0;
        if(n==1) return 0;
        int k = 2;
        int dp[n][2][k+1];// 每天交易结束后 没股票和有股票,没交易和第一笔交易和第二笔交易的最大利润 
        // 初始化
        for(int i=0;i<=k;i++) dp[0][0][i]=0;
        for(int i=0;i<k;i++) dp[0][1][i]=-prices[0];
        for(int i=0;i<n;i++) dp[i][0][0]=0; // 不买股票的利润

        for(int i=1;i<n;i++){
            for(int j=0;j<k;j++){
                dp[i][1][j]=max(dp[i-1][1][j],dp[i-1][0][j]-prices[i]); // 买入
                dp[i][0][j+1]=max(dp[i-1][0][j+1],dp[i-1][1][j]+prices[i]); // 卖出
            }
                     
        }
        return dp[n-1][0][k];
    }
};
```



## （hard）买卖股票的最佳时期 IV（LC 188）

**题目：[309. 最佳买卖股票时机含冷冻期 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)**

```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        if(n==0) return 0;
        if(n==1) return 0;
        int dp[n][2][k+1];// 每天交易结束后 没股票和有股票,没交易和第一笔交易和第二笔交易的最大利润 
        //初始化
        for(int i=0;i<=k;i++) dp[0][0][i]=0;
        for(int i=0;i<k;i++) dp[0][1][i]=-prices[0];
        for(int i=0;i<n;i++) dp[i][0][0]=0;  // 不买股票的利润

        for(int i=1;i<n;i++){
            for(int j=0;j<k;j++){
                dp[i][1][j]=max(dp[i-1][1][j],dp[i-1][0][j]-prices[i]); // 买入
                dp[i][0][j+1]=max(dp[i-1][0][j+1],dp[i-1][1][j]+prices[i]); // 卖出
            }                     
        }
        return dp[n-1][0][k];
    }
};
```



## 买卖股票的最佳时期含冷冻期（LC 309）

**题目：[309. 最佳买卖股票时机含冷冻期 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n==0) return 0;
        if(n==1) return 0;
        int dp[n][2][2];// 每天交易结束后 没股票和有股票的最大利润 是否冻结
        dp[0][0][0] = 0;
        dp[0][0][1] = 0;
        dp[0][1][0] = -prices[0];
        for(int i=1;i<n;i++){
            dp[i][0][0]=max(dp[i-1][0][0],dp[i-1][0][1]);
            dp[i][0][1]=dp[i-1][1][0]+prices[i];
            dp[i][1][0]=max(dp[i-1][1][0],dp[i-1][0][0]-prices[i]);
        }
        return max(dp[n-1][0][0],dp[n-1][0][1]);
    }
};
```



## 买卖股票的最佳时期含手续费（LC 714）

**题目：[714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if(n==0) return 0;
        if(n==1) return 0;
        int dp[n][2];// 每天交易结束后 没股票和有股票的最大利润
        dp[0][0] = 0;
        dp[0][1] = -prices[0]-fee;
        for(int i=1;i<n;i++){
            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]-fee);
        }
        return dp[n-1][0];
    }
};
```



## 打家劫舍|（LC 198）

**题目：[198. 打家劫舍 - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber/)**

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        // 法一
        int n=nums.size();
        if(n==0) return 0;
        if(n==1) return nums[0];
        int dp[2];  // 第i间房间不偷(dp[0])与偷(dp[1])获得的最大金额
        dp[0] = 0;  // 不偷第一间房间金额为0
        dp[1] = nums[0];  // 偷就是nums[0]
        for(int i=1;i<n;i++){
            int temp = dp[0];
            dp[0] = max(dp[0],dp[1]); // 不偷就是i-1的结果的最大值
            dp[1] = temp+nums[i];  // 偷就是dp[0]+nums[i]
        }
        return max(dp[0],dp[1]);
        
		// 法二
        // int n=nums.size();
        // if(n==0) return 0;
        // if(n==1) return nums[0];
        // int dp[n];  // 到第i间房间能拿到的最高金额
        // dp[0] = nums[0];
        // dp[1] = max(dp[0],nums[1]);
        // for(int i=2;i<n;i++){
        //     dp[i] = max(dp[i-1],dp[i-2]+nums[i]);
        // }
        // return dp[n-1];
    }
};
```



## （方法巧妙）打家劫舍||（LC 213）

**题目：[213. 打家劫舍 II - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-ii/)**

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n=nums.size();
        if(n==0) return 0;
        if(n==1) return nums[0];
        if(n==2) return (nums[0]>nums[1])?nums[0]:nums[1];

        // 0~n-2
        int dp[n-1];  // 到第i间房间能拿到的最高金额
        dp[0] = nums[0];
        dp[1] = max(dp[0],nums[1]);
        for(int i=2;i<n-1;i++){
            dp[i] = max(dp[i-1],dp[i-2]+nums[i]);
        }

        // 1~n-1
        int dp1[n-1];  // 到第i间房间能拿到的最高金额
        dp1[0] = nums[1];
        dp1[1] = max(dp1[0],nums[2]);
        for(int i=2;i<n-1;i++){
            dp1[i] = max(dp1[i-1],dp1[i-2]+nums[i+1]);
        }

        
        return max(dp[n-2],dp1[n-2]);
    }
};
```



## 打家劫舍|||（LC 337）

**题目：[337. 打家劫舍 III - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-iii/)**

```c++
class Solution {
public:
    int* DFS(TreeNode* root){
        if(root == NULL) return new int[2]{0};
        int * resul
        t = new int[2]{0};
        int * left = DFS(root->left);
        int * right = DFS(root->right);
        result[0] = max(left[0],left[1])+max(right[0],right[1]);  // 不偷当前节点
        result[1] = left[0]+right[0]+root->val;  // 偷当前节点
        return result;
    }
    int rob(TreeNode* root) {
        int *money=DFS(root);
        return max(money[0],money[1]);
    }
};
```



## （方法巧妙，值得学习）删除并获得点数（打家劫舍Plus）（LC 740）

**题目：[740. 删除并获得点数 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-and-earn/)**

```c++
class Solution {
public:
    // 打家劫舍升级版plus
    int deleteAndEarn(vector<int>& nums) {
        int n=nums.size();
        if(n==0) return 0;
        if(n==1) return nums[0];
        int a[10001]={0};  // 数组的长度取决于最大值
        for(int i=0;i<n;i++){  // 转换数组
            a[nums[i]]++;  // i元的数量
        }
        int dp[10001];  // 打家劫舍思路
        dp[0]=0*a[0];
        dp[1]=max(0*a[0],1*a[1]);
        for(int i=2;i<10001;i++){
            dp[i] = max(a[i]*i+dp[i-2],dp[i-1]);
        }
        return dp[10000];
    }
};
```

## 最长回文子串（LC 5）

**题目：[5. 最长回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-substring/)**

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        bool dp[n][n];  // dp[i][j]代表子串i~j是否是回文子串
        int maxlen = 1;  // 最长回文子串的长度
        int index = 0;  // 最长回文子串的起始下标
        for(int j=0;j<n;j++){ 
            for(int i=0;i<=j;i++){
                if(s[i] != s[j]){
                    dp[i][j] = false;
                }else{
                    if(j-i+1<=3) dp[i][j] = true;  // 长度为 1或者2或者3
                    else{  // 否则取决于子串
                        dp[i][j] = dp[i+1][j-1];
                    }
                    if(dp[i][j] && (j-i+1)>maxlen){
                        maxlen = j-i+1;
                        index = i;
                    }
                }
            }
        }
        return s.substr(index,maxlen);
    }
};
```



## 跳跃游戏 |（LC 55）

**题目：[55. 跳跃游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game/)**

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n=nums.size();
        int *dp = new int[n]{0};  // 能到达的最远地方
        dp[0] = nums[0];
        for(int i=1;i<n;i++){
            if(dp[i-1]<i) return false;   // 到达不了这个台阶
            else dp[i] = max(dp[i-1],nums[i]+i);
        }
        if(dp[n-1]>=n-1) return true;
        return false;
    }
};
```





## 最大数组和（LC 53）

**题目：**[**53. 最大子数组和 - 力扣（LeetCode）**](https://leetcode.cn/problems/maximum-subarray/)

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n= nums.size();
        vector<int> dp(n) ;  // 状态方程转移，以第i个结尾的前i个的最大和
        dp[0] = nums[0];
        for(int i=1;i<n;i++){
            if(dp[i-1]>0) dp[i] = dp[i-1]+nums[i];  // 前i-1个和是正数，就加上
            else dp[i] = nums[i];  // 前i个和为负数，就不加上
        }
        auto max = max_element(dp.begin(),dp.end());  // 找出里面的最大值，返回迭代器
        return *max;
    }
};
```



## 爬楼梯（LC 70）

**题目：[70. 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/)**

```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n==0) return 0;
        if(n==1) return 1;
        if(n==2) return 2;
        int dp[2];  // dp[0] 代表前1步的方法，dp[1] 代表前2步的方法
        dp[0] = 1;  // 只能走一步
        dp[1]=2;  // 走两次一步或者走一次两步
        for(int i=3;i<n;i++){
            dp[1] += dp[0]; 
            dp[0] = dp[1]-dp[0];
        }
        return dp[0]+dp[1];
    }
};
```



## 不同的二叉搜索树（LC 96）

**题目：[96. 不同的二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-binary-search-trees/submissions/)**

```C++
class Solution {
public:
    int numTrees(int n) {
        int * a = new int[n+1]{1};
        if(n==0) return 0;
        if(n==1) return 1;
        for(int i=1;i<=n;i++){
            for(int j=0;j<=i-1;j++){
                a[i] += a[j]*a[i-j-1];  // 左子树的总数与右子树的总数之积
            }
        }
        return a[n];
    }
};
```



## 杨辉三角（LC 118）

**题目：[118. 杨辉三角 - 力扣（LeetCode）](https://leetcode.cn/problems/pascals-triangle/submissions/)**

```c++
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> v(numRows,vector<int>());
        for(int i=0;i<numRows;i++){
            for(int j=0;j<=i;j++){
                if(j == 0 || j == i) v[i].push_back(1);
                else v[i].push_back(v[i-1][j-1]+v[i-1][j]);
            }
        }
        return v;
    }
};
```



## 斐波那契数（LC 509）

**题目：[509. 斐波那契数 - 力扣（LeetCode）](https://leetcode.cn/problems/fibonacci-number/)**

```c++
class Solution {
public:
    int fib(int n) {
        if(n == 0) return 0;
        if(n == 1) return 1;
        int dp[2];
        dp[0] = 0;  // n-2的数
        dp[1] = 1;  // n-1的数
        for(int i=2;i<n;i++){
            dp[1] += dp[0];
            dp[0] = dp[1]-dp[0];
        }
        return dp[0]+dp[1];
    }
};
```



## 使用最小花费爬楼梯（LC 746）

**题目：[746. 使用最小花费爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/min-cost-climbing-stairs/)**

```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        if(n==0) return 0;
        if(n==1) return cost[0];
        int dp[n];  // 爬到第i个阶梯所需的最小花费
        dp[0] = 0;  // 第一个和第二个阶梯的花费是0
        dp[1] = 0;
        for(int i=2;i<n;i++){
            dp[i] = min(dp[i-2]+cost[i-2],dp[i-1]+cost[i-1]);
        }
        return min(dp[n-2]+cost[n-2],dp[n-1]+cost[n-1]);
    }
};
```



## （hard）使序列递增的最小交换次数（LC 801）

**题目：[801. 使序列递增的最小交换次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/)**

```c++
class Solution {
public:
    int minSwap(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        int dp[n][2];  // 第i个位置交换与不交换的话  合格的最少次数
        dp[0][0] = 0;  // 0代表不交换，1代表交换
        dp[0][1] = 1;
        for(int i=1;i<n;i++){
            int a = nums1[i],b=nums1[i-1],c=nums2[i],d=nums2[i-1];
            if((a>b)&&(c>d)&&(c>b)&&(a>d)) {  // d<a<b<c,i位置交换与否都不影响
                dp[i][0] = min(dp[i-1][0],dp[i-1][1]);
                dp[i][1] = min(dp[i-1][0],dp[i-1][1])+1;
            }
            else if((a>b)&&(c>d)){  // 不能交换
                dp[i][0] = dp[i-1][0];
                dp[i][1] = dp[i-1][1]+1;
            }
            else{  // 必须交换，要么交换i，要么交换i-1
                dp[i][0] = dp[i-1][1];
                dp[i][1] = dp[i-1][0]+1;
            }
        }
        return min(dp[n-1][0],dp[n-1][1]);  // 返回最小值
    }
};
```



## （方法巧妙）环形子数组的最大和（LC 918）

**题目：[918. 环形子数组的最大和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-sum-circular-subarray/)**

```c++
class Solution {
public:
    int maxSubarraySumCircular(vector<int>& nums) {
        int n= nums.size();
        if(n==1) return nums[0];

        // 不是环形数组的最大值
        vector<int> dp(n) ;  // 状态方程转移，以第i个结尾的前i个的最大和
        dp[0] = nums[0];
        int sum=nums[0];
        for(int i=1;i<n;i++){
            sum+=nums[i];
            if(dp[i-1]>0) dp[i] = dp[i-1]+nums[i];  // 前i-1个和是正数，就加上
            else dp[i] = nums[i];  // 前i个和为负数，就不加上
        }
        auto max1 = *max_element(dp.begin(),dp.end());  // 找出里面的最大值，返回迭代器
    
        // 不是环形数组的最小值
        vector<int> nums2 = nums;
        nums2.erase(nums2.begin());
        nums2.pop_back();
        vector<int> dp1(nums2.size());
        dp1[0] = nums2[0];
        for(int i=1;i<nums2.size();i++){
            if(dp1[i-1]>0) dp1[i] = nums2[i];
            else dp1[i] = dp1[i-1]+nums2[i];
        }
        auto min = *min_element(dp1.begin(),dp1.end());
        int max2 = sum-min;  // 转化成为包含nums[n-1]和nums[0]的最大值
        return max(max2,max1);
    }
};
```



## 第N个泰波那契数（LC 1137）

**题目：[1137. 第 N 个泰波那契数 - 力扣（LeetCode）](https://leetcode.cn/problems/n-th-tribonacci-number/)**

```c++
class Solution {
public:
    int tribonacci(int n) {
        if(n==0) return 0;
        if(n==1) return 1;
        if(n==2) return 1;
        int dp[3];
        dp[0] = 0;dp[1] = 1;dp[2] = 1;
        for(int i=3;i<n;i++){
            int temp = dp[0];
            dp[0] = dp[1];
            dp[1] = dp[2];
            dp[2] = dp[0]+dp[1]+temp;
        }
        return dp[2]+dp[1]+dp[0];
    }
};
```



## 乘积最大的子数组（LC 152）

**题目：[152. 乘积最大子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-product-subarray/)**

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        if(n == 1) return nums[0];
        int Max = nums[0];  // 迭代最大值
        int maxDP = nums[0];  // 代表以第i个结尾的乘积的最大值
        int minDP = nums[0];  // 代表以第i个结尾的乘积的最小值
        for(int i = 1; i < n; i++) {
            int t = maxDP;  // 暂时记录一下第i个的乘积最大值
            maxDP = max(max(maxDP*nums[i], nums[i]), minDP*nums[i]);
            minDP = min(min(t*nums[i], nums[i]), minDP*nums[i]);
            Max = max(maxDP, Max);
        }
        return Max;
    }
};
```



## 最大正方形（LC 221）

**题目：[221. 最大正方形 - 力扣（LeetCode）](https://leetcode.cn/problems/maximal-square/submissions/)**

```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        // dp[i][j] 表示以matrix[i][j]作为右下角的正方形的边长
        vector<vector<int>> dp(matrix.size(),vector<int>(matrix[0].size(),0));
        int Max=matrix[0][0]-'0';
        // 初始化边界条件
        for(int i=0;i<matrix.size();i++) dp[i][0] = matrix[i][0]-'0',Max = max(Max,dp[i][0]);;
        for(int j=0;j<matrix[0].size();j++) dp[0][j] = matrix[0][j]-'0',Max = max(Max,dp[0][j]);;
        // 填表
        for(int i=1;i<matrix.size();i++){
            for(int j=1;j<matrix[i].size();j++){
                if(matrix[i][j]-'0') {
                    dp[i][j] = min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;
                    Max = max(Max,dp[i][j]);
                }
                else dp[i][j] = 0;
            }
        }
        return Max*Max;
    }
};
```



## 括号分配（LC 22）

**题目：[22. 括号生成 - 力扣（LeetCode）](https://leetcode.cn/problems/generate-parentheses/submissions/)**

```c++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        if(n==0) return vector<string>();
        vector<vector<string>> dp(n+3,vector<string>());
        dp[0].push_back("");
        dp[1].push_back("()");
        dp[2].push_back("(())"); dp[2].push_back("()()");
        for(int i=3;i<=n;i++){  // 填表
            for(int p=0;p<=i-1;p++){  //"(" + 【i=p时所有括号的排列组合】 + ")" + 【i=q时所有括号的排列组合】
                int q = i-1-p;
                for(int j=0;j<dp[p].size();j++)  // 【i=p时所有括号的排列组合】
                    for(int k=0;k<dp[q].size();k++)  // i=q时所有括号的排列组合】
                        dp[i].push_back("("+dp[p][j]+")"+dp[q][k]);
            }
        }
        return dp[n];
    }
};
```



## 整数拆分（LC 343）

**题目：[343. 整数拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/integer-break/submissions/)**

```c++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+1,0);
        dp[1] = 0;
        dp[2] = 1;
        for(int i=3;i<=n;i++){
            dp[i] = INT_MIN;
            for(int j=1;j<i;j++)
                dp[i] = max(dp[i],max(j*(i-j),max(j*dp[i-j],dp[j]*dp[i-j])));
        }
        return dp[n];
    }
};
```

## 丑数||（LC 264）

**题目：[264. 丑数 II - 力扣（LeetCode）](https://leetcode.cn/problems/ugly-number-ii/submissions/)**

```c++
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> primes;
        primes.push_back(2);
        primes.push_back(3);
        primes.push_back(5);
        vector<int> idx(primes.size(),0);
        auto dp = vector<long long>(n);
        dp[0] = 1;
        for(int i=1;i<n;i++){
            dp[i] = INT_MAX;
            for(int j=0;j<primes.size();j++){
                dp[i] = min(dp[i],dp[idx[j]]*primes[j]);
            }
            for(int j=0;j<primes.size();j++){
                if(dp[i]==dp[idx[j]]*primes[j]) 
                    idx[j]++;
            }
        }
        return dp[n-1];
    }
};
```



## 超级丑数（LC 313）

**题目：[313. 超级丑数 - 力扣（LeetCode）](https://leetcode.cn/problems/super-ugly-number/)**

```c++
class Solution {
public:
    int nthSuperUglyNumber(int n, vector<int>& primes) {
        int len = primes.size();
        vector<long long> dp(n,0);  // （丑数）
        vector<int> index(len,0);  // 丑数的下标（对应素数的下标）
        dp[0] = 1;
        for(int i=1;i<n;i++){
            dp[i] = INT_MAX;
            for(int j=0;j<len;j++){  // 思想类似于多路归并，因此可以用堆来优化
                dp[i] = min(dp[index[j]]*primes[j],dp[i]);
            }
            for(int j=0;j<len;j++){
                if(dp[i] == dp[index[j]]*primes[j])
                    index[j]++;
            }
        }
        return dp[n-1];
    }
};
```



## 不同路径 | （LC 62）

**题目：[62. 不同路径 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths/submissions/)**

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        // dp[i][j] 代表到达（i，j）的方法数
        vector<vector<int>> dp(m,vector<int>(n,1));  // 初始化完成
        for(int i=1;i<m;i++)
            for(int j=1;j<n;j++)
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
        return dp[m-1][n-1];
    }
};
```



## 不同路径 || （LC 63）

**题目：[63. 不同路径 II - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths-ii/submissions/)**

```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        if(obstacleGrid[0][0]) return 0;
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        // dp[i][j] 代表到达（i，j）的方法数
        vector<vector<int>> dp(m,vector<int>(n,0));
        // 初始化
        dp[0][0]=1;
        for(int i=1;i<m;i++) {
            if(obstacleGrid[i][0]) dp[i][0]=0;
            else {
                if(!dp[i-1][0]) dp[i][0]=0;
                else dp[i][0]=1;
            }
        }
        for(int j=1;j<n;j++) {
            if(obstacleGrid[0][j]) dp[0][j]=0;
            else {
                if(!dp[0][j-1]) dp[0][j]=0;
                else dp[0][j]=1;
            }
        }
        // 填表
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                if(!obstacleGrid[i][j]){  // 没有阻挡物
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }else dp[i][j]=0;  // 有阻挡物
            }
        }
        return dp[m-1][n-1];
    }
};
```



## 解码方法（LC 91）

**题目：[91. 解码方法 - 力扣（LeetCode）](https://leetcode.cn/problems/decode-ways/submissions/)**

```c++
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        vector<int> dp(n+1,0);
        dp[0] = 1;
        for (int i=1; i<=n; ++i) {
            if (s[i-1] != '0') {  //单个字符解码
                dp[i] = dp[i-1];
            }
            // 两个字符解码
            if (i>1 && s[i-2]!='0' && ((s[i-2]-'0')*10+(s[i-1]-'0') <= 26)) {
                dp[i]+=dp[i-2];
            }
        }
        return dp[n];
    }
};
```



## 交错字符串（LC 97）

**题目：[97. 交错字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/interleaving-string/comments/)**

```c++
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        // dp[i][j]表示s1[0~i-1]和s2[0~j-1]能否交错组成s3[0~i+j-1]
        auto dp = vector<vector<int>>(s1.size()+1,vector<int>(s2.size()+1,false));
        int n = s1.size(), m = s2.size(), t = s3.size();
        if (n+m != t) return false;
        dp[0][0] = true;
        for (int i = 0; i <= n; ++i) {
            for (int j = 0; j <= m; ++j) {
                int p = i + j - 1;
                if (i > 0) 
                    dp[i][j] |= (dp[i-1][j] && s1[i-1] == s3[p]);
                if (j > 0)
                    dp[i][j] |= (dp[i][j-1] && s2[j-1] == s3[p]);
            }
        }
        return dp[n][m];
    }
};
```



## 三角形的最小路径和（LC 120）

**题目：[120. 三角形最小路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/triangle/)**

```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        auto dp = vector<vector<int>>(n,vector<int>()); 
        dp[0].push_back(triangle[0][0]);
        for(int i=1;i<n;i++){
            dp[i].resize(triangle[i].size());
            for(int j=0;j<triangle[i].size();j++){
                if(j>=1 && j<i)
                    dp[i][j] = min(dp[i-1][j-1]+triangle[i][j],dp[i-1][j]+triangle[i][j]);
                else if(j>=i)
                    dp[i][j] = dp[i-1][j-1]+triangle[i][j];
                else if(j<1)
                    dp[i][j] = dp[i-1][j]+triangle[i][j];
            }
        }
        auto Min = *min_element(dp[n-1].begin(),dp[n-1].end());
        return Min;
    }
};
```



## 最小路径和（LC 64）

**题目：[64. 最小路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-path-sum/)**

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        // dp[i][j] 代表到达（i，j）网格时的最小和
        // 状态转移方程：dp[i][j] = min(dp[i-1][j],dp[i][j-1])+grid[i][j];
        auto dp = vector<vector<int>>(n,vector<int>(m,0));
        // 初始化
        dp[0][0] = grid[0][0];
        for(int i=1;i<n;i++) dp[i][0] = dp[i-1][0]+grid[i][0];
        for(int j=1;j<m;j++) dp[0][j] = dp[0][j-1]+grid[0][j];
        // 填表  
        for(int i=1;i<n;i++)
            for(int j=1;j<m;j++)
                dp[i][j] = min(dp[i-1][j],dp[i][j-1])+grid[i][j];
        return dp[n-1][m-1];
    }
};
```



## 单词拆分（LC 139）

**题目：[139. 单词拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/word-break/)**

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        int n = s.size();
        // dp[i]表示字符串s的前i个字符能否拆分成wordDict。
        // 状态转移方程：dp[i] = dp[j] && dp[i-j];
        vector<bool> dp(n+1);  
        unordered_set m(wordDict.begin(),wordDict.end());
        dp[0] = true;
        for(int i=1;i<=n;i++){
            for(int j=0;j<i;j++){
                if(dp[j] && m.find(s.substr(j,i-j))!=m.end()){
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[n];
    }
};
```



## 最长递增子序列（LC 300）

**题目：[300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/submissions/)**

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size(); 
        // dp[i]是以第i个元素结尾的最长子序列
        auto dp = vector<int>(n,0);
        dp[0] = 1;
        for(int i=1;i<n;i++){
            dp[i]=1;
            for(int j=i-1;j>=0;j--){
                if(nums[i] > nums[j])
                    dp[i] = max(dp[i],dp[j]+1);
            }
        } 
        return *max_element(dp.begin(),dp.end());
    }
};
```



## 统计各位数字都不同的数字个数（LC 357）

**题目：[357. 统计各位数字都不同的数字个数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-numbers-with-unique-digits/submissions/)**

```c++
class Solution {
public:
    int countNumbersWithUniqueDigits(int n) {
        if (n == 0) return 1;
        if (n == 1) return 10;
        int ans = 10, cur = 9;
        for (int i = 0; i < n - 1; ++i)
            cur *= 9 - i,ans += cur;
        return ans;
    }
};
```



## (hard)奇怪的打印机（LC 664）

**题目：[664. 奇怪的打印机 - 力扣（LeetCode）](https://leetcode.cn/problems/strange-printer/submissions/)**

```c++
class Solution {
public:
    // 区间DP
    int strangePrinter(string s) {
        int n=s.size();
        // dp[i][j]代表打印s[i...j]所需要的最少次数
        // 状态转移方程: dp[i][j] = min(dp[i][k]+dp[k+1][j]) k:[i...j-1] , s[i]!=s[j];
        //              dp[i][j] = dp[i][j-1]  ,  s[i]==s[j];
        auto dp = vector<vector<int>>(n,vector<int>(n));
        for(int i=0;i<n;i++) dp[i][i] = 1;
        for(int i=n-1;i>=0;i--){  // 倒序保证无后效性
            for(int j=i+1;j<n;j++){
                if(s[i] == s[j])
                    dp[i][j] = dp[i][j-1];
                else{
                    dp[i][j] = INT_MAX;
                    for(int k=i;k<j;k++){
                        dp[i][j] = min(dp[i][j],dp[i][k]+dp[k+1][j]);
                    }
                }
            }
        }
        return dp[0][n-1];
    }
};
```



## (hard)戳气球（LC 312）

**题目：[312. 戳气球 - 力扣（LeetCode）](https://leetcode.cn/problems/burst-balloons/comments/)**

```c++
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        // 方便处理 头插一个1，尾插一个1
        nums.insert(nums.begin(),1);
        nums.push_back(1);
        // dp[i][j]代表开区间内的最大硬币数量
        // i<j-1: dp[i][j] = max (dp[i][k]+dp[k][j]+nums[i]*nums[k]*nums[j]); k:[i+1...j-1]
        // i>=j-1: dp[i][j] = 0;
        auto dp = vector<vector<int>>(n+2,vector<int>(n+2,0));  // 初始化
        // 填表
        for(int i=n+1;i>=0;i--){  // 保证无后效性
            for(int j=i+2;j<n+2;j++){
                dp[i][j] = INT_MIN;
                for(int k=i+1;k<=j-1;k++){
                    dp[i][j] = max(dp[i][j],dp[i][k]+dp[k][j]+nums[i]*nums[k]*nums[j]);
                }
            }
        }
        return dp[0][n+1];
    }
};
```



## （hard）切棍子的最小成本（LC 1547）

**题目：[1547. 切棍子的最小成本 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/)**

```c++
class Solution {
public:
    int minCost(int n, vector<int>& cuts) {
        // 方便计算
        cuts.push_back(0);
        cuts.push_back(n);
        int nc = cuts.size();
        //dp[i][j] 表示覆盖cuts[i]到cuts[j]的木棍范围的最小总成本
        int dp[nc][nc];
        memset(dp,0, sizeof(dp));
        sort(cuts.begin(),cuts.end());
        for (int i = nc-1; i >= 0; --i){
            for (int j = i+2; j <= nc-1; ++j){
                dp[i][j] = INT_MAX;
                for (int k = i+1; k < j; ++k){
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);
                }
                dp[i][j] += cuts[j] - cuts[i];
            }
        }
        return dp[0][nc-1];
        
        // // dp[i][j]代表i~j的最小成本
        // auto dp = vector<vector<int>>(n+1,vector<int>(n+1));
        // auto hash_helper = vector<bool>(n+1,0);
        // for(auto num: cuts) hash_helper[num]=1; 
        // auto hash = [&](int k)->bool{
        //     return hash_helper[k];
        // };
        // for(int i=n;i>=0;--i){
        //     for(int j=i+1;j<=n;++j){
        //         if(j-i==1) dp[i][j]=0;
        //         else{
        //             dp[i][j] = INT_MAX;
        //             int tag = true;
        //             for(int k=i+1;k<j;++k){
        //                 if(hash(k))
        //                     dp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]+j-i),tag = false;
        //             }
        //             if(tag) dp[i][j] = 0;
        //         }
        //     }
        // }
        // return dp[0][n];
    }
};
```



## （hard）戳气球（LC 312）

**题目：[312. 戳气球 - 力扣（LeetCode）](https://leetcode.cn/problems/burst-balloons/)**

```c++
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        // 方便处理 头插一个1，尾插一个1
        nums.insert(nums.begin(),1);
        nums.push_back(1);
        // dp[i][j]代表开区间类的最大数量
        // i<j-1: dp[i][j] = max (dp[i][k]+dp[k][j]+nums[i]*nums[k]*nums[j]); k:[i+1...j-1]
        // i>=j-1: dp[i][j] = 0;
        auto dp = vector<vector<int>>(n+2,vector<int>(n+2,0));  // 初始化
        // 填表
        for(int i=n+1;i>=0;i--){  // 保证无后效性
            for(int j=i+2;j<n+2;j++){
                dp[i][j] = INT_MIN;
                for(int k=i+1;k<=j-1;k++){
                    dp[i][j] = max(dp[i][j],dp[i][k]+dp[k][j]+nums[i]*nums[k]*nums[j]);
                }
            }
        }
        return dp[0][n+1];
    }
};
```



## （hard）买木头块（LC 2312）

**题目：[2312. 卖木头块 - 力扣（LeetCode）](https://leetcode.cn/problems/selling-pieces-of-wood/submissions/)**

```c++
class Solution {
public:
    int price[201][201];
    void helper(vector<vector<int>>& prices){
        for(int i=0;i<prices.size();++i)
            price[prices[i][0]][prices[i][1]] = prices[i][2];
    }
    int hash(int m,int n){
        return price[m][n];
    }
    long long sellingWood(int m, int n, vector<vector<int>>& prices) {
        memset(price,0,sizeof(price));
        helper(prices);
        // dp[i][j] 代表 iXj 的木板能出售的最大价值
        long long dp[m+1][n+1];
        memset(dp,0,sizeof(dp));
        for(int i=1;i<=m;++i){
            for(int j=1;j<=n;++j){
                dp[i][j] = hash(i,j);
                for(int k=1;k<j;++k){
                    dp[i][j] = max(dp[i][j],dp[i][k]+dp[i][j-k]);
                }
                for(int k=1;k<i;++k){
                    dp[i][j] = max(dp[i][j],dp[k][j]+dp[i-k][j]);
                }
            }
        }
        return dp[m][n];
    }
};

```



## （hard）扰乱字符串（LC 87）

**题目：[87. 扰乱字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/scramble-string/)**

```c++
class Solution {
public:
    bool isScramble(string s1, string s2) {
        int n = s1.size();
        //dp[i][j][g][h]代表 s1[i..j]是否有能够变换成为s2[g..h]
        /* 
                           0, j<i or h<g or j-i!=h-g;
        dp[i][j][g][h]=    s1[i]==s2[g] , len = j-i+1 = 1; 
                           (dp[i][k][g][k-i+g]&&dp[k+1][j][h-j+k+1][h]) || dp[i][k][h-k+i][h]&&dp[k+1][j][g][g+j-k-1]; k:[i..j-1]
        */
        int dp[n][n][n][n];
        memset(dp,0,sizeof(dp));
        for(int i=n-1;i>=0;--i){  // 保证无后效性
            for(int j=i;j<=n-1;++j){
                for(int g = n-1;g>=0;--g){  // 保证无后效性
                    for(int h=g;h<=n-1;++h){
                        if(j-i!=h-g) continue;
                        if(j-i+1 == 1){  // 长度为一
                            dp[i][j][g][h] = (s1[i]==s2[g]);
                            continue;
                        }
                        for(int k=i;k<j;k++){  // 长度不为一
                            bool tag = dp[i][k][g][k-i+g]&&dp[k+1][j][h-j+k+1][h];
                            tag |= dp[i][k][h-k+i][h]&&dp[k+1][j][g][g+j-k-1];
                            if(tag==true) {
                                dp[i][j][g][h] = tag;
                                break;
                            }
                        }
                    }
                }
            }
        }
        return dp[0][n-1][0][n-1];
    }
};
```



## (hard)合并石头的最小成本（LC 1000）

**题目：[1000. 合并石头的最低成本 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-cost-to-merge-stones/)**

```c++
class Solution {
public:
    int mergeStones(vector<int>& stones, int k) {
        int n = stones.size();
        if((n-k)%(k-1) != 0) return -1;  // 无法合并的情况
        int dp[n][n];//定义dp[i][j]为尽可能多的合并区间[i, j] 所需的成本
        memset(dp,0,sizeof(dp));
        int sum[n][n];
        memset(sum,0,sizeof(sum));
        for(int i=0;i<n;++i) sum[i][i] = stones[i];
        for(int i=n-1;i>=0;--i){
            for(int j=i+1;j<n;j++){
                sum[i][j] = sum[i][j-1]+stones[j];
                dp[i][j] = INT_MAX;
                for(int r=i;r<j;r+=k-1){
                    // 保证能把左部分合成一堆，尽可能的多合成右部分
                    dp[i][j] = min(dp[i][j],dp[i][r]+dp[r+1][j]);
                }
                // 如果能够合成一堆，需要额外加上合成的成本
                if((j-i+1-k)%(k-1)==0) dp[i][j] += sum[i][j];
            }
        }
        return dp[0][n-1];
    }
};
```



## 回文子串（LC 647）

**题目：[647. 回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindromic-substrings/)**

```c++
class Solution {
public:
    int countSubstrings(string s) {
        int n=s.size();
        int cnt=0;
        // dp[i][j]:s[i...j]是否是回文子串
        bool dp[n][n];
        memset(dp,0,sizeof(dp));
        for(int i=n-1;i>=0;--i){
            for(int j=i;j<n;++j){
                int len = j-i+1;
                if(len<=3){
                    if(s[i]==s[j]) dp[i][j] = true;
                    else dp[i][j] = false;
                }else{
                    if(s[i]==s[j]) dp[i][j] = dp[i+1][j-1];
                    else dp[i][j] = false;
                }
                if(dp[i][j]) cnt++;
            }
        }
        return cnt; 
    }
};
```



## （hard）不同的子序列||（LC 940）

**题目：[940. 不同的子序列 II - 力扣（LeetCode）](https://leetcode.cn/problems/distinct-subsequences-ii/)**

```c++
class Solution {
public:
    int distinctSubseqII(string s) {
        const long mod = 1e9 + 7;
        long endsWith[26] = {0}; // endsWith[i]来表示以第i个字母结束的sequence数量。
        for (char c : s)
            endsWith[c - 'a'] = accumulate(begin(endsWith), end(endsWith), 1L) % mod;
        return accumulate(begin(endsWith), end(endsWith), 0L) % mod;
    }
};
```



## (hard)统计不同回文子序列（LC 730）

**题目：[730. 统计不同回文子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/count-different-palindromic-subsequences/submissions/)**

```c++
class Solution {
public:
    const int mod = 1e9+7; 
    int countPalindromicSubsequences(string s) {
        int n = s.size();
        // dp[i][j]: s[i...j]的回文子序列的数量
        long dp[n][n];
        memset(dp,0,sizeof(dp));
        for(int i=0;i<n;++i) dp[i][i] = 1;
        for(int i=n-1;i>=0;--i){
            for(int j=i+1;j<n;++j){
                if(s[i]==s[j]){  // 相同
                    int l = i + 1, r = j - 1;
                    while (l <= r && s[l] != s[i])
                        l++;
                    while (l <= r && s[r] != s[i])
                        r--;
                    if(l>r)  // 没有相同的
                        dp[i][j] = 2*dp[i+1][j-1]+2;
                    else if(l==r) // 有一个相同的
                        dp[i][j] = 2*dp[i+1][j-1]+1;
                    else  // 有两个及以上的
                        dp[i][j] = 2*dp[i+1][j-1]-dp[l+1][r-1];
                }else  // 不相同
                    dp[i][j] = dp[i][j-1]+dp[i+1][j]-dp[i+1][j-1];
                dp[i][j] = (dp[i][j] >= 0) ? dp[i][j] % mod : dp[i][j] + mod;
            }
        }
        return dp[0][n-1];
    }
};
```



## （hard）接雨水（LC 42）

**题目：[42. 接雨水 - 力扣（LeetCode）](https://leetcode.cn/problems/trapping-rain-water/)**

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        // 解法四 按列栈模拟 

    }
    // 解法一 按行求
        /* auto height_max = *max_element(height.begin(),height.end());
        int rainSum=0;
        stack<int> st;  // 存放height的下标
        for(int i=1;i<=height_max;i++){
            for(int j=0;j<height.size();j++){
                if(st.empty() && height[j]>=i) st.push(j);
                else if(!st.empty() && height[j]>=i){
                    rainSum += j-st.top()-1;
                    st.pop();
                    st.push(j);
                }
            }
            while(!st.empty()) st.pop();
        }
        return rainSum; */

    // 解法二 按列求
        /* int rainSum=0;
        for(int i=1;i<height.size()-1;i++){
            int leftMax=0;  // 左边的最大高度的下标
            int rightMax=height.size()-1;  // 右边的最大高度的下标
            for(int j=0;j<i;j++){
                if(height[j]>height[leftMax]) leftMax=j;
            }
            for(int j=height.size()-1;j>i;j--){
                if(height[j]>height[rightMax]) rightMax=j;
            }
            int minHeight = min(height[leftMax],height[rightMax]);
            if(minHeight>height[i]) rainSum += minHeight-height[i]; 
        }
        return rainSum; */

    // 解法三 动态规划
        /* int n = height.size();
        int *dpLeftMax = new int[n];  // 第i个下标左边的最大高度
        int *dpRightMax = new int[n];  // 第i个下标右边的最大高度
        // 初始化
        dpLeftMax[0] = height[0];
        dpRightMax[n-1] = height[n-1];
        // 填表
        for(int i=1;i<n;i++)
            dpLeftMax[i] = max(dpLeftMax[i-1],height[i]);
        for(int i=n-2;i>=0;i--)
            dpRightMax[i] = max(dpRightMax[i+1],height[i]);
        // 计算雨水量
        int rainSum=0;
        for(int i=1;i<n-1;i++){
            int minHeight = min(dpLeftMax[i],dpRightMax[i]);
            if(minHeight>height[i]) rainSum += minHeight-height[i];
        }
        return rainSum; */
};
```

## 多边形三角剖分的最低分（LC 1039）

**题目：[1039. 多边形三角剖分的最低得分 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/)**

```c++
class Solution {
public:
    int minScoreTriangulation(vector<int>& values) {
        int n = values.size();
        // dp[i][j]:i~j的最低得分
        int dp[n][n];memset(dp,0,sizeof(dp));
        for(int len = 3;len<=n;++len){
            for(int i=0;i<n;++i){
                int j = i + len - 1;
                if(j > n-1) continue;
                dp[i][j] = INT_MAX;
                for(int k=i+1;k<=j-1;++k){
                    dp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]+values[i]*values[j]*values[k]);
                }
            }
        }
        return dp[0][n-1];
    }
};
```

## 二叉树的最大路径和（LC 124）

**题目：[124. 二叉树中的最大路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)**

```c++
class Solution {
public:
    int maxPath=INT_MIN;
    int dfs(TreeNode* root){
        if(root==NULL) return 0;
        int left = dfs(root->left);
        int right = dfs(root->right);
        if(left < 0 && right < 0) {
            maxPath = max(maxPath,root->val);
            return root->val;
        }
        if(left < 0) {
            maxPath = max(maxPath,right+root->val);
            return right+root->val;
        }
        if(right < 0) {
            maxPath = max(maxPath,left+root->val);
            return left+root->val;
        }
        maxPath = max(maxPath,left+right+root->val);
        return max(left,right)+root->val;
    }
    int maxPathSum(TreeNode* root) {
        dfs(root);
        return maxPath;
    }
};
```

## 没有上司的舞会（LG P1352）

**题目：[P1352 没有上司的舞会 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1352)**

```c++
#include <algorithm>
#include <cstdio>
using namespace std;

struct edge {
  int v, next;
} e[6005];

int head[6005], n, cnt, f[6005][2], ans, is_h[6005], vis[6005];

void addedge(int u, int v) {  // 建图
  e[++cnt].v = v;
  e[cnt].next = head[u];
  head[u] = cnt;
}

void calc(int k) {
  vis[k] = 1;
  for (int i = head[k]; i; i = e[i].next) {  // 枚举该结点的每个子结点
    if (vis[e[i].v]) continue;
    calc(e[i].v);
    f[k][1] += f[e[i].v][0];
    f[k][0] += max(f[e[i].v][0], f[e[i].v][1]);  // 转移方程
  }
  return;
}

int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; i++) scanf("%d", &f[i][1]);
  for (int i = 1; i < n; i++) {
    int l, k;
    scanf("%d%d", &l, &k);
    is_h[l] = 1;
    addedge(k, l);
  }
  for (int i = 1; i <= n; i++)
    if (!is_h[i]) {  // 从根结点开始DFS
      calc(i);
      printf("%d", max(f[i][1], f[i][0]));
      return 0;
    }
}

```

## 骑士拨号键（LC 935）

**题目：[935. 骑士拨号器 - 力扣（LeetCode）](https://leetcode.cn/problems/knight-dialer/)**

```c++
class Solution {
public:
    vector<vector<int>> dir{{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};
    const int mod = 1e9+7;
    int knightDialer(int n) {
        int f[n+1][10];  // 长度为i，以j结尾的个数
        memset(f,0,sizeof(f));
        for(int j=0;j<=9;++j) f[1][j] = 1;
        for(int i=1;i<=n;++i){
            for(int j=0;j<=9;++j){
                for(int x:dir[j]) {
                    f[i][j] = (f[i][j] + f[i-1][x])%mod;
                }
            }
        }
        int sum=0;
        for(int i=0;i<10;++i){
            sum = (sum+f[n][i])%mod;
        }
        return sum;
    }
};
```

## (hard)参加考试的最大学生数（LC 1349）

**题目：[1349. 参加考试的最大学生数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-students-taking-exam/)**

```c++
class Solution {
public:
    bool isVaild(int i,int state,vector<vector<char>>& seats){  // 检查是否相邻和是否有椅子
        bitset<8> bs(state);
        for(int p=0;p<seats[0].size()-1;++p){
            if(bs[p] && bs[p]==bs[p+1]) return false;
            if(bs[p] && seats[i][p]=='#') return false;
        }
        if(bs[seats[0].size()-1] && seats[i][seats[0].size()-1]=='#') return false;
        return true;
    }
    int maxStudents(vector<vector<char>>& seats) {
        int m=seats.size(),n=seats[0].size();
        // f[i][j]：第i行j状态最大的人数
        int f[m][1 << n];memset(f,0,sizeof(f));
        for(int state=0;state<(1 << n);++state){  // 初始化
            if(isVaild(0,state,seats)){
                bitset<8> bs(state);
                f[0][state] = (int)bs.count();
            } else {
                f[0][state] = -1;
                continue;
            }
        }
        // 填表
        for(int i=1;i<m;++i){
            for(int state=0;state<(1 << n);++state){
                if(isVaild(i,state,seats)){
                    for(int s=0;s<(1 << n);++s){
                        if(isVaild(i-1,s,seats)){
                            bitset<8> bs(state);
                            bitset<8> bss(s);
                            bool tag=true;
                            for(int p=0;p<8;++p){  // 筛选合法的上一行
                                if(p > 0 && p < 7){
                                    if(bs[p] && (bss[p-1]==bs[p]||bss[p+1]==bs[p])){tag=false;break;}
                                }else if(p > 0){
                                    if(bs[p] && bss[p-1]==bs[p]) {tag=false;break;}
                                }else{
                                    if(bs[p] && bss[p+1]==bs[p]) {tag=false;break;}
                                }
                            }
                            if(tag) f[i][state] = max(f[i][state],f[i-1][s]+(int)bs.count());
                        } else {
                            continue;
                        }
                    }
                } else {
                    f[i][state] = -1;
                    continue;
                }
            }
        }
        auto res = *max_element(f[m-1],f[m-1]+ (1 << n));
        return res;
    }
};
```

## 优美的排列（LC 526）

**题目：[526. 优美的排列 - 力扣（LeetCode）](https://leetcode.cn/problems/beautiful-arrangement/)**

```c++
class Solution {
public:
    int countArrangement(int n) {
        int mask = 1 << n;
        int f[n+1][mask];
        memset(f,0,sizeof(f));
        f[0][0] = 1;
        for(int i=1;i<=n;++i){
            for(int state=0;state<mask;++state){
                int tp = state;
                int cnt = 0;
                while(tp != 0){
                    if(tp & 1) cnt++;
                    tp >>= 1;
                }
                if(cnt != i) continue;
                for(int k=1;k<=n;++k){
                    if(state&(1<<(k-1)) == 0) continue;
                    if(!(k%i==0 || i%k==0)) continue;
                    f[i][state] += f[i-1][state&(~(1<<(k-1)))];
                }
            }
        }
        for(int i=0;i<=n;++i){
            for(int j=0;j<mask;++j){
                cout<<f[i][j]<<" ";
            }
            cout<<endl;
        }
        return f[n][mask - 1];
    }
};
```

## 我能赢吗（LC 464）

**题目：[464. 我能赢吗 - 力扣（LeetCode）](https://leetcode.cn/problems/can-i-win/)**

```c++

```

## 度的数量

**题目：**

![20201006182133577](初学上课笔记.assets\20201006182133577.png)

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 35;
int c[N][N];
int l, r, K ,B;
void init(){
	for(int i=1;i<=N;++i){
		for(int j=0;j<=i;++j){
			if(j==0) c[i][j] = 1;
			else{
				c[i][j] = c[i-1][j-1] + c[i-1][j];
			}
		}
	}
}

int dp(int n){
    if(n==0) return 0;
    vector<int>nums;
    while(n>0) nums.push_back(n%B),n /= B;
    int res=0;
    int last=0;  // 有几个1
    for(int i=nums.size()-1;i>=0;--i){  // 每个位置只能取0或者1
        int x = nums[i];
        if(x > 0){
            res += c[i][K - last];
            if(x > 1){
                if(K - last - 1 >= 0) res += c[i][K - last -1];
                break;
            } else {
                last++;
                if(last > K) break;
            }
        }
        if(i==0 && last==K) res++;
    }
    return res;
}
int main() {
	init();
    cin >> l >> r >> K >> B;
    cout << dp(r) - dp(l-1) << endl;
	system("pause");
	return 0;
}

```

## 数字游戏

**题目：**

![屏幕截图_20221218_202539](初学上课笔记.assets\屏幕截图_20221218_202539.png)

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 15;
int f[N][N];  // 长度为i的，最高位取j的数量
int l, r;
void init(){
	for(int i=0;i<=N;++i) f[1][i] = 1;
    for(int i=2;i<=N;++i){
        for(int j=0;j<=9;++j){
            for(int k=j;k<=9;++k){
                f[i][j] += f[i-1][k];
            }
        }
    }
}

int dp(int n){
    if(n==0) return 1;
    vector<int>nums;
    while(n>0) nums.push_back(n%B),n /= B;
    int res=0;
    int last=0;  // 有几个1
    for(int i=nums.size()-1;i>=0;--i){  // 每个位置只能取0或者1
        int x = nums[i];
        for(int j=last;j<x;++j){
            res += f[i+1][j];
        }
        if(x < last) break;
        last = x;
        if(i==0) res++ ;
    }
    return res;
}
int main() {
	init();
    while(cin >> l >> r)
        cout << dp(r) - dp(l-1) << endl;
	system("pause");
	return 0;
}

```

## Windy数

**题目：[P2657 [SCOI2009\] windy 数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2657)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 15;
int f[N][N];  // 长度为i的，最高位取j的数量
int l, r;
void init(){
	for(int i=0;i<=9;++i) f[1][i] = 1;
    for(int i=2;i<N;++i)
        for(int j=0;j<=9;++j)
            for(int k=0;k<=9;++k)
                if(abs(j-k) >= 2){
                    f[i][j] += f[i-1][k];
                }
}
// Windy 数
int dp(int n){
    if(n==0) return 0;
    vector<int> nums;
    int res=0;
    int last=-2;
    while(n) nums.push_back(n % 10), n /= 10;
    for(int i=nums.size()-1;i>=0;--i){
        int x = nums[i];
        for(int j= i==nums.size()-1;j<x;++j){
            if(abs(j-last) >= 2)
                res += f[i+1][j];
        }
        if(abs(x-last) >= 2) last = x;
        else break;
        if(i==0) res++ ;
    }
    // 特殊处理含有前导零的
    for(int i=1;i<nums.size();++i){
        for(int j=1;j<=9;++j){
            res += f[i][j];
        }
    }
    return res;
}
int main() {
	init();
    cin >> l >> r;
    cout << dp(r) - dp(l-1) << endl;
	system("pause");
	return 0;
}

```

## 数字游戏||

**题目：**

![网页捕获_19-12-2022_114247_www.cnblogs.com](初学上课笔记.assets\网页捕获_19-12-2022_114247_www.cnblogs.com.jpeg)

```C++
#include <bits/stdc++.h>
using namespace std;
const int N = 15;
const int M = 100;
int f[N][10][M];  // 长度为i的，最高位取j,模结果为k的的数量
int l, r, P;
int mod(int x,int y){
    return (x % y + y) % y;
}
void init(){
    memset(f,0,sizeof(f));
	for(int i=0;i<=9;++i) f[1][i][mod(i,P)] = 1;
    for(int i=2;i<N;++i)
        for(int j=0;j<=9;++j)
            for(int k=0;k<P;++k)
                for(int x=0;x<=9;++x)
                    f[i][j][k] += f[i-1][x][mod(j-k,P)];
            
}
// 数字游戏 II
int dp(int n){
    if(n==0) return 1;
    vector<int> nums;
    int res=0;
    int last=0;
    while(n) nums.push_back(n % 10), n /= 10;
    for(int i=nums.size()-1;i>=0;--i){
        int x = nums[i];
        for(int j=0;j<x;++j){
            res += f[i+1][j][mod(-last,P)];
        }
        last += x;
        if(i==0 && last % P == 0) res++;
    }
    return res;
}
int main() {
    while(cin >> l >> r >> P){
        init();
        cout << dp(r) - dp(l-1) << endl;
    }
	system("pause");
	return 0;
}

```

## 不要62

**题目：[Problem - 2089 (hdu.edu.cn)](http://acm.hdu.edu.cn/showproblem.php?pid=2089)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 15;
int f[N][10];  // 长度为i的，最高位取j的数量
int l, r;
void init(){
    for(int i=0;i<=9;++i) if(i!=4) f[1][i] = 1;
    for(int i=2;i<N;++i)
        for(int j=0;j<=9;++j){
            if(j==4) continue;
            for(int k=0;k<=9;++k){
                if(k==4) continue;
                if(k==2 && j==6) continue;
                f[i][j] += f[i-1][k];
            }
        }
}
int dp(int n){
    if(n==0) return 1;
    vector<int> nums;
    int res=0;
    int last=0;
    while(n) nums.push_back(n % 10), n /= 10;
    for(int i=nums.size()-1;i>=0;--i){
        int x = nums[i];
        for(int j=0;j<x;++j){
            if(j==4 ||(last==6 && j==2)) continue;
            res += f[i+1][j];
        }
        if(x==4 || (last==6 && x==2)) break;
        last = x;
        if(i==0) res++ ;
    }
    return res;
}
int main() {
    init();
    while(cin >> l >> r,l||r){
        cout << dp(r) - dp(l-1) << endl;
    }
	system("pause");
	return 0;
}

```

## （hard）数字1的个数（LC 233）

**题目：[233. 数字 1 的个数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-digit-one/)**

```c++
class Solution {
public:
    static const int N = 11;
    int f[N][10];// 长度为i，最高位为j的最大数量
    void init(){
        memset(f,0,sizeof(f));
        f[1][1] = 1;
        for(int i=2;i<N;++i)
            for(int j=0;j<=9;++j){
                if(j==1) f[i][j] += (int)pow(10,(i-1));
                for(int k=0;k<=9;++k)
                    f[i][j] += f[i-1][k];
            }
    }
    int dp(int n){
        if(n==0) return 0;
        vector<int> nums;
        while(n) nums.push_back(n % 10), n /= 10;
        int res=0;
        for(int i=nums.size()-1;i>=0;--i){
            int x = nums[i];
            for(int j=0;j<x;++j){
                res += f[i+1][j];
            }
            if(x==1){
                int t=0;
                for(int j=i-1;j>=0;--j) t += pow(10,j)*nums[j];
                res += t+1;
            }
        }
        return res;
    }
    int countDigitOne(int n) {
        init();
        return dp(n);
    }
};
```

## （hard）最大为N的数字组合（LC 902）

**题目：[902. 最大为 N 的数字组合 - 力扣（LeetCode）](https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/comments/)**

```c++
class Solution {
public:
    static const int N = 11;
    int f[N][10];  // 长度为i，最高位为j的最大数量
    void init(vector<int>& v){
        memset(f,0,sizeof(f));
        for(int i=0;i<v.size();++i) f[1][v[i]] = 1;
        for(int i=2;i<N;++i){
            for(int j=0;j<v.size();++j){
                for(int k=0;k<v.size();++k){
                    f[i][v[j]] += f[i-1][v[k]];
                }
            }
        }
    }
    int dp(vector<int>& v,int n){
        if(n==0) return 0;
        vector<int> nums;
        while(n) nums.push_back(n % 10), n /= 10;
        int res=0;
        // 处理不含前导零的情况
        for(int i=nums.size()-1;i>=0;--i){
            int x = nums[i];
            for(int j=0; j<v.size() && v[j]<x ;++j){
                res += f[i+1][v[j]];
            }
            if(!binary_search(v.begin(),v.end(),x)) break;
            if(i==0) res++;
        }
        // 处理前导零的情况
        for(int i=1;i<nums.size();++i){
            for(int j=0;j<v.size();++j){
                res += f[i][v[j]];
            }
        }
        return res;
    }
    int atMostNGivenDigitSet(vector<string>& digits, int n) {
        vector<int> v;
        for(auto digit : digits){
            v.push_back(stoi(digit));
        }
        init(v);
        return dp(v,n);   
    }
};
```

## （hard）N次操作后的最大分数和（LC 1799）

**题目：[1799. N 次操作后的最大分数和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximize-score-after-n-operations/)**

```c++
class Solution {
public:
    int maxScore(vector<int>& nums) {
        int len = nums.size();
        int gccd[len][len];
        for(int i=0;i<len;++i){
            for(int j=0;j<len;++j){
                gccd[i][j] = gcd(nums[i],nums[j]);
            }
        }
        int f[1 << len];
        memset(f,0,sizeof(f));
        for(int s=0;s<(1<<len);++s){
            bitset<14> bs(s);
            if((int)bs.count() & 1) continue;
            if((int)bs.count() < 2) continue;
            for(int i=0;i<len;++i){
                if(!bs[i]) continue;
                for(int j=i+1;j<len;++j){
                    if(!bs[j]) continue;
                    f[s] = max(f[s],f[s^(1<<i)^(1<<j)]+(int)bs.count()/2*gccd[i][j]);
                }
            }
        }
        //for(int s=0;s<(1<<len);++s) cout << f[s] << " " ;
        return f[(1<<len)-1];
    }
};
```

## 比特位计数（LC 338）

**题目：[338. 比特位计数 - 力扣（LeetCode）](https://leetcode.cn/problems/counting-bits/)**

```c++
class Solution {
	public:
		vector<int> countBits(int n) {
            vector<int> dp(n + 1);
            for (int i = 1; i <= n; i ++) {
                if (i & 1) {
                    dp[i] = dp[i >> 1] + 1;
                } else {
                    dp[i] = dp[i >> 1];
                }
            }
	    return dp;
	}
};
```

## 带限制的子序列和（LC 1425）

**题目：[1425. 带限制的子序列和 - 力扣（LeetCode）](https://leetcode.cn/problems/constrained-subsequence-sum/)**

```c++
class Solution {
public:
    int constrainedSubsetSum(vector<int>& nums, int k) {
        int n = nums.size() ; auto f = vector<int>(n) ; deque<int> dq ;
        for(int i=0;i<n;++i) f[i] = nums[i] ; int ans = INT_MIN ;
        for(int i=0;i<n;++i) {
            if(dq.size() && i - dq.front() > k) dq.pop_front() ;
            if(dq.size()) f[i] = max(f[i], f[dq.front()] + nums[i]) ;
            while(dq.size() && f[dq.back()] <= f[i]) dq.pop_back() ; 
            dq.push_back(i) ; ans = max(ans , f[i]) ;
        }
        return ans ;
    }
};
```

## 相邻字符不同的最长路径（LC 2246）

**题目：[2246. 相邻字符不同的最长路径 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/)**

```c++
class Solution {
public:
    int longestPath(vector<int>& fa, string s) {
        // 树形DP
        int n = fa.size() ; vector<int> e[n] ;
        for(int i=1;i<fa.size();++i){
            e[fa[i]].push_back(i) ;
        }
        int ans = 0 ;
        function<int(int)> dfs = [&](int u){
            int dia = 0 ;
            for(auto v : e[u]){
                int d = dfs(v);
                if(s[u] != s[v]) {
                    ans = max(ans , dia + d + 1) ;
                    dia = max(dia , d) ;
                }
            }
            ans = max(ans,dia+1) ;
            return dia + 1;
        };
        dfs(0);
        return ans ;
    }
};
```

## ==World Final？World Cup！（NC）==

**题目：[B-World Final? World Cup! (II)_2023牛客寒假算法基础集训营1 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/46800/B)**

```c++
#include <bits/stdc++.h>
#define int long long
const int N = 41 , M = 121 , K = 101 ;
const int P = 998244353 ;

int dp[N][M][K][K] ; // 第i场，获得j分，我们x分，他们y分的方案数
int line[M][K][K] , up[M][K][K] , down[M][K][K] ;
void solve(){
    int n , m , x , y ;
    std::cin >> n >> m >> x >> y ;
    
    dp[0][0][0][0] = 1 ;
    for(int i=1;i<=n;++i){
        for(int j=0;j<=3*i;++j) {  // 前缀和优化
            for(int p=0;p<=x;++p){
                down[j][p][0] = line[j][p][0] = dp[i-1][j][p][0] ; // 下三角的总数
            }
            for(int q=0;q<=y;++q){
                up[j][0][q] = line[j][0][q] = dp[i-1][j][0][q] ;  // 上三角的总数
            }
            for(int p=0;p<=x;++p){
                for(int q=0;q<=y;++q){
                    if(p > 0 && q > 0) line[j][p][q] = (line[j][p-1][q-1] + dp[i-1][j][p][q]) % P ;  // 对角线的总数
                }
            }
            for(int p=0;p<=x;++p){
                for(int q=0;q<=y;++q){
                    if(p > 0) up[j][p][q] = (line[j][p][q] + up[j][p-1][q]) % P ;
                    if(q > 0) down[j][p][q] = (line[j][p][q] + down[j][p][q-1]) % P ;
                }
            }
        }
        
        for(int j=0;j<=3*i;++j) {
            for(int p=0;p<=x;++p){
                for(int q=0;q<=y;++q){
                    if(j > 0){
                        dp[i][j][p][q] = (dp[i][j][p][q]+line[j-1][p][q]) % P ;
                    } 
                    if(j >= 3 && p > 0) {
                        dp[i][j][p][q] = (dp[i][j][p][q]+up[j-3][p-1][q]) % P ;
                    }
                    if(q > 0) dp[i][j][p][q] = (dp[i][j][p][q]+down[j][p][q-1]) % P ;
//                     for(int dog=0;dog<=p;++dog){
//                         for(int cat=0;cat<=q;++cat){
//                             if(dog == cat && j > 0) {
//                                 dp[i][j][p][q] = (dp[i][j][p][q]+dp[i-1][j-1][p-dog][q-cat]) % P ;
//                             } else if(dog > cat && j >= 3){
//                                 dp[i][j][p][q] = (dp[i][j][p][q]+dp[i-1][j-3][p-dog][q-cat]) % P ;
//                             } else if(dog < cat){
//                                 dp[i][j][p][q] = (dp[i][j][p][q]+dp[i-1][j][p-dog][q-cat]) % P ;
//                             }
//                         }
//                     }   
                }
            }
        }
    }
    
    int ans = 0 ;
    for(int j=m;j<=3*n;++j) {  // 统计得分大于m的总数
        ans = (ans + dp[n][j][x][y]) % P ;
    }
    std::cout << ans << std::endl ;
}

signed main(){
    std::ios::sync_with_stdio(false) ;
    std::cin.tie(nullptr) ;
    std::cout.tie(nullptr) ;
    
    solve() ;
    
    return 0 ;
}
```

## 坏区间最少的字符串（NC）

**题目：[K-本题主要考察了dp_2023牛客寒假算法基础集训营1 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/46800/K)**

```c++
#include <bits/stdc++.h>

using i64 = long long ;
const int N = 1e3+10 ;

int dp[N][N][4] ; // 长度为i的字符串有j个1并且以00，01，10，11结尾的最少坏区间
void solve(){
    int n , m ; 
    std::cin >> n >> m ; 
    
    memset(dp,0x3f,sizeof(dp)) ;
    dp[2][0][0] = 0 ; dp[2][1][1] = dp[2][1][2] = 0 ; dp[2][2][3] = 0 ;
    for(int i=0;i<=n;++i) for(int p=0;p<=3;++p) dp[i][0][p] = 0 ;
    for(int i=3;i<=n;++i){
        for(int j=1;j<=i;++j){
            dp[i][j][0] = std::min(dp[i][j][0] , dp[i-1][j][0]) ;
            dp[i][j][0] = std::min(dp[i][j][0] , dp[i-1][j][2]) ;
            dp[i][j][1] = std::min(dp[i][j][1] , dp[i-1][j-1][0]) ;
            if(j > 1) dp[i][j][1] = std::min(dp[i][j][1] , dp[i-1][j-1][2] + 1) ;
            dp[i][j][2] = std::min(dp[i][j][2] , dp[i-1][j][1]) ;
            if(j > 1) dp[i][j][2] = std::min(dp[i][j][2] , dp[i-1][j][3] + 1) ;
            if(j > 1) dp[i][j][3] = std::min(dp[i][j][3] , dp[i-1][j-1][1] + 1) ;
            if(j > 2) dp[i][j][3] = std::min(dp[i][j][3] , dp[i-1][j-1][3] + 1) ;   
        }
    }
    
    int ans = 1e9 ;
    for(int i=0;i<=3;++i) {
        ans = std::min(ans,dp[n][m][i]) ;
    }
    
    std::cout << ans << '\n' ;
}

int main(){
    std::ios::sync_with_stdio(false) ;
    std::cin.tie(nullptr) ;
    
    solve() ;
    
    return 0 ;
}
```

## 最长重复子数组

**题目：[718. 最长重复子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)**

```c++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size() , m = nums2.size() ; int ans = 0 ;
        vector<vector<int>> dp(n + 1,vector<int>(m + 1)) ;
        for(int i=1;i<=n;++i){
            for(int j=1;j<=m;++j){
                if(nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1 , ans = max(ans , dp[i][j]) ;
                else dp[i][j] = 0 ;
            }
        }
        return ans ;
    }
};
```

## 移除素有再有违禁车厢所需要的最少时间

**题目：[2167. 移除所有载有违禁货物车厢所需的最少时间 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/)**

```c++
class Solution {
public:
    int minimumTime(string s) {
        int n = s.size() ; 
        vector<vector<int>> dp(n+1 , vector<int>(2 , INT_MAX)) ;
        dp[0][0] = dp[0][1] = 0 ; int ans = INT_MAX ;
        for(int i=1;i<=n;++i){
            if(s[i-1] == '1') {
                dp[i][0] = i ;
                dp[i][1] = min(dp[i-1][0] + 2 , dp[i-1][1] + 2) ;
            }else{
                dp[i][0] = dp[i-1][0] ;
                dp[i][1] = dp[i-1][1] ;
            }
            ans = min(ans , min(dp[i][0],dp[i][1]) + n - i) ;
        }
        return ans ;
    }
};
```

## 最大子序列交替和

**题目：[1911. 最大子序列交替和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-alternating-subsequence-sum/)**

```c++
using ll = long long ;
class Solution {
public:
    long long maxAlternatingSum(vector<int>& nums) {
        int n = nums.size() ; ll dp1 , dp2 ;  // 单双讨论
        dp1 = nums[0] ; dp2 = 0 ;
        for(int i=1;i<n;++i){
            ll tp = dp1 ;
            dp1 = max(dp1 , dp2 + nums[i]) ;
            dp2 = max(dp2 , tp - nums[i]) ;
        }
        return max(dp1,dp2) ;
    }
};
```

## [古董键盘](https://leetcode.cn/problems/Uh984O/)

```c++
using ll = long long ;
class Solution {
private:
    const int P = 1e9 + 7 ;
    ll mod(ll x){return (x + P) % P ;}
public:
    int keyboard(int k, int n) {
        // 分组背包
        int dp[n + 1][27] ; memset(dp,0,sizeof(dp)) ;
        for(int i=0;i<27;i++) dp[0][i]=1; 
        for(int i=1;i<n+1;i++)
            for(int j=1;j<27;j++)
                for(int p=0;p<=k;p++){
                    //第i次按键盘，对j号字母键按了p次
                    if(i<p) continue;
                    dp[i][j] = mod(1LL*dp[i-p][j-1]*C(i,p) + dp[i][j]); 
                }                           
        return dp[n][26];
    }  
    int C(int m, int n){
        //求组合数
        int k=1;
        int ans=1;
        while(k<=n){
            ans=((m-k+1)*ans)/k;
            k++;
        }
        return ans;
    }
};
```

## [最多可以参加的会议数目 II](https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended-ii/)

```c++
class Solution {
public:
    int maxValue(vector<vector<int>>& events, int k) {
        int n = events.size() ; 
        sort(events.begin(),events.end(),[&](auto& e1,auto& e2){
            return e1[1] < e2[1] ;
        }) ;
        vector<int> v(n) ;
        for(int i=0;i<n;++i) v[i] = events[i][1] ;
        vector<vector<int>> dp(n + 1 , vector<int>(k + 1)) ;
        for(int j=1;j<=k;++j){
            for(int i=0;i<n;++i){
                int p = lower_bound(v.begin(),v.end(),events[i][0]) - v.begin() - 1 ;
                dp[i+1][j] = max(dp[i][j],dp[p + 1][j-1] + events[i][2]) ;
            }    
        }
        return dp[n][k] ;
    }
};
```

## [ 规划兼职工作](https://leetcode.cn/problems/maximum-profit-in-job-scheduling/)

```c++
class Solution {
public:
    struct node{int s,e,v;};
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        int n = startTime.size() ; vector<node> events(n) ;
        for(int i=0;i<n;++i) {
            -- endTime[i] ;
            events[i] = {startTime[i],endTime[i],profit[i]} ;
        }
        sort(events.begin(),events.end(),[&](auto& e1,auto& e2){
            return e1.e < e2.e ;
        }) ;
        vector<int> v(n) ;
        for(int i=0;i<n;++i) v[i] = events[i].e ;
        vector<int> dp(n + 1) ;
        for(int i=0;i<n;++i){
            int p = lower_bound(v.begin(),v.end(),events[i].s) - v.begin() - 1 ;
            dp[i+1] = max(dp[i],dp[p + 1] + events[i].v) ;
        }    
        return dp[n] ;
    }
};
```

## [ 掷骰子模拟](https://leetcode.cn/problems/dice-roll-simulation/)

```c++
using ll = long long ;
const ll P = 1e9 + 7 ;
inline ll mod(ll x,ll p=P) { return (x%p + p)%p;}
class Solution {
public:
    int dieSimulator(int n, vector<int>& c) {
        ll ans = 0 ; 
        int dp[n + 1][7][16] ; memset(dp,0,sizeof(dp)) ;

        for(int j = 1 ; j <= 6 ; ++ j) dp[0][j][0] = 1 ;
        for(int i = 1 ; i <= n ; ++ i)
            for(int j = 1 ; j <= 6 ; ++ j)
                for(int k = 1 ; k <= 6 ; ++ k)
                {
                    if(j == k)
                    {   
                        for(int p = 1 ; p <= c[k-1] ; ++ p)
                            dp[i][j][p] = mod(dp[i-1][k][p-1] + dp[i][j][p]) ;
                    }
                    else
                    {
                        for(int p = 1 ; p <= c[k-1] ; ++ p)
                            dp[i][j][1] = mod(dp[i-1][k][p] + dp[i][j][1]) ;
                    }
                }

        for(int j = 1 ; j <= 6 ; ++ j)
            for(int k = 1 ; k <= c[j-1] ; ++ k)
                ans = mod(ans + dp[n][j][k]) ;

        return ans ;
    }
};
```



# 背包问题

## 分割等和子集（LC 416）

**题目：[416. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/)**

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int n=nums.size();
        if(n==0) return true;
        if(n==1) return false;
        int sum=0;
        for(int i=0;i<n;i++)
            sum+=nums[i];
        if(sum%2==1) return false;
        int bag = sum/2;
        int dp[bag+1];
        dp[0] = 0;
        for(int i=1;i<=bag;i++) dp[i] = INT_MIN;
        for(int i=1;i<=n;i++){
            for(int j=bag;j>=nums[i-1];j--){
                if(dp[j-nums[i-1]] == INT_MIN) continue;
                dp[j] = max(dp[j],dp[j-nums[i-1]]+nums[i-1]);
            }
        }
        if(dp[bag] == INT_MIN) return false;
        return true;
    }
};
```

## 目标零（LC 494）

**题目：[494. 目标和 - 力扣（LeetCode）](https://leetcode.cn/problems/target-sum/)**

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        if(nums.size() == 0) return 0;
        int sum = 0;
        for(int i = 0; i < nums.size(); i++) sum += nums[i];
        if (abs(target) > abs(sum)) return 0;
        vector<vector<int>> dp(nums.size(),vector<int>(sum*2+1,0));  // dp[i][j]:nums[i]之前和为j-sum的方法数
        if(nums[0] == 0) dp[0][sum] = 2;  // 和为零有两种方法
        else{
            dp[0][sum+nums[0]] = 1;  // 初始化
            dp[0][sum-nums[0]] = 1;
        }
        
        for(int i = 1; i<nums.size(); i++){  // 填表
            for(int j = sum; j<(sum*2+1);j++){
                // 边界条件填表
                if(j+nums[i]<0 || j-nums[i]<0 || j+nums[i]>sum*2 || j-nums[i]>sum*2){ 
                    if(j+nums[i]>=0 && j+nums[i]<=sum*2) dp[i][j] = dp[i-1][j+nums[i]];
                    if(j-nums[i]>=0 && j-nums[i]<=sum*2) dp[i][j] = dp[i-1][j-nums[i]];
                }else{  // 状态转化方程
                    dp[i][j] = dp[i-1][j+nums[i]]+dp[i-1][j-nums[i]];
            }
        }
        return dp[nums.size()-1][sum+target];
    }
};
```

## 零钱兑换|（LC 322）

**题目：[322. 零钱兑换 - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change/)**

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();
        int m = amount;
        int dp[m+1]; // dp[j]表示前i个凑成j金额的最少硬币数
        // 初始化
        dp[0]=0;
        for(int i=1;i<=m;i++) dp[i] = INT_MAX;
        // 填表
        for(int i=1;i<=n;i++){
            for(int j=coins[i-1];j<=m;j++){
                if(dp[j-coins[i-1]] == INT_MAX) continue;
                dp[j] = min(dp[j],dp[j-coins[i-1]]+1);
            }
        }
        if(dp[m]!=INT_MAX){
            return dp[m];
        }
        return -1;
    }
};
```

## 零钱兑换||（LC 518）

**题目：[518. 零钱兑换 II - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change-ii/)**

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int n = coins.size();
        int m = amount;
        int * dp = new int[m+1]{1};  // dp[i][j]表示前i个凑成j金额的方法数
        for(int i=0;i<n;i++){
            for(int j=coins[i];j<=m;j++){
                dp[j] = dp[j]+dp[j-coins[i]];
            }
        }
        return dp[m];
    }
};
```

## 完全平方数（LC 279）

**题目：[279. 完全平方数 - 力扣（LeetCode）](https://leetcode.cn/problems/perfect-squares/comments/)**

```c++
class Solution {
public:
    // 完全背包问题，每个数价值为1，求最小价值
    int numSquares(int n) {
        vector<int> PF;  // PF平方的数组，体积
        for(int i=1;i<=sqrt(n);i++)
            PF.push_back(i*i);
        auto dp = vector<int>(n+1,INT_MAX);
        dp[0] = 0;
        for(int i=1;i<=PF.size();i++){
            for(int j=PF[i-1];j<=n;j++){
                dp[j] = min(dp[j],dp[j-PF[i-1]]+1);
            }
        }
        return dp[n];
    }
};
```

## 选学霸（LG P2170）

**题目：[P2170 选学霸 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2170)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 20001;
int fa[N],siz[N],n,m,k;
int find(int x){
	if(x==fa[x]) return x;
	return fa[x] = find(fa[x]);
}
void unionset(int x,int y){
	int fx = find(x);
	int fy = find(y);
	if(fx==fy) return;
	fa[fx] = fy;
	siz[fy] += siz[fx];
}

int main() {
	cin>>n>>m>>k;
	if(k==0){
	    cout<<m<<endl;
	    return 0;
	}
	int t1,t2;
	for(int i=1;i<=n;++i) fa[i] = i,siz[i] = 1;
	for(int i=1;i<=k;++i){
		cin>>t1>>t2;
		unionset(t1,t2);
	}
	vector<int> v(1);
	for(int i=1;i<=n;++i){
		if(fa[i]==i){
			v.push_back(siz[i]);
		}
	}
	int dp[2*m+1];
	memset(dp,0,sizeof(dp));
	for(int i=1;i<v.size();++i){
		for(int j=2*m;j>=v[i];--j){
			dp[j] = max(dp[j],dp[j-v[i]]+v[i]);
		}
	}
	if(dp[m] == m){
		cout<<m<<endl;
	} else {
		int ans,min=INT_MAX;
		for(int i=m;i<=2*m;++i){
			if(min > abs(dp[i]-m)) ans=dp[i],min=abs(dp[i]-m);
		}
		cout<<ans<<endl;
	}
	system("pause");
	return 0;
}

```

## 采药（LG P1048）

**题目：[P1048 [NOIP2005 普及组\] 采药 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1048)**

```c++
#include <bits/stdc++.h>
using namespace std ; 
const int N = 1e3 + 10 , M = 1e3+10;
int n , m ; int f[M] , v[N] , w[N] ; 
int main(){
    cin >> m >> n ; 
    for(int i=1;i<=n;++i) cin >> v[i] >> w[i] ;
    for(int i=1;i<=n;++i) for(int j=m;j>=v[i];--j){
        f[j] = max(f[j] , f[j-v[i]] + w[i]);
    }
    cout << f[m] << endl ;
    system("pause") ;
}
```

## 装箱问题（LG P1049）

**题目：[P1049 [NOIP2001 普及组\] 装箱问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1049)**

```c++
#include <bits/stdc++.h>
using namespace std ; 
const int N = 1e6 + 10 , M = 1e6+10;
int n , m ; int f[M] , v[N]; 
int main(){
    cin >> m >> n ; 
    for(int i=1;i<=n;++i) cin >> v[i] ;
    for(int i=1;i<=n;++i) for(int j=m;j>=v[i];--j){
        f[j] = max(f[j] , f[j-v[i]] + v[i]);
    }
    cout << m - f[m] << endl ;
    system("pause") ;
}
```

## 精卫填海（LG P1510）

**题目：[P1510 精卫填海 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1510)**

```c++
#include <bits/stdc++.h>
using namespace std ; 
const int N = 1e6 + 10 , M = 1e6+10;
int v , n , c ; int f[M] , k[N] , m[N] ; 
int main(){
    cin >> v >> n >> c ; 
    for(int i=1;i<=n;++i) cin >> k[i] >> m[i] ;
    for(int i=1;i<=n;++i) for(int j=c;j>=m[i];--j){
        f[j] = max(f[j] , f[j-m[i]] + k[i]);
    }
    for(int i=0;i<=v;++i){
        if(f[i] >= v) {cout << c - i << endl ; return 0 ;}; 
    }
    cout << "Impossible" << endl;
    system("pause") ;
}
```

## 刷题大军（LG P1926）

**题目：[P1926 小书童——刷题大军 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1926)**

```c++
#include <bits/stdc++.h>
using namespace std ; 
const int N = 1e6 + 10 , M = 1e6+10;
int n , m , k , r ; int like[N] , v[N] , w[N] ; int f[N] ;
int main(){
    cin >> n >> m >> k >> r ; 
    for(int i=1;i<=n;++i) cin >> like[i] ;
    for(int i=1;i<=m;++i) cin >> v[i] ;
    for(int i=1;i<=m;++i) cin >> w[i] ;
    for(int i=1;i<=n;++i) for(int j=r;j>=v[i];--j) 
        f[j] = max(f[j] , f[j - v[i]] + w[i]) ;
    int shen = 0 ;
    for(int i=0;i<=r;++i) if(f[i] >= k) {shen = r - i ; break ;}  // 寻找出最多可以剩下多少时间
    sort(like+1,like+1+n) ;  // 对喜欢的题目的时间进行排序
    int ans = 0 , sum = 0 ;
    for(int i=1;i<=n;++i) {
        sum += like[i] ;
        if(sum <= shen) ans++ ; 
    }
    cout << ans << endl ;
    system("pause") ;
}
```

## yyy2015c01的U盘（LG P2370）

**题目：[P2370 yyy2015c01 的 U 盘 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2370)**

```c++
#include <bits/stdc++.h>
#define v(i) nodes[i].v
#define w(i) nodes[i].w
using namespace std ; 
const int N = 1e6 + 10 , M = 1e6+10;
int n , p , s ; int f[N] ;
struct node{int v,w;} nodes[N] ;
int main(){
    cin >> n >> p >> s ;
    for(int i=1;i<=n;++i) cin >> v(i) >> w(i) ;
    sort(nodes+1,nodes+1+n,[&](auto& e1,auto& e2){
        return e1.v < e2.v ;
    }) ;
    for(int i=1;i<=n;++i) for(int j=s;j>=v(i);--j){
        f[j] = max(f[j] , f[j -v(i)] + w(i)) ;
        if(f[j] >= p) {cout << v(i) << endl; return 0 ;}
    }
    cout << "No Solution!" << endl ;
    system("pause") ;
}
```

## Shaass and Bookshelf (CF294B)

**题目”：[Shaass and Bookshelf - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/CF294B)**

```c++
#include <bits/stdc++.h>
using namespace std ;
int v[105], w[105]; //厚度 宽度
int dp[205]; //背包的最大容量是所有书的厚度总和(n<=100 厚度<=2)
int main()
{
	int n, totLen=0;
	scanf("%d", &n);
	for( int i=1; i<=n; i++ ){
		scanf("%d %d", &v[i], &w[i]);
		totLen += v[i]; //总厚度
	}
	for( int i=1; i<=totLen; i++ )
		dp[i] = 10086; //初始化
	for( int i=1; i<=n; i++ ) //当前放第 i 本书
		for( int j=totLen; j>=v[i]; j-- ) // j是当前书架长度(等效于背包容量)
			dp[j] = min( dp[j], dp[ j-v[i] ]+w[i] ); //dp表示选厚度和为 j 的若干本书横着放的最小值
	for( int i=totLen; i>=0; i-- ) //倒序查找
		if( totLen-i >= dp[i] ){ //左式是下层书的厚度和 右式是上层书的宽度和
			printf("%d\n", totLen-i);
			break;
		}
	system("pause");
	return 0;
}
```

## 消失之物（LG P4141）

**题目：[P4141 消失之物 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4141)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 2e3+10 ;
int n , m ; int f[N] , w[N] , g[N] ; // g[i] 表示当删掉某一个物品时，容量为i的方案数。
int main()
{
	cin >> n >> m ;
    for(int i=1;i<=n;++i) cin >> w[i] ;
    f[0] = 1 ;
    for(int i=1;i<=n;++i) for(int j=m;j>=w[i];--j){
        f[j] = (f[j] + f[j - w[i]])%10 ;
    }
    for(int i=1;i<=n;++i){
        memcpy(g,f,sizeof f);
        for(int j=w[i];j<=m;++j)  // 必须要顺推，恢复到上一个状态，物品递推的顺序无所谓，可以看作最后一个物品
            g[j]-=g[j-w[i]] , g[j] = (g[j]+10)%10;
        for(int j=1;j<=m;++j) cout << g[j]  ; cout << endl ;
    }
	system("pause");
	return 0;
}
```

## 垃圾陷阱（LG P1156）

**题目：[P1156 垃圾陷阱 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1156)**

```c++
#include <bits/stdc++.h>
#define t(x) trash[x].t 
#define f(x) trash[x].f
#define h(x) trash[x].h
using namespace std ;
const int N = 2e3+10 ;
int D , G ; struct node{int t,f,h;}trash[N] ; 
int f[N][N] ; // f[i][j]:前i件垃圾在j的高度下能达到的最多时间
int main()
{
	cin >> D >> G ;
    for(int i=1;i<=G;++i) cin >> t(i) >> f(i) >> h(i) ;
    sort(trash+1,trash+1+G,[&](auto& e1 , auto& e2){return e1.t < e2.t;});
    f[0][0] = 10 ;
    for(int i=1;i<=G;++i) for(int j=D;j>=0;--j) {
        if(f[i-1][j] >= t(i)) f[i][j] = max(f[i][j] , f[i-1][j] + f(i)) ;
        if(j >= h(i) && f[i-1][j-h(i)] >= t(i)) f[i][j] = max(f[i][j] , f[i-1][j-h(i)]) ;
    } 
    int maxt = 0 ;
    for(int i=1;i<=G;++i) {
        if(f[i][D] >= t(i)) {cout << t(i) << endl ; system("pause") ; return 0 ;} 
    }
    for(int i=0;i<=G;++i) for(int j=0;j<=D;++j) maxt = max(maxt,f[i][j]) ;
    cout << maxt << endl ;
	system("pause");
	return 0;
}
```

## 砝码称重（LG P1441）

**题目：[P1441 砝码称重 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1441)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 21 ;
int a[N] ; int n , m , all ; int ans ;
unordered_map<int,int> mp ;
int vis[N] ; int state ;  // 1代表未选取
// void dfs1(int sum,int last){
//     mp[sum] ;
//     for(int i=last+1;i<=n;++i){
//         if(state & (1 << i)) continue ;
//         dfs1(sum+a[i],i) ;
//     }
// }
int f[2100] ; // 第i件物品放入j的背包是否可行
void dp(){
    memset(f,0,sizeof(f)) ;
    f[0] = 1 ;
    for(int i=1;i<=n;++i){
        if(state & (1 << i)) continue ;
        for(int j=all;j>=a[i];--j) f[j] = max(f[j],f[j-a[i]]) ;
    } 
    int cnt = 0 ;
    for(int i=1;i<=all;++i) if(f[i]) cnt ++ ;
    ans = max(ans,cnt) ;
}
void dfs(int rej,int last){  // rej已经舍弃了几个
    if(rej == m){
        dp() ;
        return ;
    }
    for(int i=last+1;i<=n;++i) {
        state = state | (1 << i) ;
        dfs(rej+1,i) ;
        state = state & ~(1 << i) ;
    }
}
int main(){
    cin >> n >> m ;
    for(int i=1;i<=n;++i) scanf("%d",&a[i]) , all += a[i] ;
    dfs(0,0) ;
    cout << ans << endl ;
    system("pause") ;
}
```



# 贪心算法

## 跳跃游戏（LC 55）

**题目：[55. 跳跃游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game/)**

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        // 解法二 贪心算法
        int distanceMax=nums[0];  // 在该下标能到达的最远台阶
        for(int i=1;i<nums.size();i++){
            if(distanceMax<i) return false;
            distanceMax = max(distanceMax,nums[i]+i);
        }  
        return true;
    }
};
```



## 跳跃游戏||（LC 45）

**题目：[45. 跳跃游戏 II - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game-ii/)**

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        // 贪心算法经典题
        int n=nums.size();
        if(n==0) return 0;
        if(n==1) return 0;
        int maxPos=0;  // 每一段的可以到达的最远路径下标
        int step=0;  // 步数
        int maxtemp=0;  // 每次迭代最远路径下标
        for(int i=0;i<n;i++){
            maxtemp=max(maxtemp,nums[i]+i);  // 迭代
            if(maxPos==i){  // 如果达到最远的路径
                maxPos = maxtemp;  // 就再一次把这一段能到达的最远路径赋值
                if(maxPos<n-1) step++;  // 没有到达终点就步数加一
                else return ++step;  // 最远路径能够达到终点就走一步结束
            }
        }
        return step;
    }
};
```



## 分发饼干（LC 455）

**题目：[455. 分发饼干 - 力扣（LeetCode）](https://leetcode.cn/problems/assign-cookies/)**

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int p1=0,p2=0;
        int res=0;
        while(p1!=g.size() && p2!=s.size()){
            if(s[p2]>=g[p1]) res++,p2++,p1++;
            else p2++;
        }
        return res;
    }
};
```



## 摆动序列（LC 376）

**题目：[376. 摆动序列 - 力扣（LeetCode）](https://leetcode.cn/problems/wiggle-subsequence/)**

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        int curDiff = 0; // 当前一对差值
        int preDiff = 0; // 前一对差值
        int result = 1;  // 记录峰值个数，序列默认序列最右边有一个峰值
        for (int i = 0; i < nums.size() - 1; i++) {
            curDiff = nums[i + 1] - nums[i];
            // 出现峰值
            if ((curDiff > 0 && preDiff <= 0) || (preDiff >= 0 && curDiff < 0)) {
                result++;
                preDiff = curDiff;
            }
        }
        return result;
    }
};
```



## 最大子数组和（LC 53）

**题目：[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/)**

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        // 解法二 贪心算法
        int result = INT_MIN;
        int count = 0;
        for (int i = 0; i < nums.size(); i++) {
            count += nums[i];
            if (count > result) { // 取区间累计的最大值
                result = count;
            }
            if (count <= 0) count = 0; // 相当于重置最大子序起始位置
        }
        return result;
    }
};
```



## 买卖股票的最佳时机||（LC 122）

**题目：[122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 解法二 贪心算法
        int result = 0;
        for (int i = 1; i < prices.size(); i++) {
            result += max(prices[i] - prices[i - 1], 0);
        }
        return result;
    }
};
```



## K次取反后最大化的数组和（LC 1005）

**题目：[1005. K 次取反后最大化的数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)**

```c++
class Solution {
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        auto minHeap = priority_queue<int,vector<int>,greater<int>>(nums.begin(),nums.end());
        for(int i=0;i<k;i++){
            int temp = -minHeap.top();
            minHeap.pop();
            minHeap.push(temp);
        }
        int sum=0;
        while(!minHeap.empty()){
            sum+=minHeap.top();
            minHeap.pop();
        }
        return sum;
    }
};
```



## 加油站（LC 134）

**题目：[134. 加油站 - 力扣（LeetCode）](https://leetcode.cn/problems/gas-station/)**

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int totalSum = 0;
        int start = 0;
        for (int i = 0; i < gas.size(); i++) {
            curSum += gas[i] - cost[i];
            totalSum += gas[i] - cost[i];
            if (curSum < 0) {   // 当前累加rest[i]和 curSum一旦小于0
                start = i + 1;  // 起始位置更新为i+1
                curSum = 0;     // curSum从0开始
            }
        }
        if (totalSum < 0) return -1; // 说明怎么走都不可能跑一圈了
        return start;
    }
};
```



## （hard）分发糖果（LC 135）

**题目：[135. 分发糖果 - 力扣（LeetCode）](https://leetcode.cn/problems/candy/)**

```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        // 解法一 超时，直接顺序遍历 
        /* int minCount=1;
        int* Count=new int[ratings.size()];  // 每个小孩应该发的糖果数
        Count[0] = 1;
        for(int i=1;i<ratings.size();++i){
            if(ratings[i-1]>ratings[i]){
                Count[i] = 1;
                int p = i;
                while(p>0 && ratings[p-1]>ratings[p]){
                    int temp = max(Count[p-1],Count[p]+1);
                    minCount = minCount-Count[p-1]+temp;
                    Count[p-1] = temp;
                    p--;
                }
                ++minCount;
            }else if(ratings[i-1]<ratings[i]){
                minCount = minCount+Count[i-1]+1;
                Count[i] = Count[i-1]+1;
            }else{
                ++minCount;
                Count[i] = 1;
            }
        }
        return minCount; */

        // 解法二 顺序加逆序，两次贪心
        int minCount=1;
        int* Count=new int[ratings.size()];
        Count[0] = 1;
        for(int i=1;i<ratings.size();i++){  // 顺序贪心
            if(ratings[i-1]>=ratings[i]){
                Count[i] = 1;
                minCount = minCount+Count[i];
            }else if(ratings[i-1]<ratings[i]){
                Count[i] = Count[i-1]+1;
                minCount = minCount+Count[i];
            }
        }
        for(int i=ratings.size()-1;i>0;i--){  // 逆序贪心 
            if(ratings[i-1]>ratings[i] && Count[i-1]<=Count[i]){
                    minCount = minCount-Count[i-1]+Count[i]+1;
                    Count[i-1] = Count[i]+1;
            }
        }
        return minCount;
    }
};
```



## 柠檬水找零（LC 860）

**题目：[860. 柠檬水找零 - 力扣（LeetCode）](https://leetcode.cn/problems/lemonade-change/)**

```c++
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int five=0,ten=0;
        for(int i=0;i<bills.size();++i){
            if(bills[i]==5){
                five++;
            }else if(bills[i]==10){
                if(five==0) return false;
                ten++;five--;
            }else if(bills[i]==20){
                if((five==0&&ten!=0) || (ten==0&&five<3)) return false;
                if(ten != 0) ten--,five--;
                else five -= 3;
            }
        }
        return true;
    }
};
```



## 根据身高重建队列（LC 406）

**题目：[406. 根据身高重建队列 - 力扣（LeetCode）](https://leetcode.cn/problems/queue-reconstruction-by-height/)**

```c++
class Solution {
public:
    static bool cmp(const vector<int>& v1,const vector<int>& v2){
        if(v1[0]==v2[0]) return v1[1]<v2[1];
        else return v1[0]>v2[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(),people.end(),cmp);
        list<vector<int>> ans;
        ans.push_back(people[0]);
        for(int i=1;i<people.size();i++){
            int position = people[i][1]; // 插入到下标为position的位置
            list<vector<int>>::iterator it = ans.begin();
            while (position--) { // 寻找在插入位置
                it++;
            }
            ans.insert(it,people[i]);
        }
        return vector<vector<int>>(ans.begin(),ans.end());
    }
};
```



## 用最少数量的箭引爆气球（LC 452）

**题目：[452. 用最少数量的箭引爆气球 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)**

```c++
class Solution {
public:
    static bool cmp(const vector<int>& v1,const vector<int>& v2){
        return v1[0]<v2[0];
    }
    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(),points.end(),cmp);  
        int leftMax=points[0][0],rightMin=points[0][1];
        int res=0;
        for(int i=0;i<points.size();++i){
            if(points[i][0]>=leftMax  && points[i][0]<=rightMin){
                leftMax = max(leftMax,points[i][0]);
                rightMin = min(rightMin,points[i][1]);
            }else{
                ++res;
                leftMax = points[i][0];
                rightMin = points[i][1];
            }
        }
        return ++res;
    }
};
```



## 无重叠区间（LC 435）

**题目：[435. 无重叠区间 - 力扣（LeetCode）](https://leetcode.cn/problems/non-overlapping-intervals/)**

```c++
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(),intervals.end(),[]
            (const vector<int>& v1,const vector<int>& v2){
                if(v1[0]==v2[0]) return v1[1]<v2[1];
                else return v1[0]<v2[0];
            });
        int leftMax=intervals[0][0],rightMin=intervals[0][1];
        int res=0;  // 无重叠的区间数量
        for(int i=1;i<intervals.size();++i){
            if(intervals[i][0]>=leftMax  && intervals[i][0]<rightMin){
                leftMax = max(leftMax,intervals[i][0]);
                rightMin = min(rightMin,intervals[i][1]);
            }else{
                ++res;
                leftMax = intervals[i][0];
                rightMin = intervals[i][1];
            }
        }
        return intervals.size()-(++res);
    }
};
```



## 划分字母区间（LC 763）

**题目：[763. 划分字母区间 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-labels/)**

```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        auto res = vector<int>();  
        int idxMax=0;  // 当前划分区间的最大值下标
        for(int i=0;i<s.size();++i){
            idxMax = max(idxMax,(int)s.rfind(s[i]));
            if(idxMax==i) {
                res.push_back(i);  // 该区间最后一个的下标
                idxMax = i+1;
            }
        } 
        // 转换成为答案
        for(int i=res.size()-1;i>0;--i) res[i] -= res[i-1];
        res[0] += 1;
        
        return res;
    }
};
```

## 最低加油次数（LC 871）

**题目：[871. 最低加油次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-refueling-stops/)**

```c++
class Solution {
public:
    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {
        int n = stations.size();
        int ans=0;
        if(n>0 && startFuel<stations[0][0]) return -1;  // 边界条件
        priority_queue<int,vector<int>,less<int>> heap;  // 最大堆
        int currFuel=startFuel;
        for(int i=0;i<n;++i){
            heap.push(stations[i][1]);
            while(i<n-1&& currFuel<stations[i+1][0] && !heap.empty()){  // 加油直到能到达下一个加油站为止
                currFuel += heap.top();
                heap.pop();
                ++ans;
            }
            if(i<n-1&&currFuel<stations[i+1][0]) return -1;  // 到达不了加油站
        }
        while(currFuel<target && !heap.empty()){
            currFuel += heap.top();
            heap.pop();
            ++ans;
        }
        if(currFuel<target) return -1;  // 到达不了最后的终点
        return ans;
    }
};
```

## 构造字典序最大的合并字符串（LC 1754）

**题目：[1754. 构造字典序最大的合并字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-merge-of-two-strings/)**

```c++
class Solution {
public:
    string largestMerge(string word1, string word2) {
        string merge;
        int i = 0, j = 0;
        while (i < word1.size() || j < word2.size()) {
            if (i < word1.size() && word1.substr(i) > word2.substr(j)) {
                merge.push_back(word1[i++]);
            } else {
                merge.push_back(word2[j++]);
            }
        }
        return merge;
    }
};
```

## 消灭怪物的最大数量

**题目：[1921. 消灭怪物的最大数量 - 力扣（LeetCode）](https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/)**

```c++
class Solution {
public:
    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {
        int n = dist.size() ; int ans = 0 ;
        vector<int> tim(n) ;
        for(int i=0;i<n;++i) tim[i] = ceil(dist[i] / (double)speed[i]) ;
        sort(tim.begin(),tim.end()) ;
        for(int i=0;i<n;++i) if(tim[i] <= i) return i ;
        return n ;
    }
};
```

## [使数组唯一的最小增量](https://leetcode.cn/problems/minimum-increment-to-make-array-unique/)

```c++
class Solution {
public:
    int minIncrementForUnique(vector<int>& nums) {
        map<int,int> mp ; 
        for(auto e : nums) mp[e] ++ ;
        int ans = 0 ; 
        for(auto [u , v] : mp){
            if(v > 1){
                ans += v - 1 ;
                mp[u + 1] += v - 1 ;
                mp[u] = 1 ;
            }
        }
        return ans ;
    }
};
```

## [具有给定数值的最小字符串](https://leetcode.cn/problems/smallest-string-with-a-given-numeric-value/)

```c++
class Solution {
public:
    string getSmallestString(int n, int k) {
        char s[n + 1] ;
        for(int i = n ; i >= 1 ; -- i){
            int ch = k - (i - 1) ;
            if(ch >= 26) s[i] = 26 - 1 + 'a' , k -= 26 ;
            else s[i] = ch - 1 + 'a' , k -= ch ;
        }
        string ans ;
        for(int i = 1 ; i <= n ; ++ i) ans += s[i] ;
        return ans ;
    }
};
```

## [从房屋收集雨水需要的最少水桶数](https://leetcode.cn/problems/minimum-number-of-food-buckets-to-feed-the-hamsters/)

```c++
class Solution {
public:
    int minimumBuckets(string s) {
        int n = s.size() ;  int ans = 0 ;
        if(n == 1 && s[0] == 'H') return -1 ;
        if(n == 1 && s[0] == '.') return 0 ;
        if(s[0] == 'H' && s[1] == '.') s[1] = 'B' , ans ++ ;
        else if(s[0] == 'H' && s[1] == 'H') return -1 ;
        if(s[n-1] == 'H' && s[n-2] == '.') s[n-2] = 'B' , ans ++ ;
        else if(s[n-1] == 'H' && s[n-2] == 'H') return -1 ;
        for(int i=1;i<n;++i){
            // 贪心，优先放右边
            if(s[i] == 'H'){
                if(s[i-1] == 'B') continue ;
                else if(s[i+1] == '.') s[i+1] = 'B' , ans ++ ;
                else if(s[i+1] == 'H' && s[i-1] == 'H') return -1 ;
                else if(s[i+1] == 'H') s[i-1] = 'B' , ans ++ ;
            }
        }
        return ans ;
    }
};
```



# 滑动窗口

## 无重复字符的最长子串（LC 3）

**题目：[3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)**

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char,int> m;
        int left=0,right=0;
        int lenth=0;
        for(right=0;right<s.size();right++){
            auto it = m.find(s[right]);
            if(it != m.end()){
                int temp = it->second;
                while(left<=temp){
                    m.erase(s[left]);
                    left++;
                }
            }
            m[s[right]] = right;
            if(right-left+1>lenth) lenth=m.size();
        }
        return lenth;


        // First Solution
        // unordered_set<char> arr;
        // int lenth=0;
        // int left =0;
        // for(int i=0;i<s.size();i++){
        //     while(arr.find(s[i]) != arr.end()){
        //         arr.erase(s[left]);
        //         left++;
        //     }
        //     arr.insert(s[i]);
        //     if(arr.size()>lenth) lenth = arr.size();
        // }
        // return lenth;
    }
};
```



## 长度最小的子数组（LC 209）

**题目：[209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/)**

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        queue<int> que;
        int sum = 0;
        int minLen = nums.size();
        int tag = 0;
        for(int i=0;i<nums.size();i++){
            if(sum<target){
                que.push(nums[i]);
                sum+=nums[i]; 
            }   
                while(sum>=target){
                    minLen = que.size()>minLen?minLen:que.size();
                    sum-=que.front();
                    que.pop();
                    tag = 1;
                }
        }
        if(tag == 0) return 0;
        return minLen;
    }
};
```



## 字符串的排列（LC 567）

**题目：[567. 字符串的排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutation-in-string/)**

```c++
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        int n1 = s1.size();
        int n2 = s2.size();
        queue<char> que;
        int left=0;
        bool tag=false;
        for(int right=0;right<n2;){
            auto it = s1.find(s2[right]);
            while(it != string::npos){
                que.push(s1[it]);
                s1.erase(it,1);
                right++;tag=true;
                if(right>n2-1) break;
                it = s1.find(s2[right]); 
            }   
            if(s1.empty()) return true;
            if(right==left) tag = false;
            if(tag==true){ 
                left++;
                s1+=que.front();
                que.pop();   
                continue;
            } 
            left++;right++;
        }
        return false;
    }
};
```



## 水果成篮（LC 904）

**题目：[904. 水果成篮 - 力扣（LeetCode）](https://leetcode.cn/problems/fruit-into-baskets/)**

```c++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        int n = fruits.size();
        cout<<n<<endl;
        if(n==0) return 0;
        if(n==1) return 1;
        unordered_map<int,int> m;  // key 水果种类， val 每个种类出现的次数
        int Max = 0;  // 维护最多种类
        int left=0,right=-1;  // 滑动窗口，left指向第一个，right指向最后一个
        for(int i=0;i<n;i++){
            if(m.size()==2){  // 如果有两个了
                if(m.find(fruits[i]) == m.end()){  // 没重复的就left移动到合适的位置,并进行删除操作
                    while(1){
                        m[fruits[left]]--;
                        if(m[fruits[left]] == 0) {
                            m.erase(fruits[left]);
                            left++;
                            break;
                        }
                        left++;
                    }
                    m[fruits[i]]++;
                    right++;

                }
                else{// 有重复的就插入水果加1
                    m[fruits[i]]++;
                    right++;
                }
            }
            else {  // 如果没有两种水果，就插入水果，数量加1
                m[fruits[i]]++;  
                right++;
            }
            // 迭代最大数量
            
            Max = max(Max,right-left+1);
            cout<<left<<" "<<right<<endl;
        }
        return Max;
    }
};
```

## 子串的最大出现次数

**题目：[1297. 子串的最大出现次数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-number-of-occurrences-of-a-substring/)**

```c++
class Solution {
public:
    int maxFreq(string s, int maxLetters, int len, int maxSize) {
        unordered_map<string,int> mp ; 
        unordered_map<char,int> m ;  string str = s.substr(0,len) ;
        for(int i=0;i<len;++i) m[s[i]] ++ ; 
        for(int i=0;i<s.size();++i){
            if(s.size() - i >= len) {
                if(i > 0) {
                    str.erase(0,1) ; str += s[i + len - 1] ;
                    if(m[s[i - 1]]-- == 1) m.erase(s[i - 1]) ;
                    m[s[i + len - 1]] ++ ;
                }
                if(m.size() <= maxLetters) mp[str] ++ ;
            }
            else break ;
        }
        int ans = 0 ;
        for(auto& e : mp){
            ans = max(ans , e.second) ;
        }

        return ans ;
    }
};
```

## [最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)

```c++
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int ans = 0 ; int p = 0 ;
        for (int i = 0; i < nums.size(); ++ i , ++ p) {
            bool ok = false ;
            while(i < nums.size()){
                if(nums[i] == 1 && k >= 0) i ++ , ok = true ;
                else if(nums[i] == 0 && k > 0) i ++ , k -- , ok = true ;
                else break ;
            } 
            if(!ok){
                if(nums[i] == 0) k -- ; 
            } else -- i ;
            if(k >= 0) ans = max(i - p + 1 , ans) ;
            if(nums[p] == 0) k ++ ;
        }
        return ans ;
    }
};
```



# 搜索

## 深度优先搜索

### 单词接龙（LG P1019）

**题目：[P1019 [NOIP2000 提高组\] 单词接龙 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1019)**

```c++
#include <bits/stdc++.h>
#define int long long
#define cin(x) cin >> x 
#define cout(x) cout << x << '\n'
using namespace std ;
const int N = 21 ;
/*---------------分割线--------------*/
string s[N] ; char start ;
int n , ans ;
/*---------------分割线--------------*/
int len ;
bool check(string& s1,string& s2){
    for(int i=s1.size()-1;i>=1;--i){
        if(s1.substr(i) == s2.substr(0,s1.size() - i)) {
            len = s2.size() - (s1.size() - i) ;
            return true ;
        }
    }
    return false ;
}
int L ; int vis[N] ; 
void dfs(int u){
    for(int i=1;i<=n;++i){
        if(vis[i] == 2) continue ;
        if(check(s[u] , s[i])){
            int t = len ;
            vis[i] ++ ; L += t ;
            ans = max(ans,L) ;
            dfs(i) ;
            L -= t ; vis[i] -- ;
        }
    }
}
/*---------------分割线--------------*/

/*---------------分割线--------------*/
signed main(){
    cin(n) ; for(int i=1;i<=n;++i) cin(s[i]) ; cin(start) ;
    for(int i=1;i<=n;++i) if(s[i][0] == start){
        L += s[i].size() ; vis[i] ++ ;
        ans = max(ans,L) ; 
        dfs(i) ;
        vis[i] -- ; L -= s[i].size() ;
    }
    cout(ans) ;
    system("pause") ;
}
```

### Scales S (LG P 5194)

**题目：[P5194 [USACO05DEC\]Scales S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5194)**

```c++
#include <bits/stdc++.h>
#define int long long
#define cin(x) cin >> x 
#define cout(x) cout << x << '\n'
using namespace std ;
const int N = 1e3+1 ;
/*---------------分割线--------------*/
int n , c , a[N] , pix[N] , ans ;
/*---------------分割线--------------*/
int sum = 0 ; 
void dfs(int end){
    for(int i=end;i>=1;--i){
        if(sum + a[i] > c) continue ;
        sum += a[i] ; ans = max(ans , sum) ;
        if(sum + pix[i-1] < c) {
            ans = max(ans , sum + pix[i-1]) ;
            sum -= a[i] ;
            break ;
        }
        dfs(i-1) ;
        sum -= a[i] ;
    }
}
/*---------------分割线--------------*/
signed main(){
    cin(n) ; cin(c) ; for(int i=1;i<=n;++i) cin(a[i]) , pix[i] = pix[i-1] + a[i] ;
    dfs(n) ;
    cout(ans) ;
    system("pause") ;
}
```

### 油滴扩展（LG P1378）

**题目：[P1378 油滴扩展 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1378)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const double PI = 3.14159265358979323846 ;
int n , x , y , z , w ;
int Left , Right , up , down ;
int used[7] , r[7] , c[7] ;  // 是否使用和横纵坐标
double ans ; double d[7][7] , R[7] ; // 两点距离和半径
void dfs(int u,double sum){
    // 计算半径，更新答案，递归进入下一层，回溯复原
    if(u == n + 1) {
        ans = max(ans , sum) ; return ;
    }
    for(int i=1;i<=n;++i){
        if(used[i]) continue ;
        R[i] = min(
            min(r[i] - Left , Right - r[i]) ,
            min(c[i] - down , up - c[i]) 
        ) ;
        for(int j=1;j<=n;++j){
            if(used[j]) R[i] = min(R[i] , d[i][j] - R[j]) ;
        }
        if(R[i] < 0) R[i] = 0 ;
        used[i] = 1 ;
        dfs(u+1,sum + R[i]*R[i]*PI) ;
        used[i] = 0 ;
    }
}
int main(){
    cin >> n ; 
    cin >> x >> y ;
    Left = Right = x ; up = down = y ;
    cin >> x >> y ; 
    Left = min(x,Left) ; Right = max(Right,x) ;
    down = min(y,down) ; up = max(y,up) ;
    for(int i=1;i<=n;++i) cin >> r[i] >> c[i] ;
    for(int i=1;i<=n;i++) for(int j=i+1;j<=n;j++)
        d[i][j]=d[j][i]=sqrt(
            (r[i]-r[j])*(r[i]-r[j])+
            (c[i]-c[j])*(c[i]-c[j])
        );
    dfs(1,0.0) ;
    printf("%.0lf",(up-down)*(Right-Left)-ans);//输出剩余的面积
    system("pause") ;
}


```

### 细胞数量（LG P1451）

**题目：[P1451 求细胞数量 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1451)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 101 ;
int n, m ; char ma[N][N] ; int ans ; int vis[N][N] ;
int dx[5] = {0,-1,1,0,0} ;
int dy[5] = {0,0,0,-1,1} ;
void dfs(int x,int y){
    vis[x][y] = 1 ;
    for(int i=1;i<=4;++i){
        int xx = x + dx[i] , yy = y + dy[i] ;
        if(xx < 1 || xx > n || yy < 1 || yy > m || vis[xx][yy] || ma[xx][yy] == '0') continue ;
        dfs(xx,yy) ;
    }
}
int main(){
    cin >> n >> m ;
    for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) {cin >> ma[i][j] ;}
    for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) {
        if(!vis[i][j] && ma[i][j] != '0') {
            dfs(i,j) , ans++ ;
        }
    }
    cout << ans << endl ;
    system("pause") ;
}
```

### 01迷宫（LG P1141）

**题目：[P1141 01迷宫 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1141)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e3+1 ;
int n, m , x , y ; char ma[N][N] ; int vis[N][N] , cnt[N][N] ; 
int dx[5] = {0,-1,1,0,0} ;
int dy[5] = {0,0,0,-1,1} ;
int sum ; int color ; int c[N][N] ;
void dfs(int x,int y){  // 染色
    c[x][y] = color ; sum += 1 ;
    for(int i=1;i<=4;++i){
        int xx = x + dx[i] , yy = y + dy[i] ;
        if(xx < 1 || xx > n || yy < 1 || yy > n || c[xx][yy] || ma[xx][yy] == ma[x][y]) continue ;
        dfs(xx,yy) ;
    }
}
void dfs2(int x,int y){  // 打上数量
    vis[x][y] = 1 ; cnt[x][y] = sum ;
    for(int i=1;i<=4;++i){
        int xx = x + dx[i] , yy = y + dy[i] ;
        if(xx < 1 || xx > n || yy < 1 || yy > n || vis[xx][yy] || ma[xx][yy] == ma[x][y]) continue ;
        dfs2(xx,yy) ;
    }
}
int main(){
    cin >> n >> m ;
    for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) {cin >> ma[i][j] ;}
    for(int i=1;i<=m;++i){
        cin >> x >> y ; 
        if(vis[x][y]) cout << cnt[x][y] << endl ;
        else {
            ++color ; sum = 0 ; dfs(x,y) ; dfs2(x,y) ;
            cout << cnt[x][y] << endl ;
        }
    }
    system("pause") ;
}
```

### Icy Perimerter S (LG P5198)

**题目：[P5198 [USACO19JAN\]Icy Perimeter S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5198)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e3+1 ;
int n, m , x , y ; char ma[N][N] ; int vis[N][N] ; 
int dx[5] = {0,-1,1,0,0} ;
int dy[5] = {0,0,0,-1,1} ;
int area , perimeter ; // 面积和周长
void dfs(int x,int y){
    vis[x][y] = 1 ; area += 1 ;
    for(int i=1;i<=4;++i){
        int xx = x + dx[i] , yy = y + dy[i] ;
        if(xx < 1 || xx > n || yy < 1 || yy > n){
            perimeter += 1 ; continue ;
        }else if(vis[xx][yy]) {
            continue ;
        }else if(ma[xx][yy] == '.'){
            perimeter += 1 ; continue ;
        }
        dfs(xx,yy) ;
    }
}
int main(){
    cin >> n ; int maxArea = INT_MIN , Perimeter = INT_MAX ;
    for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) {cin >> ma[i][j] ;}
    for(int i=1;i<=n;++i){
        for(int j=1;j<=n;++j){
            if(!vis[i][j] && ma[i][j] == '#') {
                area = 0 ; perimeter = 0 ;
                dfs(i,j) ; 
                if(maxArea < area){
                    maxArea = area ; Perimeter = perimeter ;
                } else if(maxArea == area) {
                    Perimeter = min(Perimeter,perimeter) ;
                }
            }
        }
    }
    cout << maxArea << " " << Perimeter << endl ;
    system("pause") ;
}
```

### 数的划分（LG P1025）

**题目：[P1025 [NOIP2001 提高组\] 数的划分 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1025)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 201 ; 
int n , k ; int ans ;
void dfs(int sum,int d,int last){
    if(d == k){
        if(sum == n) {ans ++ ; return ; }
        else return ;
    }
    for(int i=last;i<=(n-k+1);++i){
        if(sum + i > n) {return ;}
        dfs(sum+i,d+1,i) ;
    }
}
int main(){
    cin >> n >> k ;
    dfs(0,0,1) ;
    cout << ans << endl ;
    system("pause") ;
}
```

### 砝码称重（LG P1441）

**题目：[P1441 砝码称重 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1441)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 21 ;
int a[N] ; int n , m , all ; int ans ;
unordered_map<int,int> mp ;
int vis[N] ; int state ;  // 1代表未选取
// void dfs1(int sum,int last){
//     mp[sum] ;
//     for(int i=last+1;i<=n;++i){
//         if(state & (1 << i)) continue ;
//         dfs1(sum+a[i],i) ;
//     }
// }
int f[2100] ; // 第i件物品放入j的背包是否可行
void dp(){
    memset(f,0,sizeof(f)) ;
    f[0] = 1 ;
    for(int i=1;i<=n;++i){
        if(state & (1 << i)) continue ;
        for(int j=all;j>=a[i];--j) f[j] = max(f[j],f[j-a[i]]) ;
    } 
    int cnt = 0 ;
    for(int i=1;i<=all;++i) if(f[i]) cnt ++ ;
    ans = max(ans,cnt) ;
}
void dfs(int rej,int last){  // rej已经舍弃了几个
    if(rej == m){
        dp() ;
        return ;
    }
    for(int i=last+1;i<=n;++i) {
        state = state | (1 << i) ;
        dfs(rej+1,i) ;
        state = state & ~(1 << i) ;
    }
}
int main(){
    cin >> n >> m ;
    for(int i=1;i<=n;++i) scanf("%d",&a[i]) , all += a[i] ;
    dfs(0,0) ;
    cout << ans << endl ;
    system("pause") ;
}
```

### 跳跃游戏|||

**题目：[1306. 跳跃游戏 III - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game-iii/)**

```c++
class Solution {
public:
    bool canReach(vector<int>& arr, int start) {
        int n = arr.size() ; vector<int> vis(n) ;
        function<bool(int)> dfs = [&](int s){
            if(vis[s]) return false ; vis[s] = 1 ;
            bool ok = false ;
            if(s + arr[s] < n) {
                if(arr[s + arr[s]] == 0) return true ;
                else ok |= dfs(s + arr[s]) ;
            }
            if(s - arr[s] >= 0) {
                if(arr[s - arr[s]] == 0) return true ;
                else ok |= dfs(s - arr[s]) ;
            }
            return ok ;
        } ;
        return dfs(start) ;
    }
};
```



## 广度优先搜索

### 填涂颜色（LG P1162）

**题目：[P1162 填涂颜色 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1162)**

```c++
#include <bits/stdc++.h>
using namespace std;
#define maxN 31
#define  mp(x,y) make_pair(x,y)
int n;
int matrix[maxN][maxN],visited[maxN][maxN];
void read(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			scanf("%d",&matrix[i][j]);
		}
	}
}
bool isVaild(int x,int y){
	if(x<0 || x>n+1 || y<0 || y>n+1 || matrix[x][y]==1) return false;
	return true;
}
void BFS(int x,int y){
	queue<pair<int,int>> Q;
	Q.push(mp(0,0));
	while(!Q.empty()){
		int dx = Q.front().first;
		int dy = Q.front().second;
		Q.pop();
		if(!isVaild(dx,dy)) continue;
		if(visited[dx][dy]) continue; 
		visited[dx][dy] = 1;
		Q.push(mp(dx-1,dy));
		Q.push(mp(dx+1,dy));
		Q.push(mp(dx,dy-1));
		Q.push(mp(dx,dy+1));
	}
}
void ans(){
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			if(visited[i][j]==1 && matrix[i][j]==0){
				printf("0 ");
			}else if(visited[i][j]==0 && matrix[i][j]==1){
				printf("1 ");
			}else printf("2 ");
		}
		printf("\n");
	}
}
int main() {
	read();
	BFS(0,0);
	ans();
	system("pause");
	return 0;
}
/*
6
0 0 0 0 0 0
0 0 1 1 1 0
0 1 1 0 0 1
1 0 0 0 0 1
1 1 1 1 1 0
0 0 0 0 0 0
*/
```

### 马的遍历（LG P1443）

**题目：[P1443 马的遍历 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1443)**

```c++
#include<iostream>//P1443
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<cmath>
using namespace std;
const int dx[8]={-1,-2,-2,-1,1,2,2,1};
const int dy[8]={2,1,-1,-2,2,1,-1,-2};//8个方向
queue<pair<int,int> > q;
int f[500][500];//存步数
bool vis[500][500];//走没走过
int main()
{
	int n,m,x,y;
	memset(f,-1,sizeof(f));memset(vis,false,sizeof(vis));
	cin>>n>>m>>x>>y;
	f[x][y]=0;vis[x][y]=true;q.push(make_pair(x,y));
	while(!q.empty())
	{
		int xx=q.front().first,yy=q.front().second;q.pop();//取队首并出队
		for(int i=0;i<8;i++)
		{
			int u=xx+dx[i],v=yy+dy[i];
			if(u<1||u>n||v<1||v>m||vis[u][v])continue;//出界或走过就不走
		    vis[u][v]=true;q.push(make_pair(u,v));f[u][v]=f[xx][yy]+1;
		}
	}
	for(int i=1;i<=n;i++)
	 {for(int j=1;j<=m;j++)printf("%-5d",f[i][j]);printf("\n");}//注意场宽！！
	return 0;
}
```

### 棋盘（LG P3956）

**棋盘：[P3956 [NOIP2017 普及组\] 棋盘 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3956)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e3+1 , M = 1e2+1;
/********************************************/
int n , m , x , y , color ;  
int dx[5] = {0,-1,1,0,0} ;
int dy[5] = {0,0,0,-1,1} ;
/********************************************/
int c[M][M] , dis[M][M] , vis[M][M] ;  // 颜色，到这个点的最小花费,是否访问 
struct node{
    int x , y , c ; 
    int priority ;
    int isBlank ;
    bool operator<(const node& e)const{return priority > e.priority;}
} ;
void bfs(){
    priority_queue<node> q ; memset(dis,0x3f,sizeof(dis)) ; dis[1][1] = 0 ;
    q.push({1,1,c[1][1],dis[1][1],0}) ; memset(vis,0,sizeof(vis)) ; node v ;
    while(q.size()){
        auto u = q.top() ; q.pop() ;
        if(vis[u.x][u.y]) continue ;
        vis[u.x][u.y] = 1 ;
        for(int i=1;i<=4;++i){
            v.x = u.x + dx[i] ; v.y = u.y + dy[i] ;
            if(!u.isBlank) {  // 如果不是空白格子
                if(u.c == c[v.x][v.y] && dis[v.x][v.y] > dis[u.x][u.y]) {
                    dis[v.x][v.y] = dis[u.x][u.y] ;
                    q.push({v.x,v.y,c[v.x][v.y],dis[v.x][v.y],0}) ;
                } else if(c[v.x][v.y] != -1 && dis[v.x][v.y] > dis[u.x][u.y] + 1) {
                    dis[v.x][v.y] = dis[u.x][u.y] + 1 ;
                    q.push({v.x,v.y,c[v.x][v.y],dis[v.x][v.y],0}) ;
                } else if(dis[v.x][v.y] > dis[u.x][u.y] + 2) {
                    dis[v.x][v.y] = dis[u.x][u.y] + 2 ;
                    q.push({v.x,v.y,u.c,dis[v.x][v.y],1}) ;
                }
            } else {  // 如果是空白格子
                if(c[v.x][v.y] == -1) continue ;
                if(u.c == c[v.x][v.y] && dis[v.x][v.y] > dis[u.x][u.y]) {
                    dis[v.x][v.y] = dis[u.x][u.y] ;
                    q.push({v.x,v.y,c[v.x][v.y],dis[v.x][v.y],0}) ;
                } else if(dis[v.x][v.y] > dis[u.x][u.y] + 1) {
                    dis[v.x][v.y] = dis[u.x][u.y] + 1 ;
                    q.push({v.x,v.y,c[v.x][v.y],dis[v.x][v.y],0}) ;
                }
            }
        }
    }
}
/********************************************/
int main(){
    cin >> m >> n ; memset(c,-1,sizeof(c)) ;  // 空白为-1
    for(int i=1;i<=n;++i) cin >> x >> y >> color , c[x][y] = color ;
    bfs() ;
    if(dis[m][m] > (int)1e9) cout << -1 << endl ;
    else cout << dis[m][m] << endl ;
    system("pause") ;
}


```

### 字符变换（LG P1032）

**题目：[P1032 [NOIP2002 提高组\] 字串变换 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1032)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e3+1 , M = 1e2+1;
/******************************************************/
string A , B , x , y , z ;
string be[7] , en[7] ; int idx ; 
/******************************************************/
void bfs() {
    unordered_map<string,int> m ;
    queue<string> q ; q.push(A) ; m[A] = 0 ;
    while(q.size()){
        string u = q.front() , v ; q.pop() ; int pos ; 
        for(int i=1;i<=idx;++i) {
            pos = 0 ;
            while(( pos = u.find(be[i],pos)) != -1) {
                v = u ; v.replace(pos,be[i].size(),en[i]) ;
                if(m.count(v)) {pos++ ; continue ;};
                m[v] = m[u] + 1 ;
                if(m[v] > 10) {cout << "NO ANSWER!" << endl ; return ;}
                if(v == B) {cout << m[v] << endl ; return ;}
                q.push(v) ;
            }
        }
    }
    cout << "NO ANSWER!" << endl ;
}
void doubleBfs(){
    unordered_map<string,int> mq ;
    unordered_map<string,int> mp ;
    queue<string> q ; q.push(A) ; mq[A] = 0 ;
    queue<string> p ; p.push(B) ; mp[B] = 0 ;
    while(p.size() && q.size()){
        /****************First BFS******************/
        string u = q.front() , v ; q.pop() ; int pos ; 
        for(int i=1;i<=idx;++i) {
            pos = 0 ;
            while(( pos = u.find(be[i],pos)) != -1) {
                v = u ; v.replace(pos,be[i].size(),en[i]) ;
                if(mq.count(v)) {pos++ ; continue ;};
                mq[v] = mq[u] + 1 ;
                if(mq[v] > 10) {cout << "NO ANSWER!" << endl ; return ;}
                if(mp.count(v)) {cout << mp[v] + mq[v] << endl ; return ;}
                q.push(v) ;
            }
        }
        /****************Second BFS******************/
        u = p.front() ; p.pop() ;
        for(int i=1;i<=idx;++i) {
            pos = 0 ;
            while(( pos = u.find(en[i],pos)) != -1) {
                v = u ; v.replace(pos,en[i].size(),be[i]) ;
                if(mp.count(v)) {pos++ ; continue ;};
                mp[v] = mp[u] + 1 ;
                if(mp[v] > 10) {cout << "NO ANSWER!" << endl ; return ;}
                if(mq.count(v)) {cout << mp[v] + mq[v] << endl ; return ;}
                p.push(v) ;
            }
        }
    }
    cout << "NO ANSWER!" << endl ;
}
/******************************************************/
int main(){
    cin >> A >> B ;
    while(cin >> be[++idx] >> en[idx]){} ;
    doubleBfs() ;
    system("pause") ;
}


```

### 机器人搬重物（LG P1126）

**题目：[P1126 机器人搬重物 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1126)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 51 , M = 51;
/******************************************************/
int n , m , s_x , s_y , e_x , e_y , x , y ; 
char dir ; int mtri[N][M] ;
int dx[13] = {0,-1,1,0,0,-2,2,0,0,-3,3,0,0} ;
int dy[13] = {0,0,0,-1,1,0,0,-2,2,0,0,-3,3} ;
/******************************************************/
int vis[N][M] , dis[N][M] ;  // 是否访问和最短时间
struct node{
    int x , y , dis ;
    char dir ;
    bool operator<(const node& e)const {return dis > e.dis;}
} ;
bool check(int x,int y,int dx,int dy){
    int xx = x + dx , yy = y + dy ;
    if(xx >= n || yy >= m || xx < 1 || yy < 1) return false ;
    if(dx == 0) {
        if(dy > 0){
            for(int j=y+2;j<=y+1+dy;++j){
                if(mtri[x][j] || mtri[x+1][j]) return false ;
            }
        } else {
            for(int j=y+dy;j<=y-1;++j){
                if(mtri[x][j] || mtri[x+1][j]) return false ;
            }
        }
    } else {
        if(dx > 0){
            for(int i=x+2;i<=x+1+dx;++i){
                if(mtri[i][y] || mtri[i][y+1]) return false ;
            }
        } else {
            for(int i=x+dx;i<=x-1;++i){
                if(mtri[i][y] || mtri[i][y+1]) return false ;
            }
        }
    }
    return true ;
}
int dir_cost ; char nex_dir ;
void get_dir_cost(int dx,int dy,char dir){
    if(dx == 0){
        if(dy > 0) {
            nex_dir = 'E' ;
            if(dir == 'E') dir_cost = 0 ;
            else if(dir == 'S') dir_cost = 1 ;
            else if(dir == 'W') dir_cost = 2 ;
            else if(dir == 'N') dir_cost = 1 ;
        } else {
            nex_dir = 'W' ;
            if(dir == 'E') dir_cost = 2 ;
            else if(dir == 'S') dir_cost = 1 ;
            else if(dir == 'W') dir_cost = 0 ;
            else if(dir == 'N') dir_cost = 1 ;
        }
    } else {
        if(dx > 0) {
            nex_dir = 'S' ;
            if(dir == 'E') dir_cost = 1 ;
            else if(dir == 'S') dir_cost = 0 ;
            else if(dir == 'W') dir_cost = 1 ;
            else if(dir == 'N') dir_cost = 2 ;
        } else {
            nex_dir = 'N' ;
            if(dir == 'E') dir_cost = 1 ;
            else if(dir == 'S') dir_cost = 2 ;
            else if(dir == 'W') dir_cost = 1 ;
            else if(dir == 'N') dir_cost = 0 ;
        }
    }
}
void bfs() {
    memset(dis,0x3f,sizeof(dis)) ; memset(vis,0,sizeof(vis)) ; dis[s_x][s_y] = 0 ;
    priority_queue<node> q ; q.push({s_x,s_y,dis[s_x][s_y],dir}) ; node u , v ; 
    while(q.size()){
        u = q.top() ; q.pop() ;
        if(vis[u.x][u.y]) continue ;
        vis[u.x][u.y] = 1 ;
        if(u.x == e_x && u.y == e_y) {cout << dis[u.x][u.y] << endl ; return ;}
        for(int i=1;i<=12;++i){
            v.x = u.x + dx[i] ; v.y = u.y + dy[i] ; 
            if(!check(u.x,u.y,dx[i],dy[i])) continue ;
            get_dir_cost(dx[i],dy[i],u.dir) ;
            if(dis[v.x][v.y] > dis[u.x][u.y] + dir_cost + 1){
                dis[v.x][v.y] = dis[u.x][u.y] + dir_cost + 1 ;
                q.push({v.x,v.y,dis[v.x][v.y],nex_dir}) ;
            }
        }
    }
    cout << -1 << endl ;
}
/******************************************************/
int main(){
    cin >> n >> m ; 
    for(int i=1;i<=n;++i) for(int j=1;j<=m;++j)
        cin >> mtri[i][j] ;
    cin >> s_x >> s_y >> e_x >> e_y >> dir ;
    if(mtri[s_x][s_y] || mtri[s_x][s_y+1] || mtri[s_x+1][s_y] || mtri[s_x+1][s_y+1]) {cout << -1 << endl ; return 0;}
    bfs() ;
    system("pause") ;
}


```

### 好奇怪的游戏（LG P1747）

**题目：[P1747 好奇怪的游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1747)**

```c++
#include <iostream>
#include <cstring> 
#include <unordered_map>
#include <queue>
using namespace std ;
int x1 , y , x2 , y2 ;
int dx[13]={0,1,1,2,2,2,2,-1,-1,-2,-2,-2,-2};
int dy[13]={0,-2,2,-2,-1,1,2,-2,2,-1,1,-2,2};
struct node{int x,y,dis;}; int vis[26][26] ;
void bfs(int x,int y){
    queue<node> q ; memset(vis,0,sizeof(vis)) ;
    q.push({x,y,0}) ; node u , v ; vis[x][y] = 1 ;
    while(q.size()){
        u = q.front() ; q.pop() ;
        for(int i=1;i<=12;++i){
            int xx = u.x + dx[i] , yy = u.y + dy[i] ;
            if(xx <= 0 || yy <= 0 || xx>=25 || yy>=25 || vis[xx][yy]) continue ;
            q.push({xx,yy,u.dis+1}) ; vis[xx][yy] = 1 ;
            if(xx==1 && yy == 1) {
                cout << u.dis+1 << endl ; return ;
            }
        }
    }
}
int main(){
    cin >> x1 >> y >> x2 >> y2 ;
    if(x1 == 1 && y == 1) cout << 0 << endl ; else bfs(x1,y) ;
    if(x2 == 1 && y2 == 1) cout << 0 << endl ; else bfs(x2,y2) ;
    system("pause") ;
}
```

### 离开中山路（LG P1746）

**题目：[P1746 离开中山路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1746)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e3+1 ;
int n , u1 , v1 , u2 , v2 ;
int dx[5] = {0,-1,1,0,0} ;
int dy[5] = {0,0,0,-1,1} ;
int vis[N][N] ; char ma[N][N] ;
struct node{int x,y,dis;};
void bfs(int x,int y){
    memset(vis,0,sizeof(vis)) ; queue<node> q ; q.push({x,y,0}) ;
    while(q.size()){
        node u = q.front() ; q.pop() ;
        if(vis[u.x][u.y]) continue ; vis[u.x][u.y] = 1 ;
        if(u.x == u2 && u.y == v2) {
            cout << u.dis << endl ;
            return ;
        }
        for(int i=1;i<=4;++i){
            int xx = u.x + dx[i] , yy = u.y + dy[i] ;
            if(xx < 1 || yy < 1 || xx > n || yy > n || ma[xx][yy] == '1') continue ;
            q.push({xx,yy,u.dis+1}) ;
        }
    }
}
int main(){
    cin >> n ;
    for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) cin >> ma[i][j] ;
    cin >> u1 >> v1 >> u2 >> v2 ;
    bfs(u1,v1) ;
    system("pause") ;
}
```

### Mzc和男家丁的游戏（LG P2298）

**题目：[P2298 Mzc和男家丁的游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2298)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 2e3+1 ;
int n , m , u1 , v1 , u2 , v2 ;
int dx[5] = {0,-1,1,0,0} ;
int dy[5] = {0,0,0,-1,1} ;
int vis[N][N] ; char ma[N][N] ;
struct node{int x,y,dis;};
void bfs(int x,int y){
    memset(vis,0,sizeof(vis)) ; queue<node> q ; q.push({x,y,0}) ;
    while(q.size()){
        node u = q.front() ; q.pop() ;
        if(vis[u.x][u.y]) continue ; vis[u.x][u.y] = 1 ;
        if(u.x == u2 && u.y == v2) {
            cout << u.dis << endl ;
            return ;
        }
        for(int i=1;i<=4;++i){
            int xx = u.x + dx[i] , yy = u.y + dy[i] ;
            if(xx < 1 || yy < 1 || xx > n || yy > n || ma[xx][yy] == '#') continue ;
            q.push({xx,yy,u.dis+1}) ;
        }
    }
    cout << "No Way!" << endl ;
}
int main(){
    cin >> n >> m ;
    for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) {
        cin >> ma[i][j] ; 
        if(ma[i][j] == 'm') u1 = i , v1 = j ;
        else if(ma[i][j] == 'd') u2 = i , v2 = j ;
    }
    bfs(u1,v1) ;
    system("pause") ;
}
```

### 血色先锋队（LG P1332）

**题目：[P1332 血色先锋队 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1332)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 501 ;
int n , m , a , b ;
int dx[5] = {0,-1,1,0,0} ;
int dy[5] = {0,0,0,-1,1} ;
int vis[N][N] , dis[N][N] ;
struct node{int x,y;};
void bfs(int x,int y){
    memset(vis,0,sizeof(vis)) ; queue<node> q ; q.push({x,y}) ; dis[x][y] = 0 ;
    while(q.size()){
        node u = q.front() ; q.pop() ;
        if(vis[u.x][u.y]) continue ; vis[u.x][u.y] = 1 ;
        for(int i=1;i<=4;++i){
            int xx = u.x + dx[i] , yy = u.y + dy[i] ;
            if(xx < 1 || yy < 1 || xx > n || yy > m) continue ;
            if(dis[xx][yy] > dis[u.x][u.y] + 1) {
                dis[xx][yy] = dis[u.x][u.y] + 1 ;
                q.push({xx,yy}) ;
            }
        }
    }
}
int main(){
    cin >> n >> m >> a >> b ; int x , y ; 
    memset(dis,0x3f,sizeof(dis)) ;
    for(int i=1;i<=a;++i){
        cin >> x >> y ;
        bfs(x,y) ;
    }
    for(int i=1;i<=b;++i){
        cin >> x >> y ; 
        cout << dis[x][y] << endl ;
    }
    system("pause") ;
}
```



## 双向广度搜索

### 字串变换（LG P1032）

**题目：[P1032 [NOIP2002 提高组\] 字串变换 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1032)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e3+1 , M = 1e2+1;
/******************************************************/
string A , B , x , y , z ;
string be[7] , en[7] ; int idx ; 
/******************************************************/
void bfs() {
    unordered_map<string,int> m ;
    queue<string> q ; q.push(A) ; m[A] = 0 ;
    while(q.size()){
        string u = q.front() , v ; q.pop() ; int pos ; 
        for(int i=1;i<=idx;++i) {
            pos = 0 ;
            while(( pos = u.find(be[i],pos)) != -1) {
                v = u ; v.replace(pos,be[i].size(),en[i]) ;
                if(m.count(v)) {pos++ ; continue ;};
                m[v] = m[u] + 1 ;
                if(m[v] > 10) {cout << "NO ANSWER!" << endl ; return ;}
                if(v == B) {cout << m[v] << endl ; return ;}
                q.push(v) ;
            }
        }
    }
    cout << "NO ANSWER!" << endl ;
}
void doubleBfs(){
    unordered_map<string,int> mq ;
    unordered_map<string,int> mp ;
    queue<string> q ; q.push(A) ; mq[A] = 0 ;
    queue<string> p ; p.push(B) ; mp[B] = 0 ;
    while(p.size() && q.size()){
        /****************First BFS******************/
        string u = q.front() , v ; q.pop() ; int pos ; 
        for(int i=1;i<=idx;++i) {
            pos = 0 ;
            while(( pos = u.find(be[i],pos)) != -1) {
                v = u ; v.replace(pos,be[i].size(),en[i]) ;
                if(mq.count(v)) {pos++ ; continue ;};
                mq[v] = mq[u] + 1 ;
                if(mq[v] > 10) {cout << "NO ANSWER!" << endl ; return ;}
                if(mp.count(v)) {cout << mp[v] + mq[v] << endl ; return ;}
                q.push(v) ;
            }
        }
        /****************Second BFS******************/
        u = p.front() ; p.pop() ;
        for(int i=1;i<=idx;++i) {
            pos = 0 ;
            while(( pos = u.find(en[i],pos)) != -1) {
                v = u ; v.replace(pos,en[i].size(),be[i]) ;
                if(mp.count(v)) {pos++ ; continue ;};
                mp[v] = mp[u] + 1 ;
                if(mp[v] > 10) {cout << "NO ANSWER!" << endl ; return ;}
                if(mq.count(v)) {cout << mp[v] + mq[v] << endl ; return ;}
                p.push(v) ;
            }
        }
    }
    cout << "NO ANSWER!" << endl ;
}
/******************************************************/
int main(){
    cin >> A >> B ;
    while(cin >> be[++idx] >> en[idx]){} ;
    doubleBfs() ;
    system("pause") ;
}


```

### [为高尔夫比赛砍树](https://leetcode.cn/problems/cut-off-trees-for-golf-event/)

```c++
#include <bits/stdc++.h>
#define debug cout << "__LINE__ : " << __LINE__ - 9 <<endl ;
using namespace std ;

using ll = long long ;
class Solution {
public:
    struct node{int x,y;} ;
    int dx[5] = {0,-1,1,0,0} ;
    int dy[5] = {0,0,0,-1,1} ;
    int cutOffTree(vector<vector<int>>& forest) {
        int n = forest.size() ; int m = forest[0].size() ;
        vector<node> tree ; //forest[0][0] = 1 ;
        for(int i=0;i<n;++i) for(int j=0;j<m;++j) 
        if(forest[i][j]>1) tree.push_back({i,j}) ;
        sort(tree.begin(),tree.end(),[&](const node& e1,const node& e2){
            return forest[e1.x][e1.y] < forest[e2.x][e2.y] ;
        }) ; 
        auto bfs = [&](int sx,int sy,int tx,int ty){
            if(sx == tx && sy == ty) return 0 ; 
            //debug ; cout << sx << " " << sy << " " << tx << " " << ty << endl ;
            array<array<int,50>,50> vis1{} ; 
            queue<node> q ; q.push({sx,sy}) ; vis1[sx][sy] = 1 ;
            array<array<int,50>,50> vis2{}  ; 
            queue<node> p ; p.push({tx,ty}) ; vis2[tx][ty] = 1 ;
            while(p.size() && q.size()){
                node u = q.front() ; q.pop() ;
                for (int i = 1; i <= 4; ++i){
                    int x = u.x + dx[i] , y = u.y + dy[i] ;
                    if(x < 0 || x >= n || y < 0 || y >= m || !forest[x][y]) continue ;
                    //debug ; 
                    if(vis2[x][y]) return vis1[u.x][u.y] + vis2[x][y] - 1 ;
                    if(vis1[x][y]) continue ; 
                    //debug ;
                    vis1[x][y] = vis1[u.x][u.y] + 1 ;
                    q.push({x,y}) ;
                }
                //debug ; 
                u = p.front() ; p.pop() ;
                for (int i = 1; i <= 4; ++i){
                    int x = u.x + dx[i] , y = u.y + dy[i] ;
                    if(x < 0 || x >= n || y < 0 || y >= m || !forest[x][y]) continue ;
                    if(vis1[x][y]) return vis2[u.x][u.y] + vis1[x][y] - 1 ;
                    if(vis2[x][y]) continue ; 
                    vis2[x][y] = vis2[u.x][u.y] + 1 ;
                    p.push({x,y}) ;
                }
            }
            //debug ;
            return -1 ;
        } ;
        int ans = 0 ; int sx = 0 , sy = 0 ;
        for (int i = 0; i < tree.size(); ++i){
            int t = bfs(sx,sy,tree[i].x,tree[i].y) ;
            //debug ; cout << t << endl ;
            if(t == -1) return -1 ;
            ans += t ; sx = tree[i].x , sy = tree[i].y ;
        }
        return ans ;
    }
};
```



## 记忆化搜索

### 逛公园（LG P3953）

**题目：[P3953 [NOIP2017 提高组\] 逛公园 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3953)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10 , M = 2e5+10 , K = 51 , inf = 1e9 ;
int T , n , m , k , P ; int a , b , c ; int u , v , w ;
struct qwq{int to,w,ne;} e[M] , re[M] ;
int h[N] , tot , rh[N] ;
void add(int u,int v,int w){
    e[++tot]={v,w,h[u]};h[u]=tot;
    re[tot]={u,w,rh[v]};rh[v]=tot;
} 
struct node{
    int v , dis ;
    bool operator<(const node& e)const {return dis > e.dis;}
};
int vis[N] , dis[N] ; 
void dijkstra(int s){  // 求出反图n到各点的距离
    fill(dis+1,dis+n+1,inf) ; dis[s] = 0 ;
    memset(vis,0,sizeof(vis)) ;
    priority_queue<node> q ;  q.push({s,dis[s]}) ;
    while(q.size()){
        int u = q.top().v ; q.pop() ;
        if(vis[u]) continue ;
        vis[u] = 1 ;
        for(int i=rh[u];i;i=re[i].ne){
            int v = re[i].to , w = re[i].w ;
            if(dis[v] > dis[u] + w) dis[v] = dis[u] + w , q.push({v,dis[v]}) ;
        }
    }
}
int cnt[N][K] , visited[N][K] , tag ;  // cnt[i][k] i 到 n 等于 dis[i] + k 的方案数 , visited[i][k] 判断0环
void dfs(int u,int s){
    if(visited[u][s]){tag = 1 ; return ;}
    if(cnt[u][s]) return ;
    visited[u][s] = 1 ;
    cout << "进入 ： " << u << "   " << s <<endl ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to , w = e[i].w ;
        int tmp = dis[u] + s - dis[v] - w ;  // tmp <= s 可以证明的，用三角形定理，d[u] - d[v] <= w 
        if(tmp < 0 || tmp > k) continue ;
        dfs(v,tmp) ;
        cnt[u][s] = (cnt[u][s] + cnt[v][tmp])  ;
        printf("tmp: %d , dis[u] : %d , dis[v] : %d , w : %d \n",tmp,dis[u],dis[v],w) ;
        cout << "cnt[" << u << "][" << s << "]" << " : " << cnt[u][s] << endl ;
        if(tag) return ;
    }
    visited[u][s] = 0 ;
    cout << "离开 ： " << u << "   " << s <<endl ;
    if(u == n && s == 0) {cnt[u][s] = 1 ; return ;}  // 该位置放于最后用来判断n节点是0环的一部分
}
void init(){
    tot = 0 ; memset(h,0,sizeof(h)) ; memset(rh,0,sizeof(rh)) ;
    memset(cnt,0,sizeof(cnt)) ; tag = 0 ;
}
int main(){
    ios::sync_with_stdio(false) ; cin.tie(nullptr) ; cout.tie(nullptr) ;
    cin >> T ; while(T -- ){
        init() ;
        cin >> n >> m >> k >> P ;
        for(int i=1;i<=m;++i) cin >> a >> b >> c , add(a,b,c) ; 
        dijkstra(n) ; int ans = 0 ; 
        for(int i=0;i<=k;++i){
            memset(visited,0,sizeof(visited)) ;
            dfs(1,i) ;
            ans = (ans + cnt[1][i])  ;
            cout << "ans ： " << ans << endl ;
            cout << "----------------------" <<endl ;
            if(tag) break ;
        }
        if(tag) cout << -1 << endl ;
        else cout << ans << endl ;
    }
    system("pause") ;
}
```

### 引水入城（LG P1514）

**题目：[P1514 [NOIP2010 提高组\] 引水入城 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1514)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 501 , inf = 1e9 ;
int n , m , h[N][N] , L[N][N] , R[N][N] ;  // 海拔高度，左边能到的最远距离和右边能到的最远距离
int dx[5] = {0,-1,1,0,0} ;
int dy[5] = {0,0,0,-1,1} ;
int vis[N][N] ;
void dfs(int x,int y){
    vis[x][y] = 1 ;
    for(int i=1;i<=4;++i){
        int u = x + dx[i] , v = y + dy[i] ;
        if(u < 1 || u > n || v < 1 || v > m) continue ;
        if(h[u][v] >= h[x][y]) continue ;
        if(!vis[u][v]) dfs(u,v) ;
        L[x][y] = min(L[x][y] , L[u][v]) ;
        R[x][y] = max(R[x][y] , R[u][v]) ;
    }
}
int main(){
    cin >> n >> m ; 
    for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) cin >> h[i][j] , L[i][j] = inf , R[i][j] = -inf;
    for(int i=1;i<=m;++i) L[n][i] = R[n][i] = i ;
    for(int i=1;i<=m;++i) {
        if(!vis[1][i]) dfs(1,i) ;
    }
    bool flag = false ; int cnt = 0 ;
    for (int i=1;i<=m;i++)    
        if (!vis[n][i]){
            flag=true;
            cnt++;
        }
    if (flag){
        puts("0");
        printf("%d",cnt);
        return 0;
    }
    int left = 1 ;
    while (left <= m){
        int maxr = 0 ;
        for (int i=1;i<=m;i++) if(L[1][i]<=left) maxr=max(maxr,R[1][i]) ;
        cnt++ ; left=maxr+1 ; 
    }
    puts("1");
    printf("%d",cnt);
    system("pause") ;
}
```

### Cow Traveling S （LG P1535）

**题目：[P1535 [USACO08MAR\]Cow Travelling S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1535)**

```c++
#include <iostream>
using namespace std ;
const int N = 101 ;
int n , m , t , x , y , x2 , y2 ;
int ans ; char ma[N][N] ;
int dx[5] = {0,-1,1,0,0} ;
int dy[5] = {0,0,0,-1,1} ;
void dfs(int x,int y,int t){
    if(t == 0){
        if(x == x2 && y == y2) ans ++ ;
        return ;
    }
    if(abs(x - x2) + abs(y - y2) > t) return ;
    for(int i=1;i<=4;++i){
        int xx = x + dx[i] , yy = y + dy[i] ;
        if(xx < 1 || xx > n || yy < 1 || yy > m) continue ;
        if(ma[xx][yy] == '*') continue ;
        dfs(xx,yy,t-1) ;
    }
}
int main(){
    cin >> n >> m >> t ; 
    for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) cin >> ma[i][j] ;
    cin >> x >> y >> x2 >> y2 ;
    if(ma[x][y] == '*' || ma[x2][y2] == '*'){
        cout << 0 << endl ; return 0 ;
    }
    dfs(x,y,t) ;
    cout << ans << endl ;
    system("pause") ;
}
```

### 滑雪（LG P1434）

**题目：[P1434 [SHOI2002\] 滑雪 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1434)**

```c++
#include <iostream>
using namespace std;
const int N = 101 ;
int n , m , h[N][N] , vis[N][N] , dis[N][N] , ans ;
int dx[5] = {0,-1,1,0,0} ;
int dy[5] = {0,0,0,-1,1} ;
void dfs(int x,int y){
    vis[x][y] = 1 ;
    for(int i=1;i<=4;++i){
        int xx = x + dx[i] , yy = y + dy[i] ;
        if(xx < 1 || xx > n || yy < 1 || yy > m) continue ;
        if(h[x][y] > h[xx][yy]){
            if(!vis[xx][yy]) dfs(xx,yy) ;
            dis[x][y] = max(dis[x][y] , dis[xx][yy] + 1) ;   
        }
    }
}
int main(){
    cin >> n >> m ; 
    for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) cin >> h[i][j] ;
    for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) 
        if(!vis[i][j]) dfs(i,j) , ans = max(ans , dis[i][j]) ;
    cout << ans + 1 << endl ;
    system("pause") ;
}
```

### ==得到新鲜甜甜圈的最多组数（LC 1815）==

**题目：[1815. 得到新鲜甜甜圈的最多组数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-number-of-groups-getting-fresh-donuts/)**

```c++
#define amount(mask , i) (( mask >> ((i - 1) * LEN) ) & 31)
#define nextstate(mask , i) (( mask - (1LL << (i - 1) * LEN)))
class Solution {
private:
    static const int LEN = 5 ; 
public:
    int maxHappyGroups(int batchSize, vector<int>& groups) {
        vector<int> cnt(batchSize) ;
        for(auto e : groups) cnt[e % batchSize] ++ ;

        long long start = 0 ;
        for(int i=batchSize-1;i>=1;--i) {   // 加载状态
            start = ( start << LEN | cnt[i] ) ;
        }

        unordered_map<long long,int> m ;  // 记忆化搜索
        function<int(long long)> dfs = [&](long long mask) {
            if(mask == 0) return 0 ;
            if(m.count(mask)) return m[mask] ;
            
            int total = 0 ;
            for(int i=1;i<batchSize;++i){  // 统计剩下多少饼干
                total += i * amount(mask , i) ;
            }   

            int best = 0 ;
            for(int i=1;i<batchSize;++i){
                if(amount(mask , i)) {
                    int res = dfs(nextstate(mask , i)) ;
                    if((total - i) % batchSize == 0) res ++ ;
                    best = max(best , res) ;
                }
            }
            return m[mask] = best ;
        } ;

        return dfs(start) + cnt[0] ;
    }
};
```



## 剪枝优化

### 小木棍（LG P1120）

**题目：[P1120 小木棍 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1120)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 66 ;
int n , a[N] , sum ;
int vis[N] , len , cnt , nex[N] ; // len是原始木棍的长度，cnt是原始木棍的数量
bool dfs(int cur,int cab,int last) {
    if(cur > cnt) return true ;  // 寻找到了答案
    if(cab == len) return dfs(cur+1,0,0) ;  // 当前cur根原始木棒已经拼接完成
    for(int i=last+1;i<=n;++i){  // 优化，last为上一个木根的位置
        if(vis[i] || cab + a[i] > len) continue ;  // 优化，fail对应的元素已经确定不行了，没必要继续搜索了
        vis[i] = 1 ; 
        if(dfs(cur,cab+a[i],i)) {vis[i] = 0 ; return true ;}
        vis[i] = 0 ; i = nex[i] ; i -- ; // nex数组优化，代表当前长度的木棒搜索过了，就直接跳到下一个长度去
        if(cab == 0 || cab + a[i] == len) return false ;  // 优化，如果第一个木棍不能匹配成功或者当前长度是len就返回false
    }
    return false ;
}
bool check(int m) {
    if(sum % m != 0) return false ;  // 不是整数倍的可以直接返回，优化搜索
    len = m ; cnt = sum / m ; 
    return dfs(1,0,0) ; 
}
int main(){
    scanf("%d",&n) ; for(int i=1;i<=n;++i) {
        scanf("%d",&a[cnt+1]) ; 
        if(a[cnt+1] > 50) continue ;sum += a[++cnt] ;
    } n = cnt ; cnt = 0 ;
    sort(a+1,a+1+n,[&](int x,int y){return x > y ;}) ;  // 优化搜索顺序
    for(int i=1;i<=n;++i){  // nex数组优化，代表当前长度的木棒搜索过了，就直接跳到下一个长度去
        int p = i + 1 ; while(p <= n && a[p] == a[i]) p ++ ;
        for(;i<p;++i) nex[i] = p ; i -- ;
    }
    // 优化寻找答案的顺序
    int i ; for(i=a[1];i<=sum/2;++i) if(check(i)) break ;
    if(i > sum/2) cout << sum << endl ;
    else cout << len << endl ;
    system("pause") ;
}
```

### Mayan 游戏（LG P1312）

**题目：[P1312 [NOIP2011 提高组\] Mayan 游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1312)**

```c++
#include <iostream>
#include <cstring>
using namespace std ;
const int N = 10 ;
int n ;
int ans[N][3] , map[5][7] , last[N][5][7] , xiao[N][N] ;
/******************************************************/
void copy(int x){  // 复制第x步的状态
    for(int i=0;i<5;++i) for(int j=0;j<7;++j) last[x][i][j] = map[i][j] ;
}  // 拷贝第x步之前的状态
void recover(int x){
    for(int i=0;i<5;++i) for(int j=0;j<7;++j) map[i][j] = last[x][i][j] ;
}  // 还原第x步之前的状态状态
/******************************************************/
bool del(){  // 消除连续的方块
    int flag=0;
    for(int i=0;i<5;i++)
        for(int j=0;j<7;j++){
            if(i-1>=0&&i+1<5&&map[i][j]==map[i-1][j]&&map[i][j]==map[i+1][j]&&map[i][j]){
                xiao[i-1][j]=1;xiao[i+1][j]=1;xiao[i][j]=1;flag=1;
            }
            if(j-1>=0&&j+1<7&&map[i][j]==map[i][j+1]&&map[i][j]==map[i][j-1]&&map[i][j]){
                xiao[i][j]=1;xiao[i][j+1]=1;xiao[i][j-1]=1;flag=1;
            }
        }
    if(!flag)return 0;
    for(int i=0;i<5;i++)
        for(int j=0;j<7;j++)
        if(xiao[i][j]){
            xiao[i][j]=0;
            map[i][j]=0;
        } 
    return 1;
}
/******************************************************/
void updata(){  // 更新地图
    for(int i=0;i<5;++i){
        int x = 0 ; 
        for(int j=0;j<7;++j){
            if(!map[i][j]) x ++ ;
            else {
                if(!x) continue ;
                map[i][j-x] = map[i][j] ;
                map[i][j] = 0 ;
            }
        }
    }
}
/******************************************************/
void move(int i ,int j , int op){  // 移动方块
    swap(map[i][j],map[i+op][j]) ;
    updata() ; while(del()) updata() ;
}
/******************************************************/
bool check(){  // 判断答案，是不是都消除了
    for(int i=0;i<5;++i) if(map[i][0]) return false ;
    return true ;
} 
/******************************************************/
void dfs(int x){  // 已经走了x步
    if(check()) {  // 已经消除完毕
        for(int i=0;i<n;++i){
            if(i != 0) cout << '\n' ;
            printf("%d %d %d",ans[i][0],ans[i][1],ans[i][2]) ;
        }
        system("pause") ;
        exit(0) ;  // 退出程序
    }
    if(x == n) return ; copy(x) ;
    for(int i=0;i<5;++i) for(int j=0;j<7;++j) {
        if(!map[i][j]) continue ;
        if(i+1 < 5 && map[i][j] != map[i+1][j]){  // 向右走,优化版本(不过这样写会被hack，因为有时候需要无用的交换来满足次数，只要把后面的条件删除就好了，这里为了体现剪枝优化就不删除了)
            move(i,j,1) ;
            ans[x][0] = i , ans[x][1] = j , ans[x][2] = 1 ;
            dfs(x+1) ;
            ans[x][0] = 0 , ans[x][1] = 0 , ans[x][2] = 0 ;
            recover(x) ;
        }
        if(i-1 >= 0 && !map[i-1][j]) {  // 向左走，优化版本
            move(i,j,-1) ;
            ans[x][0] = i , ans[x][1] = j , ans[x][2] = -1 ;
            dfs(x+1) ;
            ans[x][0] = 0 , ans[x][1] = 0 , ans[x][2] = 0 ;
            recover(x) ;
        }
    }
}
/******************************************************/
int main(){
    cin >> n ; int x ;
    for(int i=0;i<5;++i){
        x = 0 ; 
        while(cin >> map[i][x] , map[i][x++]){}
    }
    dfs(0) ;
    puts("-1") ;
    system("pause") ;
}
```



## A*算法

### K短路（LG P2483）

**题目：[P2483 【模板】k 短路 / [SDOI2010\] 魔法猪学院 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2483)**

```c++
#include <bits/stdc++.h>
#define cin(x) cin >> x 
#define cout(x) cout << x 
using namespace std ;
const int N = 5e3+10 , M = 2e6+10 , inf = 1e9 ; 
/*-------------分割线---------------*/
int n , m ;
double E ; 
/*-------------分割线---------------*/
int h1[N] , h2[N] , idx ;
struct qwq{int to,ne;double w;} e1[M],e2[M] ;
void add(int u,int v,double w){
    e1[++idx] = {v,h1[u],w} ; h1[u] = idx ; // 正图
    e2[idx]   = {u,h2[v],w} ; h2[v] = idx ; // 反图
}
/*-------------分割线---------------*/
int vis[N] ; double dis[N] ;
struct dij{
    int v ; double dis ; 
    bool operator<(const dij& e) const {return dis > e.dis ;}
};
void dijkstra(int s){
    memset(vis,0,sizeof(vis)) ;
    fill(dis+1,dis+1+n,inf) ; dis[s] = 0 ;
    priority_queue<dij> q ; q.push({s,dis[s]}) ;
    while(q.size()){
        int u = q.top().v ; q.pop() ;
        if(vis[u]) continue ; vis[u] = 1 ;
        for(int i=h2[u];i;i=e2[i].ne){
            int v = e2[i].to ; double w = e2[i].w ;
            if(dis[v] > dis[u] + w ){
                dis[v] = dis[u] + w ;
                q.push({v,dis[v]}) ;
            }
        } 
    }
}
/*-------------分割线---------------*/
struct ast{
    int v ; double d , priority ; 
    ast(int _v,double _d):v(_v),d(_d),priority(dis[v]+d){}
    bool operator<(const ast& e) const {return priority > e.priority;}
} ;
int cnt ;
void a_star(int s){
    priority_queue<ast> q ;
    q.push({s,0}) ; 
    while(q.size()){
        ast u = q.top() ; q.pop() ;
        if(u.v == n) {
            if(E >= u.d) cnt++ , E -= u.d;
            else {cout(cnt) ; return ;}
        }
        for(int i=h1[u.v];i;i=e1[i].ne){
            int v = e1[i].to ; double w = e1[i].w ;
            q.push({v,u.d+w}) ; 
        }
    }
}
/*-------------分割线---------------*/
void read(){
    cin(n) ; cin(m) ; cin(E) ;
    int u , v ; double w ;
    for(int i=1 ; i <= m ; i ++) cin >> u >> v >> w , add(u , v , w) ;
}
/*-------------分割线---------------*/
int main(){
    read() ;
    dijkstra(n) ;
    a_star(1) ;
    system("pause");
}
```

# 图

## tarjan算法割点,桥与强连通分量

### 受欢迎的奶牛（LG P2341）

**题目：[P2341 [USACO03FALL / HAOI2006\] 受欢迎的牛 G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2341)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e4+10 , M = 2e5+10 ;
int h[N] , tot = 1 ; struct qwq{int to,ne;} e[M] ;
void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}  
int n , m , ans , oud[N] ; int a , b ,c ;  // 全局变量
int dfn[N] , low[N] , tim , instk[N] , scc[N] , siz[N] , cnt ; stack<int> st ;
void tarjan(int u){
    dfn[u] = low[u] = ++tim ; st.push(u) ;instk[u] = 1 ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(!dfn[v]) tarjan(v) , low[u] = min(low[u],low[v]) ;
        else if(instk[v]) low[u] = min(low[u],dfn[v]) ;
    }
    if(dfn[u] == low[u]){
        int v ; ++ cnt ;
        do{
            v = st.top() ; st.pop() ; instk[v] = 0 ;
            scc[v] = cnt ; siz[cnt] ++ ;
        }while(v!=u) ;
    }
}
int main(){
    cin >> n >> m ;
    for(int i=1;i<=m;++i) cin >> a >> b , add(a,b) ;
    for(int i=1;i<=n;++i) if(!dfn[i]) tarjan(i) ;
    for(int u=1;u<=n;++u) for(int i=h[u];i;i=e[i].ne) {
        int v = e[i].to ; 
        if(scc[u] != scc[v]) oud[scc[u]] ++ ;
    } 
    int ccc = 0 ;  // oud出度
    for(int i=1;i<=cnt;++i) if(!oud[i]) ccc++ , ans = siz[i] ;
    if(ccc == 1) cout << ans << endl ;
    else cout << 0 << endl ;
    system("pause") ;
}
```

### The Cow Prom S (LG P2863)

**题目：[P2863 [USACO06JAN\]The Cow Prom S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2863)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4+10 , M = 1e6+10 ;
int h[N] , tot ; int n , m , ans ;
struct edge{int to,ne;} e[M] ;
void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
int scc[N] , siz[N] , cnt ;
int ins[N] ; stack<int> s ;
int dfn[N] , low[N] , tim ;
void tarjan(int u){
    dfn[u] = low[u] = ++tim ; s.push(u) ; ins[u] = 1 ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(!dfn[v]){
            tarjan(v) ;
            low[u] = min(low[u],low[v]) ;
        }else if(ins[v]){
            low[u] = min(low[u],dfn[v]) ;
        }
    }
    if(dfn[u] == low[u]){
        int v ; cnt++ ;
        do{
            v = s.top() ; s.pop() ; ins[v] = 0 ;
            scc[v] = cnt ; siz[cnt]++ ;
        }while(v != u) ;
        if(siz[cnt] > 1) ans++ ;
    }
}
int main(){
    cin >> n >> m ; int u , v ; 
    for(int i=1;i<=m;++i) cin >> u >> v , add(u,v);
    for(int i=1;i<=n;++i) if(!dfn[i]) tarjan(i) ;
    cout << ans << endl ;
    system("pause");
}

```

### 校园网络（LG P2812）

**题目：[P2812 校园网络](https://www.luogu.com.cn/problem/P2812)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e5 + 10 , M = 2e6 + 10 ;
int h[N] , tot = 1 ; struct qwq{int to,ne;} e[M] ;
void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
int n , a , b , c , u , v , w ; int oud[N] , ind[N] ;
int dfn[N] , low[N] , tim , scc[N] , cnt , instk[N] ; stack<int> st ;
void tarjan(int u){
    dfn[u] = low[u] = ++ tim ; st.push(u) ; instk[u] = 1 ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(!dfn[v]) {
            tarjan(v) ; low[u] = min(low[u] , low[v]) ;
        } else if(instk[v]) low[u] = min(low[u],dfn[v]) ;
    }
    if(dfn[u] == low[u]){
        int v ; ++ cnt ; do{
            v = st.top() ; st.pop() ; scc[v] = cnt ; instk[v] = 0 ;
        }while(v != u) ;
    }
}
int main(){
    cin >> n ;
    for(int u=1;u<=n;++u) while(cin >> v , v) add(u,v) ;
    for(int u=1;u<=n;++u) if(!dfn[u]) tarjan(u) ;
    for(int u=1;u<=n;++u) for(int i=h[u];i;i=e[i].ne) {
        int v = e[i].to ;
        if(scc[u] != scc[v]) ind[scc[v]] ++ , oud[scc[u]] ++ ;
    }
    for(int u=1;u<=cnt;++u) {
        if(!ind[u]) a++ ;
        if(!oud[u]) b++ ;
    }
    if(cnt == 1) {cout << 1 << endl << 0 << endl ; return 0 ;} // 特判一个强连通图
    b = max(a,b) ; // 使一个图变成强连通图的最少边数就是DAG的max（出度为0的数量，入度为0的数量）
    cout << a << endl << b << endl ;
    system("pause") ;
}
```

### 稳定婚姻（LG P1407）

**题目：[P1407 [国家集训队\]稳定婚姻 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1407)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e5 + 10 , M = 2e6+10 ;
int h[N] , tot = 1 ; struct qwq{int to,ne;}e[M] ;
void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
int n , m , idx ; unordered_map<string,int> mp; 
int dfn[N] , low[N] , tim , instk[N] , scc[N] , cnt ; stack<int> st ;
void tarjan(int u){
    dfn[u] = low[u] = ++tim ; st.push(u) ; instk[u] = 1 ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(!dfn[v]) tarjan(v) , low[u] = min(low[u],low[v]) ;
        else if(instk[v]) low[u] = min(low[u],dfn[v]) ;
    }
    if(dfn[u] == low[u]){
        int v ; ++ cnt ;
        do{
            v = st.top() ; st.pop() ; instk[v] = 0 ;
            scc[v] = cnt ;
        }while(v!=u) ;
    }
}
int main(){
    cin >> n ; string s1 , s2 ; 
    for(int i=1;i<=n;++i){
        cin >> s1 >> s2 ; mp[s1] = ++idx ; mp[s2] = ++idx ;
        add(mp[s1],mp[s2]) ;
    }
    cin >> m ;
    for(int i=1;i<=m;++i){
        cin >> s1 >> s2 ; 
        add(mp[s2],mp[s1]) ;
    }
    for(int i=1;i<=idx;++i) if(!dfn[i]) tarjan(i) ;
    for(int i=1;i<=n;++i){
        if(scc[i*2-1] == scc[i*2]) cout << "Unsafe" << endl ;
        else cout << "Safe" << endl ;
    }
    system("pause") ;
}
```

### 最大半连通子图（LG P2272）

**题目：[P2272 [ZJOI2007\]最大半连通子图 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2272)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e5+10 , M = 2e6+10 ;
int h[N] , tot ; struct qwq{int to,ne;}e[M];
void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
int hs[N] , tots ; qwq es[M];
void adds(int u,int v){es[++tots]={v,hs[u]};hs[u]=tots;}
int n , m , P ;  map<pair<int,int>,bool> isExist ;
int dfn[N] , low[N] , tim , scc[N] , siz[N] , cnt , instk[N] ; stack<int> st ;
void tarjan(int u){
    dfn[u] = low[u] = ++ tim ; st.push(u) ; instk[u] = 1 ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(!dfn[v]){
            tarjan(v) ; low[u] = min(low[u],low[v]) ;
        }else if(instk[v]) low[u] = min(low[u],dfn[v]) ;
    }
    if(dfn[u] == low[u]){
        int v ; ++ cnt ;
        do{
            v = st.top() ; st.pop() ; instk[v] = 0 ; scc[v] = cnt ; siz[cnt] ++ ;
        }while(v != u) ;
    }
}
int K , C ; 
int ind[N] ; int f[N] , cot[N] ; // 到达i点的最大节点数和该节点数的方案数
void topo(){  // 注意只有一个点的时候
    queue<int> q ;
    for(int i=1;i<=cnt;++i) {
        f[i] = siz[i] ; cot[i] = 1 ; K = max(K , f[i]) ;
        if(!ind[i]) q.push(i) ;
    }
    while(q.size()){
        int u = q.front() ; q.pop() ; 
        for(int i=hs[u];i;i=es[i].ne){
            int v = es[i].to ;
            if(f[u] + siz[v] == f[v]){
                cot[v] = ( cot[v] + cot[u] ) % P ;
            } else if(f[u] + siz[v] > f[v]) {
                f[v] = f[u] + siz[v] ;
                cot[v] = cot[u] ;
            }
            K = max(K , f[v]) ;
            if(!--ind[v]) q.push(v) ;
        }
    }
    for(int i=1;i<=cnt;++i) if(f[i] == K) C = (C + cot[i]) % P ;
}
int main(){
    cin >> n >> m >> P ; int u , v ;
    for(int i=1;i<=m;++i) cin >> u >> v , add(u,v) ;
    for(int i=1;i<=n;++i) if(!dfn[i]) tarjan(i) ;
    for(int u=1;u<=n;++u) for(int i=h[u];i;i=e[i].ne) {
        int v = e[i].to ; 
        if(scc[u] != scc[v] && !isExist.count( make_pair(scc[u],scc[v]) ) ) {  // 去重边
            adds(scc[u],scc[v]) ; ind[scc[v]] ++ ; 
            isExist[make_pair(scc[u],scc[v])] = 1 ;
        }
    }
    topo() ;
    cout << K << endl << C << endl ;
    system("pause") ;
}

```

### 嗅探器（LG P5058）

**题目：[P5058 [ZJOI2004\]嗅探器 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5058)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 2e5 + 10 , M = 2e6 + 10 ;
int h[N] , tot = 1 ; struct qwq{int to,ne;}e[M] ;
void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;e[++tot]={u,h[v]};h[v]=tot;}
int n , a , b ;
int dfn[N] , low[N] , cut[N] , tim , root ; 
void tarjan(int u){
    dfn[u] = low[u] = ++ tim ; int child = 0 ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(!dfn[v]){
            tarjan(v) ; low[u] = min(low[u],low[v]) ;
            if(low[v] >= dfn[u]){
                child ++ ; 
                if(u != root || child > 1) { // 判断割点是一条边一条边的判断，判断这条边对应的那一片连通块是不是不可以没有u，记住，一条边对应一片连通块
                    if(dfn[a] <= dfn[u] && dfn[b] >= dfn[v]) cut[u] = 1 ; // 记录能让a和b分成两半的割点，不是全部割点
                    if(dfn[b] <= dfn[u] && dfn[a] >= dfn[v]) cut[u] = 1 ;
                }
            }
        } else low[u] = min(low[u],dfn[v]) ;
    }
}
int main(){
    cin >> n ; int u , v ;
    while(cin >> u >> v , u) add(u,v) ;
    cin >> a >> b ;
    for(int i=1;i<=n;++i) if(!dfn[i]) root = i ,tarjan(i) ;
    for(int i=1;i<=n;++i) if(cut[i] && i!=a && i!=b){cout << i << endl ; system("pause") ; return 0 ;}
    cout << "No solution" << endl ;
    system("pause") ;
}
```

### 矿场搭建（LG P3225）

**题目：[P3225 [HNOI2012\]矿场搭建 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3225)**

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e4+10 , M = 1e6+10 ;
int h[N] , tot ; struct edge{int to,ne;} e[M] ;
void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
int n ; 
int dfn[N] , low[N] , tim , cut[N] , root , cnt ; 
stack<int> st ; vector<int> vdcc[N] ;
void tarjan(int u) {
    dfn[u] = low[u] = ++ tim ; int child = 0 ; st.push(u) ;
    if(h[u] == 0) vdcc[++cnt].push_back(u) ; 
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(!dfn[v]) {
            tarjan(v) ; low[u] = min(low[u],low[v]) ;
            if(low[v] >= dfn[u]) {
                child ++ ; 
                if(u != root || child > 1) cut[u] = 1 ;
                int x ; cnt ++ ;
                do{
                    x = st.top() ; st.pop() ;
                    vdcc[cnt].push_back(x) ; 
                }while(x != v) ;
                vdcc[cnt].push_back(u) ;
            }
        } else low[u] = min(low[u],dfn[v]) ;
    }
}
signed main(){
    int iii = 0 ;
    while(cin >> n , n){
        int u , v , ansa = 0 , ansb = 1 ; iii ++ ; int nn = 0 ; for(int i=1;i<=cnt;++i) vdcc[i].clear() ;
        memset(dfn,0,sizeof(dfn)) ; memset(h,0,sizeof(h)) ; tot = 0 ; cnt = 0 ; while(st.size()) st.pop() ;
        memset(low,0,sizeof(low)) ; memset(cut,0,sizeof(cut)) ; tim = 0 ; memset(e,0,sizeof(e)) ;
        for(int i=1;i<=n;++i) cin >> u >> v , add(u , v) , add(v,  u) ,  nn = max(nn,max(u,v)) ;
        for(int i=1;i<=nn;++i) if(!dfn[i]) root = i , tarjan(i) ;
        for(int i=1;i<=cnt;++i) {
            int sss = 0 ;
            for(int j=0;j<vdcc[i].size();++j) {
                sss += cut[vdcc[i][j]] ;
            }
            int nnn = vdcc[i].size() ;
            if(sss == 0) {
                ansa += 2 ; ansb *= nnn*(nnn-1)/2 ;
            } else if(sss == 1) {
                ansa += 1 ; ansb *= nnn-1 ;
            }
        }  
        printf("Case %d: %d %lld\n",iii,ansa,ansb) ;
    }
    system("pause");
}

```

## 树链剖分

### Grass Planting G （LG P3038）

**题目：[P3038 [USACO11DEC\]Grass Planting G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3038)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 2e5 + 10 , M = 2e6 + 10 ; 
int nw[N] , id[N] , idx ;  int n , m , root , P = 0x7fffffff;
int h[N] , tot ; struct qwq{int to,ne;} e[M] ; void adde(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
namespace SegTree {
    #define lc (p << 1)
    #define rc (p << 1 | 1)
    #define sum(x) tr[x].sum
    #define add(x) tr[x].add
    struct node{int sum,add;} tr[N << 2] ;
    void pushup(int p){sum(p) = (sum(lc) + sum(rc))%P ;}
    void pushdown(int p,int l,int r){
        if(!add(p)) return ; int m = l + r >> 1 ;
        sum(lc) = (sum(lc) + (m - l + 1) * add(p))%P ; 
        sum(rc) = (sum(rc) + (r - m) * add(p))%P ; 
        add(lc) = (add(lc) + add(p))%P ; add(rc) = (add(rc) + add(p))%P ; add(p) = 0 ;
    }
    int query(int p,int l,int r,int x,int y) {
        if(x <= l && y >= r) return sum(p) ;
        pushdown(p,l,r) ;
        int m = l + r >> 1 ; int res = 0 ;
        if(x <= m) res = (res + query(lc,l,m,x,y))%P ;
        if(y >= m+1) res = (res + query(rc,m+1,r,x,y))%P ;
        pushup(p) ;
        return res ;
    }
    void updata(int p,int l,int r,int x,int y,int k) {
        if(x <= l && y >= r) {
            sum(p) = (sum(p) + (r - l + 1) * k)%P ;
            add(p) = (add(p) + k)%P ; return ;
        }
        pushdown(p,l,r) ;
        int m = l + r >> 1 ;
        if(x <= m) updata(lc,l,m,x,y,k) ;
        if(y >= m+1) updata(rc,m+1,r,x,y,k) ;
        pushup(p) ;
    }
}
namespace TreeLink {
    int dep[N] , fa[N] , siz[N] , son[N] , top[N] ;
    void dfs1(int u,int father){  // 处理 dep fa son siz
        fa[u] = father ; dep[u] = dep[father] + 1 ; siz[u] = 1 ;
        for(int i=h[u];i;i=e[i].ne) {
            int v = e[i].to ; 
            if(v == father) continue ;
            dfs1(v,u) ; siz[u] += siz[v] ;
            if(siz[son[u]] < siz[v]) son[u] = v ;
        }
    }
    void dfs2(int u,int tp){ // 处理 top 和 nw 和 id
        top[u] = tp ; id[u] = ++ idx ; 
        if(!son[u]) return ;
        dfs2(son[u],tp) ;
        for(int i=h[u];i;i=e[i].ne) {
            int v = e[i].to ; 
            if(v == fa[u] || v == son[u]) continue ;
            dfs2(v,v) ;
        }
    }
    void updata(int u,int v,int k) {  // 1 更新u到v
        while(top[u] != top[v]) {
            if(dep[top[u]] < dep[top[v]]) swap(u,v) ;
            SegTree::updata(1,1,n,id[top[u]],id[u],k) ;
            u = fa[top[u]] ;
        }
        if(dep[u] == dep[v]) return ;
        if(dep[u] < dep[v]) swap(u,v) ;
        SegTree::updata(1,1,n,id[v]+1,id[u],k) ;
    }
    int query(int u,int v){  // 2 查询u到v的
        int ans = 0 ;
        while(top[u] != top[v]) {
            if(dep[top[u]] < dep[top[v]]) swap(u,v) ;
            ans = (ans + SegTree::query(1,1,n,id[top[u]],id[u]))%P ;
            u = fa[top[u]] ;
        }
        if(dep[u] < dep[v]) swap(u,v) ;
        ans = (ans + SegTree::query(1,1,n,id[v],id[u]))%P ;
        return ans - SegTree::query(1,1,n,id[v],id[v]);  // 减去转折点的
    }
}
int main(){
    cin >> n >> m ; int u , v ; root = n ; 
    for(int i=1;i<n;++i) cin >> u >> v , adde(u,v) , adde(v,u) ; 
    TreeLink::dfs1(root,0) ; TreeLink::dfs2(root,root) ; 
    while(m--){    
        char op ;
        cin >> op ;
        if(op=='P'){
            cin >> u >> v ; TreeLink::updata(u,v,1) ;
        }else{
            cin >> u >> v ; cout << TreeLink::query(u,v) << endl ;
        }
    }
    system("pause") ;
}
```

### Max Flow P （LG P3128）

**题目：[P3128 [USACO15DEC\]Max Flow P - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3128)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e5 + 10 , M = 2e6 + 10 ;
int n , k ;
int h[N] , tot ; struct qwq{int to,ne;} e[M] ; void adde(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
int id[N] , fa[N] , siz[N] , son[N] , idx , top[N] , dep[N] ;
void dfs1(int u,int father){
    fa[u] = father ; siz[u] = 1 ; dep[u] = dep[father] + 1 ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(v == father) continue ;
        dfs1(v,u) ;
        siz[u] += siz[v] ;
        if(siz[son[u]] < siz[v]) son[u] = v ;
    }
}
void dfs2(int u,int tp){
    top[u] = tp ; id[u] = ++ idx ;
    if(!son[u]) return ;
    dfs2(son[u],tp) ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(v == fa[u] || v == son[u]) continue ;
        dfs2(v,v) ;
    }
}
#define sum(x) tr[x].sum
#define add(x) tr[x].add
#define lc (p << 1)
#define rc (p << 1 | 1)
struct lpl{int sum,add;}tr[N << 2] ;
void pushup(int p){sum(p) = sum(lc) + sum(rc) ;}
void pushdown(int p,int l,int r){
    if(!add(p)) return ; int m = l + r >> 1 ;
    sum(lc) += (m - l + 1) * add(p) ;
    sum(rc) += (r - m) * add(p) ; 
    add(lc) += add(p) ; add(rc) += add(p) ; add(p) = 0 ;
}
void modify(int p,int l,int r,int x,int y,int k){
    if(x <= l && y >= r) {
        sum(p) += (r - l + 1) * k ;
        add(p) += k ; return ;
    }
    pushdown(p,l,r) ;
    int m = l + r >> 1 ;
    if(x <= m) modify(lc,l,m,x,y,k) ;
    if(y > m) modify(rc,m+1,r,x,y,k) ;
    pushup(p) ;
}
int query(int p,int l,int r,int x,int y){
    if(x <= l && y >= r) return sum(p) ;
    pushdown(p,l,r) ;
    int m = l + r >> 1 ; int res = 0 ;
    if(x <= m) res += query(lc,l,m,x,y) ;
    if(y > m) res += query(rc,m+1,r,x,y) ;
    pushup(p) ;
    return res ;
}
void updata(int u,int v){
    while(top[u] != top[v]) {
        if(dep[top[u]] < dep[top[v]]) swap(u,v) ;
        modify(1,1,n,id[top[u]],id[u],1) ;
        u = fa[top[u]] ;
    }
    if(dep[u] < dep[v]) swap(u,v) ;
    modify(1,1,n,id[v],id[u],1) ; 
}
int main(){
    cin >> n >> k ; int u , v , ans = 0 ;
    for(int i=1;i<n;++i) cin >> u >> v , adde(u,v) , adde(v,u) ;
    dfs1(1,0) ; dfs2(1,1) ;
    for(int i=1;i<=k;++i) cin >> u >> v , updata(u,v) ;
    for(int i=1;i<=n;++i) ans = max(ans,query(1,1,n,id[i],id[i])) ;
    cout << ans << endl ;
    system("pause") ;
}
```

### 求和（LG P4427）

**题目：[P4427 [BJOI2018\]求和 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4427)**

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std ; 
const int N = 3e5 + 10 , M = 2e6 + 10 , K = 51 , P = 998244353 ;
int n , m ;
int h[N] , tot ; struct qwq{int to,ne;} e[M] ; void adde(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
int f[N][K] ; // 根节点到u的k次方的和,设根节点是1
int fa[N] , siz[N] , son[N] , dep[N] , top[N] ;
int mod(int x){
    return (x + P) % P ;
}
int qpow(int x,int y){
    int res = 1 ; 
    while(y){
        if(y & 1) res = mod(res * x) ;
        x = mod(x * x) ;
        y >>= 1 ;
    }
    return res ;
}
void dfs1(int u,int father){  // dep[0] = -1 ;
    fa[u] = father ; siz[u] = 1 ; dep[u] = dep[father] + 1 ;
    for(int k=1;k<=50;++k) {
        f[u][k] = mod( f[father][k] + qpow(dep[u],k) )  ;
        //cout << f[u][k] << " " ;
    }
    //cout << "----------------------" << endl ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ; 
        if(v== father) continue ;
        dfs1(v,u) ;
        siz[u] += siz[v] ;
        if(siz[son[u]] < siz[v]) son[u] = v ;
    }
}
void dfs2(int u,int tp){
    top[u] = tp ; 
    if(!son[u]) return ;
    dfs2(son[u],tp) ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ; 
        if(v== fa[u] || v == son[u]) continue ;
        dfs2(v,v) ;
    }
}
int query(int u,int v,int k){
    int res = 0 ; 
    while(top[u] != top[v]){
        if(dep[top[u]] < dep[top[v]]) swap(u,v) ;
        res = mod(res + f[u][k] - f[fa[top[u]]][k]) ;
        u = fa[top[u]] ;
    }
    if(dep[u] < dep[v]) swap(u,v) ;
    res = mod(res + f[u][k] - f[fa[v]][k]) ;
    return res ;
}
signed main(){
    cin >> n ; int u , v , k ; dep[0] = -1 ;
    for(int i=1;i<n;++i) cin >> u >> v , adde(u,v) , adde(v,u) ;
    dfs1(1,0) ; dfs2(1,1) ; cin >> m ;
    for(int i=1;i<=m;++i) {
        cin >> u >> v >> k ;
        cout << mod(query(u,v,k)) << endl ;
    }
    system("pause") ;
}
```

### 树（LG P4092）

**题目;[P4092 [HEOI2016/TJOI2016\]树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4092)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e5 + 10 , M = 2e6 + 10 ; 
int n , m ; int tag[N] ;
int h[N] , tot ; struct qwq{int to,ne;} e[M] ; void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
int fa[N] , siz[N] , son[N] , dep[N] , top[N] , id[N] , rid[N] , idx ;
void dfs1(int u,int father){
    fa[u] = father ; dep[u] = dep[father] + 1 ; siz[u] = 1 ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(v == father) continue ; 
        dfs1(v,u) ;
        siz[u] += siz[v] ;
        if(siz[son[u]] < siz[v]) son[u] = v ;
    }
}
void dfs2(int u,int tp){
    top[u] = tp ; id[u] = ++ idx ; rid[idx] = u ;
    if(!son[u]) return ;
    dfs2(son[u],tp) ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(v == fa[u] || v == son[u]) continue ; 
        dfs2(v,v) ;
    }
}
#define lc (p << 1) 
#define rc (p << 1 | 1)
int lca[N << 2] ;
void up(int p) {
    lca[p] = max(lca[lc],lca[rc]) ;
}
void updata_seg(int p,int l,int r,int x) {
    if(l == r) {lca[p] = x ; return ;}
    int m = l + r >> 1 ; 
    if(x <= m) updata_seg(lc,l,m,x) ;
    else updata_seg(rc,m+1,r,x) ;
    up(p) ;
}
void updata(int u) {
    updata_seg(1,1,n,id[u]) ;
}
int query_seg(int p,int l,int r,int x,int y) {
    if(x <= l && y >= r) return lca[p] ;
    int m = l + r >> 1 ; int a = 0 , b = 0 ;
    if(x <= m) a = query_seg(lc,l,m,x,y) ;
    if(y > m) b = query_seg(rc,m+1,r,x,y) ;
    up(p) ;
    return max(a , b) ;
}
int query(int u){
    int res = 0 ;
    while(!(res = query_seg(1,1,n,id[top[u]],id[u]))) u = fa[top[u]] ;
    return rid[res] ;
}

int main(){
    ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
    cin >> n >> m ; int u , v ;
    for(int i=1;i<n;++i) cin >> u >> v , add(u,v) , add(v,u) ;
    dfs1(1,0) ; dfs2(1,1) ; updata(1) ; char op ;
    while(m--) {
        cin >> op >> u ;
        if(op == 'C'){
            updata(u) ;
        } else {
            cout << query(u) << endl ;
        }
    }
    system("pause") ;
}
```

### Disruption P （LG P4374）

**题目：[P4374 [USACO18OPEN\]Disruption P - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4374)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e5+10 , M = 2e6 + 10 , inf = 1061109567 ;
int n , m ; struct eqq{int u,v;} ; vector<eqq> edge ;
int h[N] , tot ; struct qwq{int to,ne;}e[M] ; void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
int fa[N] , son[N] , siz[N] , dep[N] , top[N] , id[N] , idx ; 
void dfs1(int u,int father){
    fa[u] = father ; dep[u] = dep[father] + 1 ; siz[u] = 1 ;
    for(int i=h[u];i;i=e[i].ne) {
        int v = e[i].to ;
        if(v == father) continue ;
        dfs1(v,u) ;
        siz[u] += siz[v] ;
        if(siz[son[u]] < siz[v]) son[u] = v ;
    }
}
void dfs2(int u,int tp){
    top[u] = tp ; id[u] = ++ idx ; if(!son[u]) return ;
    dfs2(son[u],tp) ;
    for(int i=h[u];i;i=e[i].ne) {
        int v = e[i].to ;
        if(v == fa[u] || v == son[u]) continue ;
        dfs2(v,v) ;
    }
}
#define lc (p << 1)
#define rc (p << 1 | 1)
int mi[N << 2] , lz[N << 2];
void up(int p){
    mi[p] = min(mi[lc],mi[rc]) ;
}
void down(int p){
    lz[lc] = min(lz[lc],lz[p]) ; lz[rc] = min(lz[rc],lz[p]) ;
    mi[lc] = min(mi[lc],lz[p]) ; mi[rc] = min(mi[rc],lz[p]) ;
    lz[p] = inf ;
}
void updata(int p,int l,int r,int x,int y,int k){
    if(x <= l && y >= r) {
        mi[p] = min(mi[p],k) ; lz[p] = min(lz[p],k) ; return ;
    }
    down(p) ;
    int m = l + r >> 1 ;
    if(x <= m) updata(lc,l,m,x,y,k) ;
    if(y > m) updata(rc,m+1,r,x,y,k) ;
    up(p) ;
}
void modify(int u,int v,int k){
    while(top[u] != top[v]){
        if(dep[top[u]] < dep[top[v]]) swap(u,v) ;
        updata(1,1,n,id[top[u]],id[u],k) ;
        u = fa[top[u]] ;
    }
    if(u == v) return ; 
    if(dep[u] < dep[v]) swap(u,v) ;
    updata(1,1,n,id[v]+1,id[u],k) ;
}
int query(int p,int l,int r,int x){
    if(l == r) return mi[p] ;
    down(p) ;
    int m = l + r >> 1 ; int res = inf ;
    if(x <= m) res = min(res,query(lc,l,m,x)) ;
    else res = min(res,query(rc,m+1,r,x)) ;
    up(p) ;
    return res ;
}
int main(){
    memset(mi,0x3f,sizeof(mi)) ; memset(lz,0x3f,sizeof(lz)) ;
    cin >> n >> m ; int u , v , k ;
    for(int i=1;i<n;++i) cin >> u >> v , add(u,v) , add(v,u) , edge.push_back({u,v}) ;
    dfs1(1,0) ; dfs2(1,1) ;
    for(int i=1;i<=m;++i) cin >> u >> v >> k , modify(u,v,k) ;
    for(auto e : edge) {
        u = dep[e.u] > dep[e.v] ? e.u : e.v ;
        int res = query(1,1,n,id[u]) ;
        if(res == inf) cout << -1 << endl ;
        else cout << res << endl ;
    }
    system("pause") ;
}
```

### 染色（LG P2486）

**题目：[P2486 [SDOI2011\]染色 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2486)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e5+10 , M = 2e6 + 10 , inf = 1061109567 ;
int n , m , color[N] ; 
int h[N] , tot ; struct qwq{int to,ne;}e[M] ; void add(int u,int v){e[++tot]={v,h[u]};h[u]=tot;}
int fa[N] , son[N] , siz[N] , dep[N] , top[N] , id[N] , rid[N] , idx ; 
void dfs1(int u,int father){
    fa[u] = father ; dep[u] = dep[father] + 1 ; siz[u] = 1 ;
    for(int i=h[u];i;i=e[i].ne) {
        int v = e[i].to ;
        if(v == father) continue ;
        dfs1(v,u) ;
        siz[u] += siz[v] ;
        if(siz[son[u]] < siz[v]) son[u] = v ;
    }
}
void dfs2(int u,int tp){
    top[u] = tp ; id[u] = ++ idx ; rid[idx] = u ; if(!son[u]) return ;
    dfs2(son[u],tp) ;
    for(int i=h[u];i;i=e[i].ne) {
        int v = e[i].to ;
        if(v == fa[u] || v == son[u]) continue ;
        dfs2(v,v) ;
    }
}
#define lc (p << 1)
#define rc (p << 1 | 1)
int lz[N << 2] , lec[N << 2] , ric[N << 2] , num[N << 2] ; // 下传染色标记，左边颜色，右边颜色 , 颜色段数量
void up(int p){
    if(ric[lc] == lec[rc]) {
        num[p] = num[lc] + num[rc] - 1 ;
        lec[p] = lec[lc] ; ric[p] = ric[rc] ;
    } else {
        num[p] = num[lc] + num[rc] ;
        lec[p] = lec[lc] ; ric[p] = ric[rc] ;
    }
}
void down(int p){
    if(!lz[p]) return ;
    lz[lc] = lz[rc] = lz[p] ; 
    lec[lc] = lec[rc] = ric[lc] = ric[rc] = lz[p] ; 
    num[lc] = num[rc] = 1 ; lz[p] = 0 ; 
}
void build(int p,int l,int r) {
    if(l == r) {
        lz[p] = ric[p] = lec[p] = color[rid[l]] ; 
        num[p] = 1 ; return ;
    }
    int m = l + r >> 1 ;
    build(lc,l,m) ; build(rc,m+1,r) ;
    up(p) ;
}
void updata(int p,int l,int r,int x,int y,int c){
    if(x <= l && y >= r) {
        lz[p] = lec[p] = ric[p] = c ; 
        num[p] = 1 ; return ;
    }
    down(p) ;
    int m = l + r >> 1 ;
    if(x <= m) updata(lc,l,m,x,y,c) ;
    if(y > m) updata(rc,m+1,r,x,y,c) ;
    up(p) ;
}
void modify(int u,int v,int c){
    while(top[u] != top[v]){
        if(dep[top[u]] < dep[top[v]]) swap(u,v) ;
        updata(1,1,n,id[top[u]],id[u],c) ;
        u = fa[top[u]] ;
    }
    if(dep[u] < dep[v]) swap(u,v) ;
    updata(1,1,n,id[v],id[u],c) ;
}
int query(int p,int l,int r,int x,int y){
    if(x <= l && y >= r) return num[p] ;
    down(p) ;
    int m = l + r >> 1 ; int a = 0 , b = 0 ;
    if(y <= m) return a = query(lc,l,m,x,y) , up(p) , a ; 
    else if(x > m) return b = query(rc,m+1,r,x,y) , up(p) , b ;
    else {
        a = query(lc,l,m,x,y) ; b = query(rc,m+1,r,x,y) ;
        up(p) ;
        return ric[lc] == lec[rc] ? a+b-1 : a+b ;
    } 
}
int queryc(int p,int l,int r,int x){
    if(l == r) return lec[p] ;
    int m = l + r >> 1 ;
    down(p) ; int res = 0 ;
    if(x <= m) res = queryc(lc,l,m,x) ;
    else res = queryc(rc,m+1,r,x) ;
    up(p) ; return res ;
}
int ask(int u,int v){
    int res = 0 ;
    while(top[u] != top[v]){
        if(dep[top[u]] < dep[top[v]]) swap(u,v) ;
        res += query(1,1,n,id[top[u]],id[u]) ;
        if(queryc(1,1,n,id[top[u]]) == queryc(1,1,n,id[fa[top[u]]])) res -- ;
        u = fa[top[u]] ;
    }
    if(dep[u] < dep[v]) swap(u,v) ;
    res += query(1,1,n,id[v],id[u]) ;
    return res ;
}
int main(){
    cin >> n >> m ; int u , v , c ; char op ;
    for(int i=1;i<=n;++i) cin >> color[i] ;
    for(int i=1;i<n;++i) cin >> u >> v , add(u,v) , add(v,u) ;
    dfs1(1,0) ; dfs2(1,1) ; build(1,1,n) ;
    while(m -- ){
        cin >> op >> u >> v ;
        if(op == 'Q') {
            cout << ask(u,v) << endl ;
        } else {
            cin >> c ; modify(u,v,c) ;
        }
    }
    system("pause") ;
}
```



## 其他

### 克隆图（LC 133）

**题目：[133. 克隆图 - 力扣（LeetCode）](https://leetcode.cn/problems/clone-graph/)**

```c++
class Solution {
public:
    unordered_map< Node*, Node*> visited;
    Node* cloneGraph(Node* node) {
        // BFS
        if(node==NULL) return NULL;
        queue<Node*> Q;
        Q.push(node);
        visited[node] = new Node(node->val);
        while(!Q.empty()){
            auto n = Q.front();
            Q.pop();
            // 遍历该节点的邻居
            for (auto& neighbor: n->neighbors) {
                if (visited.find(neighbor) == visited.end()) {
                    // 如果没有被访问过，就克隆并存储在哈希表中
                    visited[neighbor] = new Node(neighbor->val);
                    // 将邻居节点加入队列中
                    Q.push(neighbor);
                }
                // 更新当前节点的邻居列表
                visited[n]->neighbors.push_back(visited[neighbor]);
            }
        }
        return visited[node];


        // DFS
        /* if(node==NULL) return NULL;
        if(mp.find(node) != mp.end()) return mp[node];

        Node* root = new Node(node->val);
        mp[node] = root;

        for(int i=0;i<node->neighbors.size();++i){
            root->neighbors.push_back(cloneGraph(node->neighbors[i]));
        }
        return root; */
    }
};
```



### 传递信息（LC LCP07）

```c++
class Solution {
private:
    
public:
    int numWays(int n, vector<vector<int>>& relation, int k) {
        // DFS暴搜
        vector<vector<int>> edges(n);
        for (auto &edge : relation) 
            edges[edge[0]].push_back(edge[1]);
        int ways = 0;

        function<void(int, int)> dfs = [&](int index, int steps) {
            if (steps == k) {
                if (index == n - 1) 
                    ++ways;
                return;
            }
            for (int endPoint : edges[index]) dfs(endPoint, steps + 1);
        };
        dfs(0, 0);

        return ways;

        // 动态规划
        /* int dp[n][k+1];  // dp[i][j] 代表到达第i个人第j轮的方法数
        memset(dp,0,sizeof(dp));
        dp[0][0] = 1;  // 第0个人0轮的方法数
        for(int j=1;j<=k;++j){
            for(int p=0;p<relation.size();++p){
                dp[relation[p][1]][j] += dp[relation[p][0]][j-1]; 
            }
        }
        return dp[n-1][k]; */
    }
};
```

## [收集树上所有苹果的最少时间](https://leetcode.cn/problems/minimum-time-to-collect-all-apples-in-a-tree/)

```c++
class Solution {
public:         
    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {
        vector<int> adj[n] ;
        for(auto& e : edges){
            adj[e[0]].push_back(e[1]) ;
            adj[e[1]].push_back(e[0]) ;
        }       
        function<int(int,int)> dfs = [&](int u,int fa){
            int res = 0 ; bool ok = false ;
            for(auto v : adj[u]){
                if(v == fa) continue ;
                int tp = dfs(v , u) ; 
                if(tp) ok = true ;
                res += tp ;
            }   
            if(hasApple[u] || ok) res += 2 ;
            return res ;
        } ;    
        int t = dfs(0 , -1) ;  
        return t == 0 ? 0 : t - 2 ;
    }           
};
```

​			

# 网络流

## 方格取数（LG P2774）

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 101*101;
const int M = 1e6+1;
const int inf = 1e18;
int d[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};
int h[N+110],tot=1,n,m,S,T,a[101][101],all,de[N+110],cur[N+110];
struct edge{
    int to,w,ne;
} e[M];
void add(int u,int v,int w){
    e[++tot] = {v,w,h[u]};
    h[u] = tot;
}
bool bfs(){
    memset(de,0,sizeof(de));
    queue<int> Q;
    Q.push(S); de[S] = 1;
    while(!Q.empty()) {
        int u = Q.front(); Q.pop();
        for(int i=h[u];i;i=e[i].ne){
            int v = e[i].to ;
            int c = e[i].w ;
            if(!de[v] && c) {
                Q.push(v);
                de[v] = de[u] + 1;
                if(v == T) return true;
            }
        }
    }
    return false;
}
int dfs(int u,int mf){
    if(u==T) return mf;
    int sum = 0;
    for(int i=cur[u];i;i=e[i].ne){
        int v = e[i].to;
        cur[u] = i;
        if(de[v] == de[u] + 1 && e[i].w) {
            int f = dfs(v,min(mf,e[i].w));
            e[i].w -= f;
            e[i^1].w += f;
            sum += f;
            mf -= f;
            if(mf == 0) break;
        }
    }
    if(sum == 0) de[u] = 0;
    return sum;
}
int dinic(){
    int flow = 0;
    while(bfs()){
        memcpy(cur,h,sizeof(h));
        flow += dfs(S,inf);
    }
    return flow;
}
bool isVis(int i,int j){
    if(i<=m && i>=1 && j<=n && j>=1) return true;
    return false;
}
signed main(){
    cin >> m >> n ;
    S = n*m+1 ; T = n*m+2 ;
    for(int i=1;i<=m;++i) for(int j=1;j<=n;++j) cin >> a[i][j],all += a[i][j] ;
    // 建图，和为奇数连汇点
    for(int i=1;i<=m;++i)
        for(int j=1;j<=n;++j){
            int u = (i-1) * n + j;
            if((i+j) % 2 == 1) add(u,T,a[i][j]),add(T,u,0);
            else {
                add(S,u,a[i][j]), add(u,S,0);
                for(int k=0;k<4;++k){
                    if(isVis(i+d[k][0],j+d[k][1])) {
                        int v = (i+d[k][0]-1) * n + j+d[k][1];
                        add(u,v,inf);
                        add(v,u,0) ;
                    }
                }
            }
        }
    cout << all - dinic() << endl ;
    system("pause");
    return 0;
}
```

## 胜利者集合（PTA）

![cz6wq1rk](初学上课笔记.assets\cz6wq1rk.png)

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e4+1,M=1e5+1,inf=1e18;
struct edge{
    int to,c,nex;
} e[M] ;
int h[N],d[N],cur[N],tot=1;
int n,m,S,T=N-1,w[N],l[N],play[51][51],to_play[51],win[51];
vector<int> ans;
void add(int u,int v,int c){
    e[++tot] = {v,c,h[u]};h[u] = tot;
    e[++tot] = {u,0,h[v]};h[v] = tot;
}
bool bfs(){
    memset(d,0,sizeof(d));
    queue<int> q;
    q.push(S);d[S] = 1;
    while(q.size()){
        int u = q.front();q.pop();
        for(int i=h[u];i;i=e[i].nex){
            int v = e[i].to;
            int c = e[i].c;
            if(!d[v] && c) {
                q.push(v);
                d[v] = d[u] + 1;
                if(v==T) return true;
            }
        }
    }
    return false;
}
int dfs(int u,int mf){
    if(u==T) return mf;
    int sum = 0;
    for(int i=cur[u];i;i=e[i].nex){
        int v = e[i].to,c = e[i].c ; cur[u] = i;
        if(d[v] == d[u] + 1 && c) {
            int f = dfs(v,min(mf,c));
            e[i].c -= f; e[i^1].c += f;
            sum += f; mf -= f;
            if(mf == 0) break;
        }
    }
    if(sum == 0) d[u] = 0;
    return sum;
}
int dinic(){
    int flow=0;
    while(bfs()){
        memcpy(cur,h,sizeof(h));
        flow += dfs(S,inf);
    }
    return flow;
}
void init(){
    tot = 1; 
    memset(h,0,sizeof(h));
    memset(e,0,sizeof(e));
}
signed main(){
    cin >> n >> m ;
    for(int i=1;i<=m;++i) {
        cin >> w[i] >> l[i];
        play[min(w[i],l[i])][max(w[i],l[i])] = 1;
        to_play[w[i]]++;
        to_play[l[i]]++;
        win[w[i]]++;
    }
    for(int i=1;i<=n;++i) to_play[i] = n - 1 - to_play[i];
    for(int i=1;i<=n;++i){
        // 建图
        init();
        for(int g=1;g<=n;++g){
            for(int k=g+1;k<=n;++k){
                if(!play[g][k]){
                    int u = g*51+k;
                    add(S,u,1);
                    if(g==i) {
                        add(u,g,1);
                    }else if(k==i) {
                        add(u,k,1);
                    } else{
                        add(u,g,1);
                        add(u,k,1);
                    }
                }
            }
        }
        int w_in = win[i]+to_play[i];
        int tag = false;
        for(int g=1;g<=n;++g){
            if(g==i){
                add(g,T,to_play[g]);
            }else{
                if(w_in - win[g] - 1 < 0) {tag = true;break;}
                add(g,T,w_in - win[g] - 1);
            }
        }
        if(tag) continue;
        if(dinic() == n*(n-1)/2 - m) ans.push_back(i);
    }
    for(int i=0;i<ans.size();++i){
        if(i!=ans.size()-1) cout << ans[i] << " ";
        else cout << ans[i] << endl ;
    }
    system("pause");
}
```

## 支线剧情

**题目：[P4043 [AHOI2014/JSOI2014\]支线剧情 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4043)**

```c++
#include <bits/stdc++.h>
#define debug cout << "__LINE__ : " << __LINE__ << endl ;
using namespace std ;
#define int long long

const int inf = 1e9 ;
const int N = 510 , M = 510 * 32 ;
using ll = long long ;

int h[N] , tot = 1 ;
struct qwq{int to,w,c,ne;}adj[M] ;
void add(int u,int v,int c,int w){
    adj[++tot] = {v,w,c,h[u]} ; h[u] = tot ;
    adj[++tot] = {u,-w,0,h[v]} ; h[v] = tot ;
}

int dis[N] , mf[N] , pre[N] , vis[N] ;
bool spfa(int s,int t){
    memset(dis,0x3f,sizeof(dis)) ; dis[s] = 0 ;  
    memset(mf,0,sizeof(mf)) ; 
    queue<int> q ; q.push(s) ; vis[s] = 1 ; mf[s] = inf ;
    while(q.size()){
        int u = q.front() ; q.pop() ; vis[u] = 0 ;
        for(int i=h[u];i;i=adj[i].ne){
            int v = adj[i].to , w = adj[i].w , c = adj[i].c ;
            if(c && dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w ;
                mf[v] = min(mf[u] , c) ; pre[v] = i ;
                if(!vis[v]) q.push(v) , vis[v] = 1 ;
            } 
        }
    }
    return mf[t] > 0 ;
}

ll EK(int s,int t){
    ll minCost = 0 ;
    while(spfa(s,t)){
        int v = t ; 
        while(v != s){
            int i = pre[v] ;
            adj[i].c -= mf[t] ;
            adj[i^1].c += mf[t] ;
            v = adj[i^1].to ;
        }
        minCost += dis[t] * mf[t] ;
    }
    return minCost ;
}

void solve(){
    int n ; cin >> n ;  ll ans = 0 ;
    
    vector<int> d(n + 4) ;

    int S = 1 , T = n + 1 , SS = n + 2 , TT = n + 3  ;

    for(int i=1;i<=n;++i)
    {
        int k ; cin >> k ;
        for(int j=1;j<=k;++j)
        {
            int v , w ; cin >> v >> w ;
            ++d[v];--d[i];
            ans += w;
            add(i,v,inf,w);
        }
    }
    for(int i=2;i<=n;++i)
        add(i,T,inf,0);
    add(T,S,inf,0);
    for(int i=1;i<=n+1;++i)
    {
        if(d[i]>0) add(SS,i,d[i],0);
        if(d[i]<0) add(i,TT,-d[i],0);
    }

    cout << ans + EK(SS,TT) << endl ;

}

signed main(){
    ios::sync_with_stdio(false) ; cin.tie(nullptr) ; cout.tie(nullptr) ;

    int t = 1 ;  // cin >> t ;

    while(t -- ){
        solve() ;
    }
    return 0 ;
}
```

## 八十人环游世界

**题目：[P4553 80人环游世界 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4553)**

```c++
#include <bits/stdc++.h>
#define debug cout << "__LINE__ : " << __LINE__ << endl ;
using namespace std ;
#define int long long

const int inf = 101 ;
const int N = 1e3+1 , M = 1e5+1 ;
using ll = long long ;

int h[N] , tot = 1 ; int id1[N] , id2[N] ;
struct qwq{int to,w,c,ne;}adj[M] ;
void add(int u,int v,int c,int w){
    adj[++tot] = {v,w,c,h[u]} ; h[u] = tot ;
    adj[++tot] = {u,-w,0,h[v]} ; h[v] = tot ;
}

int dis[N] , mf[N] , pre[N] , vis[N] ;
bool spfa(int s,int t){
    memset(dis,0x3f,sizeof(dis)) ; dis[s] = 0 ;  
    memset(mf,0,sizeof(mf)) ; 
    queue<int> q ; q.push(s) ; vis[s] = 1 ; mf[s] = inf ;
    while(q.size()){
        int u = q.front() ; q.pop() ; vis[u] = 0 ;
        for(int i=h[u];i;i=adj[i].ne){
            int v = adj[i].to , w = adj[i].w , c = adj[i].c ;
            if(c && dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w ;
                mf[v] = min(mf[u] , c) ; pre[v] = i ;
                if(!vis[v]) q.push(v) , vis[v] = 1 ;
            } 
        }
    }
    return mf[t] > 0 ;
}

ll EK(int s,int t){
    ll minCost = 0 ; int tp = 0 ;
    while(spfa(s,t)){
        int v = t ; 
        while(v != s){
            int i = pre[v] ;
            adj[i].c -= mf[t] ;
            adj[i^1].c += mf[t] ;
            v = adj[i^1].to ;
        }
        tp += mf[t] ;
        minCost += dis[t] * mf[t] ;
    }
    //cout << tp << endl ;
    return minCost ;
}

void solve(){
    int n , m ; cin >> n >> m ;

    int S = 2*n + 1 , T = 2*n + 2 ; 
    int X = 2*n + 3 , SS = 2*n + 4 , TT = 2*n + 5 ;

    add(S,X,m,0) ; add(T,S,inf,0) ;
    for (int i = 1; i <= n; ++i)
    {
        int v ; cin >> v ;
        id1[i] = 2*i - 1 ; id2[i] = 2*i ;
        add(id1[i],id2[i],0,0) ;
        add(id1[i],TT,v,0) ; add(SS,id2[i],v,0) ;
        add(X,id1[i],inf,0) ;
        add(id2[i],T,inf,0) ;
    }

    for (int i = 1; i < n; ++i)
    {
        for (int j = 1; j <= n - i; ++j)
        {
            int w ; cin >> w ; if(w == -1) continue ;
            add(id2[i],id1[j+i],inf,w) ;
        }
    }

    cout << EK(SS,TT) << endl ;

}

signed main(){
    ios::sync_with_stdio(false) ; cin.tie(nullptr) ; cout.tie(nullptr) ;

    int t = 1 ;  // cin >> t ;

    while(t -- ){
        solve() ;
    }

    system("pause") ;
    return 0 ;
}
```

## 最大获利

**题目：[P4174 [NOI2006\] 最大获利 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4174)**

```c++
#include <bits/stdc++.h>
#define debug cout << "__LINE__ : " << __LINE__ << endl ;
using namespace std ;

const int inf = 1e9 ;
const int N = 1e5+1 , M = 2e6+1 ;
using ll = long long ;

int h[N] , tot = 1 ; 
struct edge{int to,c,ne;} e[M] ;
void add(int u,int v,int c){
    e[++tot] = {v,c,h[u]} ; h[u] = tot ;
    e[++tot] = {u,0,h[v]} ; h[v] = tot ;
}
int dis[N] ;
bool bfs(int s,int t){
    memset(dis,0,sizeof(dis)) ;
    queue<int> q ; q.push(s) ; dis[s] = 1 ;
    while(q.size()){
        int u = q.front() ; q.pop() ;
        for(int i=h[u];i;i=e[i].ne){
            int v = e[i].to , c = e[i].c ;
            if(!dis[v] && c){
                q.push(v) ; dis[v] = dis[u] + 1 ;
                if(v == t) return true ;
            }
        }
    }
    return false ;
}
ll dfs(int u,int t,int mf){
    if(u == t) return mf ;
    ll sum = 0;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to , c = e[i].c ;
        if(dis[v] == dis[u] + 1 && c){
            ll f = dfs(v,t,min(mf,c)) ;
            e[i].c -= f ; e[i^1].c += f ; sum += f ; mf -= f ;
            if(mf == 0) break ; 
        }
    }
    if(sum == 0) dis[u] = 0;
    return sum ;
}
ll dinic(int s,int t){
    ll flow = 0;
    while(bfs(s,t)){
        flow += dfs(s,t,inf) ;
    }
    return flow ;
}

void solve(){
    int n , m ; cin >> n >> m ; ll ans = 0 ;

    int S = 0 , T = n + m + 1 ; 

    for (int i = 1; i <= n; ++i)
    {
        int p ; cin >> p ;
        add(i , T , p) ;
    }

    for (int i = 1; i <= m; ++i)
    {
        int a , b , c ; cin >> a >> b >> c ;
        ans += c ; add(S,i+n,c) ; 
        add(i+n,a,inf) ; add(i+n,b,inf) ; 
    }

    cout << ans - dinic(S,T) << endl ;
}

signed main(){
    ios::sync_with_stdio(false) ; cin.tie(nullptr) ; cout.tie(nullptr) ;

    int t = 1 ;  // cin >> t ;

    while(t -- ){
        solve() ;
    }
    return 0 ;
}
```

## 修车

**题目：[P2053 [SCOI2007\] 修车 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2053)**

```c++
#include <bits/stdc++.h>
#define debug cout << "__LINE__ : " << __LINE__ << endl ;
using namespace std ;

const int inf = 1e9 ;
const int N = 1e5+1 , M = 2e6+1 ;
using ll = long long ;

int h[N] , tot = 1 ;
struct qwq{int to,w,c,ne;}adj[M] ;
void add(int u,int v,int c,int w){
    adj[++tot] = {v,w,c,h[u]} ; h[u] = tot ;
    adj[++tot] = {u,-w,0,h[v]} ; h[v] = tot ;
}

int dis[N] , mf[N] , pre[N] , vis[N] ;
bool spfa(int s,int t){
    memset(dis,0x3f,sizeof(dis)) ; dis[s] = 0 ;  
    memset(mf,0,sizeof(mf)) ; 
    queue<int> q ; q.push(s) ; vis[s] = 1 ; mf[s] = inf ;
    while(q.size()){
        int u = q.front() ; q.pop() ; vis[u] = 0 ;
        for(int i=h[u];i;i=adj[i].ne){
            int v = adj[i].to , w = adj[i].w , c = adj[i].c ;
            if(c && dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w ;
                mf[v] = min(mf[u] , c) ; pre[v] = i ;
                if(!vis[v]) q.push(v) , vis[v] = 1 ;
            } 
        }
    }
    return mf[t] > 0 ;
}

ll EK(int s,int t){
    ll minCost = 0 ;
    while(spfa(s,t)){
        int v = t ; 
        while(v != s){
            int i = pre[v] ;
            adj[i].c -= mf[t] ;
            adj[i^1].c += mf[t] ;
            v = adj[i^1].to ;
        }
        minCost += dis[t] * mf[t] ;
    }
    return minCost ;
}

int id_cai[41] , id_shi[101][41] ;
void solve(){
    int n , m ; cin >> m >> n ; 

    int idx = 0 ; int S = ++ idx , T = ++ idx ;

    for (int i = 1; i <= n; ++i)
    {
        id_cai[i] = ++ idx ;
        add(S,id_cai[i],1,0) ;
    }

    for (int i = 1; i <= m; ++i)
    {
        for (int j = 1; j <= n; ++j)
        {
            id_shi[i][j] = ++ idx ;
            add(id_shi[i][j],T,1,0) ;
        }
    }

    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= m; ++j)
        {
            int t ; cin >> t ;  
            for(int k = 1; k <= n ; ++ k)
            {
                add(id_cai[i],id_shi[j][k],1,k*t) ;
            }            
        }
    }

    cout << fixed << setprecision(2) <<  (double)EK(S,T) / n << endl ;

}

signed main(){
    ios::sync_with_stdio(false) ; cin.tie(nullptr) ; cout.tie(nullptr) ;

    int t = 1 ;  // cin >> t ;

    while(t -- ){
        solve() ;
    }
    return 0 ;
}
```

## 美食节

**题目：[P2050 [NOI2012\] 美食节 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2050)**

```c++
#include <bits/stdc++.h>
#define debug cout << "__LINE__ : " << __LINE__ << endl ;
using namespace std ;

const int inf = 1e9 ;
const int N = 1e5+1 , M = 1e7+1 ;
using ll = long long ;

int h[N] , tot = 1 ;
struct qwq{int to,w,c,ne;}adj[M] ;
void add(int u,int v,int c,int w){
    adj[++tot] = {v,w,c,h[u]} ; h[u] = tot ;
    adj[++tot] = {u,-w,0,h[v]} ; h[v] = tot ;
}

int dis[N] , mf[N] , pre[N] , vis[N] ;
bool spfa(int s,int t){
    memset(dis,0x3f,sizeof(dis)) ; dis[s] = 0 ;  
    memset(mf,0,sizeof(mf)) ; 
    queue<int> q ; q.push(s) ; vis[s] = 1 ; mf[s] = inf ;
    while(q.size()){
        int u = q.front() ; q.pop() ; vis[u] = 0 ;
        for(int i=h[u];i;i=adj[i].ne){
            int v = adj[i].to , w = adj[i].w , c = adj[i].c ;
            if(c && dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w ;
                mf[v] = min(mf[u] , c) ; pre[v] = i ;
                if(!vis[v]) q.push(v) , vis[v] = 1 ;
            } 
        }
    }
    return mf[t] > 0 ;
}

int idx = 0 ; unordered_map<int,pair<int,int>> mp ;
int id_cai[41] , id_shi[101][801] , tt[41][101] ; 
int n , m ;  int S , T ;

ll EK(int s,int t){
    ll minCost = 0 ;
    // 有可能产生负环
    while(spfa(s,t)){
        int v = t ; 
        while(v != s){
            int i = pre[v] ;
            adj[i].c -= mf[t] ;
            adj[i^1].c += mf[t] ;
            v = adj[i^1].to ;
        }
        minCost += dis[t] * mf[t] ;
        v = adj[pre[t]^1].to ;
        auto it = mp[v] ; 
        id_shi[it.first][it.second+1] = ++ idx ;
        mp[idx] = make_pair(it.first,it.second+1) ;
        add(idx,T,1,0) ;
        for (int i = 1; i <= n; ++i)
        {
            add(id_cai[i],idx,1,(it.second+1)*tt[i][it.first]) ;
        }
    }
    return minCost ;
}

void solve(){
    cin >> n >> m ; ll sum = 0 ;

    S = ++ idx , T = ++ idx ;

    for (int i = 1; i <= n; ++i)
    {
        int p ; cin >> p ; id_cai[i] = ++ idx ;
        add(S,id_cai[i],p,0) ; sum += p ;
    }

    for (int i = 1; i <= m; ++i)
    {
        id_shi[i][1] = ++ idx ; 
        mp[idx] = make_pair(i,1) ;
        add(id_shi[i][1],T,1,0) ;
    }

    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= m; ++j)
        {
            cin >> tt[i][j] ;  
            add(id_cai[i],id_shi[j][1],1,1*tt[i][j]) ;          
        }
    }

    cout << EK(S,T) << endl ;

}

signed main(){
    ios::sync_with_stdio(false) ; cin.tie(nullptr) ; cout.tie(nullptr) ;

    int t = 1 ;  // cin >> t ;

    while(t -- ){
        solve() ;
    }
    return 0 ;
}
```



# 拓扑排序

## 模板

```c++
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;
const int MAXV = 1010;

vector<int> G[MAXV];//邻接表
int n, m, inDegree[MAXV];//顶点数、边数、入度

//拓扑排序
bool topologicalSort() {
	int num = 0;//记录加入拓扑序列的顶点数
	queue<int> q;
	for (int i = 0; i < n; i++) {
		if (inDegree[i] == 0) {
			q.push(i);//将所有入度为0的顶点入队
		}
	}
	while (!q.empty())
	{
		int u = q.front();//取队首顶点u
		//printf("%d", u);//此处可输出顶点u，作为拓扑序列中的顶点
		q.pop();
		for (int i = 0; i < G[u].size(); i++) {
			int v = G[u][i];//u的后继结点v
			inDegree[v]--;//顶点v的入度减1
			if (inDegree[v] == 0) {//顶点v的入度减为0则入队
				q.push(v);
			}
		}
		G[u].clear();//清空顶点u的所有出边（如无必要可不写）
		num++;//加入拓扑序列的顶点加1
	}
	if (num == n) return true;//加入拓扑序列的顶点数为n，说明拓扑排序成功
	else return false;//加入拓扑序列的顶点数小于n，说明拓扑排序失败
}

int main() {
	fill(inDegree, inDegree + MAXV, 0);//初始化
	cin >> n >> m;//输入顶点数和边数
	int x, y;//分别代表出顶点和入顶点
	for (int i = 0; i < m; i++) {
		cin >> x >> y;
		G[x].push_back(y);
		inDegree[y]++;
	}
	cout << topologicalSort() << endl;
    system("pause");
	return 0;
}

```

```c++
void topoSort(){
    queue<int> Q;
    for(int i=1;i<=n;++i){
        if(inDegree[i]==0) Q.push(i);
    }
    while(!Q.empty()){
        int size = Q.size();
        for(int i=0;i<size;++i){
            int u = Q.front();
            Q.pop();
            for(int j=head[u];j!=0;j=edges[j].next){
                int v = edges[j].to;
                inDegree[v]--;
                if(inDegree[v]==0) Q.push(v);
            }
            //cout<<u<<" ";
        }
        //cout<<endl;
    }
}
```



## (hard)并行课程|||（LC 2050）

**题目：[2050. 并行课程 III - 力扣（LeetCode）](https://leetcode.cn/problems/parallel-courses-iii/)**

```c++
class Solution {
public:
    static const int maxN = 5e4+1;
    stack<int> S;
    struct edge{
        int to;
        int next;
    } edges[maxN] ;
    int idx=0;
    int head[maxN];
    void addEdge(int start,int end){
        edges[++idx].to = end;
        edges[idx].next = head[start];
        head[start] = idx;
    }
    bool visited[maxN];
    void DFS(int u){
        if(visited[u]==true) return;
        visited[u] = true;
        for(int i=head[u];i!=0;i=edges[i].next){
            if(visited[edges[i].to]==true) continue;
            DFS(edges[i].to);
        }
        S.push(u);
    }

    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {
        vector<vector<int>> gr(n+1);
        int dp[n+1];
        memset(dp,0,sizeof(dp));
        for(int i=0;i<relations.size();++i){
            addEdge(relations[i][0],relations[i][1]);
            gr[relations[i][1]].push_back(relations[i][0]);
        }
        memset(visited,0,sizeof(visited));
        for(int i=1;i<=n;++i){
            if(visited[i]==true) continue;
            DFS(i);
        }
        while(!S.empty()){
            int u = S.top();
            S.pop();
            if(gr[u].empty())dp[u] = time[u-1];
            else{
                dp[u] = INT_MIN;
                for(int i=0;i<gr[u].size();++i){
                    dp[u] = max(dp[u],dp[gr[u][i]]+time[u-1]);
                }
            }
        }
        return *max_element(dp+1,dp+n+1);
    }
};
```



## 车站分级（LG P 1983）

**题目：[P1983 [NOIP2013 普及组\] 车站分级 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1983)**

```c++
#include <bits/stdc++.h>
using namespace std;
#define maxN ((int)1e4+1)
#define inf 2147483647
int ans;  // 级数
int n,m;
int inDegree[maxN];  // 入度
bool visited[maxN][maxN];
struct edge{
    int to,next;
} edges[maxN*maxN];  // 边
int head[maxN];  // 起点
int idx;
void addEdge(int start,int end){
    edges[++idx].to = end;
    edges[idx].next = head[start];
    head[start] = idx;
}

void read(){
    cin>>n>>m;
    for(int i=0;i<m;++i){
        int s;
        cin>>s;
        int tempArr[s];
        for(int j=0;j<s;++j){
            cin>>tempArr[j];
        }
        int tempIdx=0;
        for(int j=tempArr[0];j<=tempArr[s-1];++j){
            if(j==tempArr[tempIdx]){
                tempIdx++;
            }else{
                for(int k=0;k<s;++k){
                    if(visited[j][tempArr[k]]==false){
                        addEdge(j,tempArr[k]);
                        inDegree[tempArr[k]]++;
                        visited[j][tempArr[k]] = true;
                    }    
                }
            }
        }
    }

}
void topoSort(){
    queue<int> Q;
    for(int i=1;i<=n;++i){
        if(inDegree[i]==0) Q.push(i);
    }
    while(!Q.empty()){
        int size = Q.size();
        for(int i=0;i<size;++i){
            int u = Q.front();
            Q.pop();
            for(int j=head[u];j!=0;j=edges[j].next){
                int v = edges[j].to;
                inDegree[v]--;
                if(inDegree[v]==0) Q.push(v);
            }
            //cout<<u<<" ";
        }
        //cout<<endl;
        ans++;
    }
}

int main(){
    read();
    topoSort();
    cout<<ans<<endl;
    system("pause");
    return 0;
}
```

## 神经网络（LG P1038）

**题目：[P1038 [NOIP2003 提高组\] 神经网络 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1038)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e5 + 10 , M = 2e6 + 10 ;
int n , m ; int c[N] , U[N] ; int ind[N] , oud[N] ;
int h[N] , tot ; struct node{int to,w,ne;}e[M] ; void add(int u,int v,int w){e[++tot]={v,w,h[u]};h[u]=tot;}
void topo(){
    queue<int> q ;
    for(int i=1;i<=n;++i) {
        if(!ind[i]) q.push(i) ; 
        else c[i] -= U[i] ;
    }
    while(q.size()) {
        int u = q.front() ; q.pop() ;
        for(int i=h[u];i;i=e[i].ne) {
            int v = e[i].to , w = e[i].w ;
            if(c[u] > 0) c[v] += w * c[u] ;
            if(!--ind[v]) q.push(v) ;
        }
    }
}
int main(){
    cin >> n >> m ; int u , v , w ; 
    for(int i=1;i<=n;++i) cin >> c[i] >> U[i] ;
    for(int i=1;i<=m;++i) cin >> u >> v >> w , add(u,v,w) , ind[v] ++ , oud[u] ++ ;
    topo() ; bool tag = false ; 
    for(int i=1;i<=n;++i) if(!oud[i]) {
        if(c[i] != 0) tag = true ;
        if(c[i] > 0) cout << i << " " << c[i] << endl ;
    }
    if(!tag) cout << "NULL" << endl ;
    system("pause") ;
}
```

## 杂物（LG P1113）

**题目：[P1113 杂务 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1113)**

```c++
#include <bits/stdc++.h>
using namespace std;
#define maxN ((int)1e4+1)
#define inf 2147483647
int n;
int Time[maxN];
vector<vector<int>> pre;
int dp[maxN];
void read(){
    cin>>n;
    pre.resize(n+1,vector<int>());
    for(int i=0;i<n;++i){
        int start;
        int time1;
        cin>>start>>time1;
        Time[start] = time1;
        int temp;
        while(cin>>temp){
            if(temp == 0) break;
            pre[start].push_back(temp);
        }
    }
}
void func(){
    for(int i=1;i<=n;++i){
        if(pre[i].empty()){
            dp[i] = Time[i];
        }else{
            dp[i] = INT_MIN;
            for(int j=0;j<pre[i].size();++j){
                dp[i] = max(dp[i],dp[pre[i][j]]+Time[i]);
            }
        }
    }
}

int main(){
    read();
    func();
    auto Max = *max_element(dp+1,dp+n+1);
    cout<<Max<<endl;
    system("pause");
    return 0;
}
```

## [矩阵转换后的秩](https://leetcode.cn/problems/rank-transform-of-a-matrix/)

```c++
#include <bits/stdc++.h>
#define debug cout << "__LINE__ : " << __LINE__ - 9 << endl ;
using namespace std ;
#define num(x,y) (x*m+y)
#define X(x) (x / m)
#define Y(x) (x % m) 

using ll = long long ;
class Solution {
public:
    int find(int x,vector<int>& fa){return x==fa[x]?x:fa[x]=find(fa[x],fa);}
    vector<vector<int>> matrixRankTransform(vector<vector<int>>& matrix) {
        int n = matrix.size() , m = matrix[0].size() ; 


        vector<int> fa(n*m) ; iota(fa.begin(),fa.end(),0) ;
        for (int i = 0; i < n; ++i) {
            map<int, vector<int>> mp;
            for (int j = 0; j < m; ++j)
                mp[matrix[i][j]].push_back(i * m + j);
            for (auto &[num, vec] : mp) {
                for (int k = 0; k + 1 < vec.size(); ++k)
                    fa[find(vec[k],fa)] =  find(vec[k + 1],fa);
            }
        }
        for (int j = 0; j < m; ++j) {
            map<int, vector<int>> mp;
            for (int i = 0; i < n; ++i)
                mp[matrix[i][j]].emplace_back(i * m + j);
            for (auto &[num, vec] : mp) {
                for (int k = 0; k + 1 < vec.size(); ++k)
                    fa[find(vec[k],fa)] =  find(vec[k + 1],fa);
            }
        }


        vector<int> idx(m) , idy(n) ; vector<int> e[n * m] , indegree(n * m) ;
        for(int i=0;i<n;++i) {
            iota(idx.begin(),idx.end(),0) ;
            sort(idx.begin(),idx.end(),[&](int x,int y){
                return matrix[i][x] < matrix[i][y] ;
            }) ;   
            for(int j=0;j+1<m;++j){
                if(matrix[i][idx[j]] == matrix[i][idx[j+1]]) continue ;
                int now = find(num(i,idx[j+1]),fa) ;
                int pre = find(num(i,idx[j]),fa) ; 
                e[pre].push_back(now) ;
                indegree[now] ++ ; pre = now ;
            }
        }
        for(int j=0;j<m;++j) {
            iota(idy.begin(),idy.end(),0) ;
            sort(idy.begin(),idy.end(),[&](int x,int y){
                return matrix[x][j] < matrix[y][j] ;
            }) ; 
            for(int i=0;i+1<n;++i){
                if(matrix[idy[i]][j] == matrix[idy[i+1]][j]) continue ;
                int now = find(num(idy[i+1],j),fa) ;
                int pre = find(num(idy[i],j),fa) ;
                e[pre].push_back(now) ;
                indegree[now] ++ ; pre = now ;
            }
        }
        

        vector<vector<int>> ans(n , vector<int>(m)) ;
        queue<int> q ; int id = 1 ;
        for(int i=0;i<n*m;++i) if(indegree[i] == 0 && fa[i] == i) {
            q.push(i) ; ans[X(i)][Y(i)] = id ; 
        } 
        while(q.size()){
            int siz = q.size() ; ++ id ;
            for(int i=0;i<siz;++i) {
                int u = q.front() ; q.pop() ;
                for(int j=0;j<e[u].size();++j){
                    int v = e[u][j] ;
                    if( -- indegree[v] == 0) q.push(v) , ans[X(v)][Y(v)] = id ;
                }
            }
        }


        for(int i=0;i<n*m;++i) if(fa[i] != i) {
            ans[X(i)][Y(i)] = ans[X(find(i,fa))][Y(find(i,fa))] ;
        } 


        return ans ;
    }
};
```



# 最小生成树

## 最小生成树（LG P3366）

**题目：[P3366 【模板】最小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3366)**

```c++
// Kruskal
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4+10 , M = 2e5+10 ;
struct edge{int u,v,w;} e[M] ;
int fa[N] , n , m , res , cnt ;
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
int main(){
    cin >> n >> m ; for(int i=1;i<=n;++i) fa[i] = i; cnt = n ;
    for(int i=1;i<=m;++i) cin >> e[i].u >> e[i].v >> e[i].w ;
    sort(e+1,e+1+m,[&](auto& e1,auto& e2){return e1.w < e2.w;});
    for(int i=1;i<=m;++i){
        int u = e[i].u , v = e[i].v , w = e[i].w ;
        int fu = find(u) , fv = find(v) ;
        if(fu == fv) continue ;
        fa[fu] = fv ; cnt--; res += w ;
        if(cnt == 1) break ;
    }
    if(cnt == 1) cout << res << endl ;
    else cout << "orz" << endl ;
    system("pause");
}
```

```c++
// prim
#include <bits/stdc++.h>
using namespace std ;
typedef long long ll ;
const int N = 1e5+10 , M = 1e6+10 , inf = 0x7fffffff ;
int n , m , s = 1 , dis[N] , vis[N] , res ;
int h[N] , tot ;
struct edge{int to,w,ne;} e[M] ;
void add(int u,int v,int w){
    e[++tot] = {v,w,h[u]} ; h[u] = tot ;
}
bool prim(){
    for(int i=0;i<=n;++i) dis[i] = inf ; 
    dis[s] = 0 ; int cnt = 0 ;
    for(int i=1;i<=n;++i){
        int u = 0 ;
        for(int j=1;j<=n;++j){
            if(vis[j]) continue ;
            if(dis[u] > dis[j]) u = j ;
        }
        vis[u] = 1 ; res += dis[u] ;
        if(dis[u]!=inf) cnt++ ;
        for(int j=h[u];j;j=e[j].ne){
            int v = e[j].to , w = e[j].w ;
            if(vis[v]) continue ;
            if(dis[v] > w) dis[v] = w ;
        }
    }
    return cnt==n;
}
int main(){
    cin >> n >> m ; int u , v , w ;
    for(int i=1;i<=m;++i) cin >> u >> v >> w , add(u,v,w) , add(v,u,w);
    if(prim()) cout << res << endl ;
    else cout << "orz" << endl ; 
    system("pause") ;
}
```

## 严格次小生成树（LG P4180）

**题目：[P4180 [BJWC2010\] 严格次小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4180)**

```c++
// 先跑出最小生成树，再跑这棵树的树链剖分
// 再随机加一条边，形成一个环，在这个环查询比这条边小的最大值（线段树维护两个值，最大值和次最大值）
#include <bits/stdc++.h>
#define int long long
using namespace std ;
const int N = 1e5 + 10 , M = 2e6 + 10 , inf = 1e18 ;
int n , m , ans = inf ;
// 树链剖分
vector<int> e[N] ; int w[N] ; // 边权转点权
int fa1[N] , dep[N] , siz[N] , son[N] , top[N] , id[N] , idx , nw[N] ;
void dfs1(int u,int father) {
    fa1[u] = father ; dep[u] = dep[father] + 1 ; siz[u] = 1 ;
    for(int i=0;i<e[u].size();++i) {
        int v = e[u][i] ; 
        if(v == father) continue ;
        dfs1(v,u) ; siz[u] += siz[v] ;
        if(siz[son[u]] < siz[v]) son[u] = v ;
    }
}
void dfs2(int u,int tp) {
    top[u] = tp ; id[u] = ++ idx ; nw[id[u]] = w[u] ;
    if(!son[u]) return ;
    dfs2(son[u],tp) ;
    for(int i=0;i<e[u].size();++i) {
        int v = e[u][i] ;  
        if(v == fa1[u] || v == son[u]) continue ;
        dfs2(v,v) ;
    }
}
// 线段树维护最大值和次最大值
#define lc (p << 1)
#define rc (p << 1 | 1) 
int ma[N << 2] , lma[N << 2] , a[4] ;  // 最大值和次最大值,初始为0 
void up(int p){
    a[0] = ma[lc] ; a[1] = ma[rc] ; a[2] = lma[lc] ; a[3] = lma[rc] ;
    sort(a,a+4,greater<int>()) ;
    ma[p] = a[0] ; int i = 1 ; 
    while(i < 4 && a[i] == a[0]) i ++ ; lma[p] = a[i] ;
}
void build(int p,int l,int r){
    if(l == r) {ma[p] = nw[l] ; return ;}
    int m = l + r >> 1 ; 
    build(lc,l,m) ; build(rc,m+1,r) ;
    up(p) ;
}
int query(int p,int l,int r,int x,int y,int k){
    if(x <= l && y >= r) return ma[p] == k ? lma[p] : ma[p] ;
    int m = l + r >> 1 ; int res = 0 ;
    if(x <= m) res = max(res,query(lc,l,m,x,y,k)) ;
    if(y > m) res = max(res,query(rc,m+1,r,x,y,k)) ;
    return res ;
}
int ask(int u,int v,int k){
    int res = 0 ;
    while(top[u] != top[v]) {
        if(dep[top[u]] < dep[top[v]]) swap(u,v) ;
        res = max(res , query(1,1,n,id[top[u]],id[u],k)) ;
        u = fa1[top[u]] ;
    }
    if(u == v) return res ;
    if(dep[u] < dep[v]) swap(u,v) ;
    res = max(res , query(1,1,n,id[v]+1,id[u],k)) ;
    return res ;
}
// 最小生成树
struct Edge{int x,y,w;} E[M] ; int W ; int fa2[N] ; int ttag[M] ;
int find(int x){return x==fa2[x]?fa2[x]:fa2[x]=find(fa2[x]);}
void kruskal(){
    sort(E+1,E+m+1,[&](auto const& e1, auto const& e2){
        return e1.w < e2.w ;
    }) ; 
    for(int i=1;i<=n;++i) fa2[i] = i ;
    int x , y ; 
    for(int i=1;i<=m;++i) {
        x = find(E[i].x) ; y = find(E[i].y) ;
        if(x == y) continue ;
        fa2[x] = fa2[y] ; W += E[i].w ; ttag[i] = 1 ;
        e[E[i].x].push_back(E[i].y) ; e[E[i].y].push_back(E[i].x) ;
    }
}
// 主函数
signed main(){
    cin >> n >> m ; int x , y ;
    for(int i=1;i<=m;++i) cin >> E[i].x >> E[i].y >> E[i].w ;
    kruskal() ;
    dfs1(1,0) ; 
    for(int i=1;i<=m;++i)if(ttag[i]) w[dep[E[i].x] > dep[E[i].y] ? E[i].x : E[i].y] = E[i].w ;
    dfs2(1,1) ; build(1,1,n) ;
    //for(int i=1;i<=n;++i) cout << w[i] << " " ; cout << endl ;
    for(int i=1;i<=m;++i) if(!ttag[i]) {
        x = E[i].x ; y = E[i].y ;
        int temp = W - ask(x,y,E[i].w) + E[i].w ;
        if(ans > temp && temp != W + E[i].w && temp > W) ans = temp ;                
    }
    cout << ans << endl ;
    system("pause") ;
}

```



## 修建道路（LG P2872）

**题目：[P2872 [USACO07DEC\]Building Roads S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2872)**

**题目描述**

给定 n 个点的坐标，第 i 个点的坐标为 (x_i,y_i)，这 n 个点编号为 1 到 n。给定 m 条边，第 i 条边连接第 u_i 个点和第 v_i 个点。现在要求你添加一些边，并且能使得任意一点都可以连通其他所有点。求添加的边的总长度的最小值。

**输入格式**

第一行两个整数 n,m 代表点数与边数。   
接下来 n 行每行两个整数 x_i,y_i 代表第 i 个点的坐标。   
接下来 m 行每行两个整数 u_i,v_i 代表第 i 条边连接第 u_i 个点和第 v_i 个点。

**输出格式**

一行一个实数代表添加的边的最小长度，要求保留两位小数，为了避免误差， 请用 64 位实型变量进行计算。

**样例 #1**

**样例输入 #1**

```
4 1
1 1
3 1
2 3
4 3
1 4
```

**样例输出 #1**

```
4.00
```

**提示**

**数据规模与约定**

**代码实现：**精度控制

```c++
#include <bits/stdc++.h>
using namespace std;

class UF{
private:
    int* eleGroup;  // 元素的节点标识符
    int _count;  // 元素分组的个数
    int* _size;  // 每个树的大小  
    int _maxN;  //  数组的最大值 
public:
    UF(int N){  // 初始化N个分组和其父节点下标
        _maxN = N;
        _count = _maxN;
        eleGroup = new int[_maxN];
        _size = new int[_maxN];
        for(int i=0;i<_maxN;++i){
            eleGroup[i] = i;
            _size[i]=1;
        }
    }
    ~UF(){  // 析构函数
        if(eleGroup != NULL){
            delete[] eleGroup;
            eleGroup = NULL;
        }
        if(_size != NULL){
            delete[] _size;
            _size = NULL;
        }
    }
    int count(){  // 返回分组的个数
        return this->_count;
    }
    bool connected(int p,int q){  // 查询p和q是否在同一个分组
        return find(p) == find(q);
    }
    int find(int p){  // 查询p的分组的父节点下标,保证p不超过数组长度
        if(p >= _maxN) return -1;
        while(true){
            if(p==eleGroup[p]) return eleGroup[p];
            p = eleGroup[p];
        }
    }
    void Union(int p,int q){  // 合并p和q所在的分组，保证p和q不超过数组长度
        int pRoot = find(p);
        int qRoot = find(q);
        if(pRoot == -1 || qRoot == -1 || pRoot==qRoot)  return;
        if(_size[qRoot] > _size[pRoot]){
            eleGroup[pRoot] = eleGroup[qRoot];
            _size[qRoot] += _size[pRoot];
        }else{
            eleGroup[qRoot] = eleGroup[pRoot];
            _size[pRoot] += _size[qRoot];
        }
        this->_count--;
    }
    void clear(){
        _count = _maxN;
        eleGroup = new int[_maxN];
        _size = new int[_maxN];
        for(int i=0;i<_maxN;++i){
            eleGroup[i] = i;
            _size[i]=1;
        }
    }
};

typedef struct {
    int start;
    int end;
    double weight;
} edge ;
typedef struct {
    int x;
    int y;
} vex ;
double distance(vex& v1,vex& v2){    //  长记性  控制精度的问题
    return (double)sqrt((double)(v1.x-v2.x)*(v1.x-v2.x)+(double)(v1.y-v2.y)*(v1.y-v2.y));
}

#define maxN 1001

int n,m;
vex vexs[maxN];
edge edges[maxN*maxN];


int main()
{   
    double res=0;
    cin>>n>>m;
    UF uf(n);
    for(int i=1;i<=n;++i){
        cin>>vexs[i].x>>vexs[i].y;
    }  
    for(int i=1;i<=m;++i){
        int temp1,temp2;
        cin>>temp1>>temp2;
        uf.Union(temp1-1,temp2-1);
    }        
    int idx=0;
    for(int i=1;i<=n;++i){
        for(int j=i+1;j<=n;++j){
            edges[idx++] = {i,j,distance(vexs[i],vexs[j])};
        }
    }
    sort(edges,edges+idx,[](edge& e1,edge& e2){return e1.weight<e2.weight;});
    for(int i=0;i<idx;++i){
        if(uf.connected(edges[i].start-1,edges[i].end-1)) continue;
        uf.Union(edges[i].start-1,edges[i].end-1);
        res += edges[i].weight;
    }
    cout<<fixed<<setprecision(2)<<res<<endl;
    system("pause");
    return 0;
}
```



## 无线通讯网（LG P1991）

**题目：[P1991 无线通讯网 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1991)**

**题目描述**

国防部计划用无线网络连接若干个边防哨所。2 种不同的通讯技术用来搭建无线网络；

每个边防哨所都要配备无线电收发器；有一些哨所还可以增配卫星电话。

任意两个配备了一条卫星电话线路的哨所（两边都ᤕ有卫星电话）均可以通话，无论他们相距多远。而只通过无线电收发器通话的哨所之间的距离不能超过 D，这是受收发器的功率限制。收发器的功率越高，通话距离 D 会更远，但同时价格也会更贵。

收发器需要统一购买和安装，所以全部哨所只能选择安装一种型号的收发器。换句话说，每一对哨所之间的通话距离都是同一个 D。你的任务是确定收发器必须的最小通话距离 D，使得每一对哨所之间至少有一条通话路径（直接的或者间接的）。

**输入格式**

从 wireless.in 中输入数据第 1 行，2 个整数 S 和 P，S 表示可安装的卫星电话的哨所数，P 表示边防哨所的数量。接下里 P 行，每行两个整数 x，y 描述一个哨所的平面坐标 (x, y)，以 km 为单位。

**输出格式**

输出 wireless.out 中

第 1 行，1 个实数 D，表示无线电收发器的最小传输距离，精确到小数点后两位。

**样例 #1**

**样例输入 #1**

```
2 4
0 100
0 300
0 600
150 750
```

**样例输出 #1**

```
212.13
```

**提示**

对于 20% 的数据：P = 2，S = 1

对于另外 20% 的数据：P = 4，S = 2

对于 100% 的数据保证：1 ≤ S ≤ 100，S < P ≤ 500，0 ≤ x,y ≤ 10000。

**【题目分析】**

卫星电话可以当做免费的
p个哨所需要p-1条边连接起来
而s个卫星电话可以免去s-1条边
所以就只剩下了p-s条边需要找
找最小的
所以最小生成树就很显然了

**代码实现：**

```c++
#include <bits/stdc++.h>
using namespace std;
class UF{
private:
    int* eleGroup;  // 元素的节点标识符
    int _count;  // 元素分组的个数
    int* _size;  // 每个树的大小  
    int _maxN;  //  数组的最大值 
public:
    UF(int N){  // 初始化N个分组和其父节点下标
        _maxN = N;
        _count = _maxN;
        eleGroup = new int[_maxN];
        _size = new int[_maxN];
        for(int i=0;i<_maxN;++i){
            eleGroup[i] = i;
            _size[i]=1;
        }
    }
    ~UF(){  // 析构函数
        if(eleGroup != NULL){
            delete[] eleGroup;
            eleGroup = NULL;
        }
        if(_size != NULL){
            delete[] _size;
            _size = NULL;
        }
    }
    int count(){  // 返回分组的个数
        return this->_count;
    }
    bool connected(int p,int q){  // 查询p和q是否在同一个分组
        return find(p) == find(q);
    }
    int find(int p){  // 查询p的分组的父节点下标,保证p不超过数组长度
        if(p >= _maxN) return -1;
        while(true){
            if(p==eleGroup[p]) return eleGroup[p];
            p = eleGroup[p];
        }
    }
    void Union(int p,int q){  // 合并p和q所在的分组，保证p和q不超过数组长度
        int pRoot = find(p);
        int qRoot = find(q);
        if(pRoot == -1 || qRoot == -1 || pRoot==qRoot)  return;
        if(_size[qRoot] > _size[pRoot]){
            eleGroup[pRoot] = eleGroup[qRoot];
            _size[qRoot] += _size[pRoot];
        }else{
            eleGroup[qRoot] = eleGroup[pRoot];
            _size[pRoot] += _size[qRoot];
        }
        this->_count--;
    }
    void clear(){
        _count = _maxN;
        eleGroup = new int[_maxN];
        _size = new int[_maxN];
        for(int i=0;i<_maxN;++i){
            eleGroup[i] = i;
            _size[i]=1;
        }
    }
};
typedef struct {
    int start;
    int end;
    double weight;
} edge ;
typedef struct {
    int x;
    int y;
} vex ;
double distance(vex& v1,vex& v2){
    return (double)sqrt((double)(v1.x-v2.x)*(v1.x-v2.x)+(double)(v1.y-v2.y)*(v1.y-v2.y));
}
#define maxP 502
int S,P;
vex vexs[maxP];
edge edges[maxP*maxP];
int main()
{   
    cin>>S>>P;
    UF uf(P);
    vector<edge> path; 
    for(int i=1;i<=P;++i){
        cin>>vexs[i].x>>vexs[i].y;
    }       
    int idx=0;
    for(int i=1;i<=P;++i){
        for(int j=i+1;j<=P;++j){
            edges[idx++] = {i,j,distance(vexs[i],vexs[j])};
        }
    }
    sort(edges,edges+idx,[](edge& e1,edge& e2){return e1.weight<e2.weight;});
    for(int i=0;i<idx;++i){
        if(uf.connected(edges[i].start-1,edges[i].end-1)) continue;
        uf.Union(edges[i].start-1,edges[i].end-1);
        path.push_back(edges[i]);
    }
    cout<<fixed<<setprecision(2)<<path[path.size()-1-S+1].weight<<endl;
    system("pause");
    return 0;
}
```





## 营救（LG P1396）

**题目：[P1396 营救 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1396)**

**题目背景**

“咚咚咚……”“查水表！”原来是查水表来了，现在哪里找这么热心上门的查表员啊！小明感动得热泪盈眶，开起了门……

**题目描述**

妈妈下班回家，街坊邻居说小明被一群陌生人强行押上了警车！妈妈丰富的经验告诉她小明被带到了 t 区，而自己在 s 区。

该市有 m 条大道连接 n 个区，一条大道将两个区相连接，每个大道有一个拥挤度。小明的妈妈虽然很着急，但是不愿意拥挤的人潮冲乱了她优雅的步伐。所以请你帮她规划一条从 s 至 t 的路线，使得经过道路的拥挤度最大值最小。

**输入格式**

第一行有四个用空格隔开的 n，m，s，t，其含义见【题目描述】。

接下来 m 行，每行三个整数 u, v, w，表示有一条大道连接区 u 和区 v，且拥挤度为 w。

**两个区之间可能存在多条大道**。

**输出格式**

输出一行一个整数，代表最大的拥挤度。

**样例 #1**

**样例输入 #1**

```
3 3 1 3
1 2 2
2 3 1
1 3 3
```

**样例输出 #1**

```
2
```

**提示**

**数据规模与约定**

- 对于 30% 的数据，保证 n<= 10。
- 对于 60% 的数据，保证 n 100。
- 对于 100% 的数据，保证 1 <= n <= 10^4，1<=m<=2*10^4，w <= 10^4，1 <=s, t<=n。且从 s 出发一定能到达 t 区。

---

**样例输入输出 1 解释**

小明的妈妈要从 1 号点去 3 号点，最优路线为 1->2->3。

**代码实现：**

```C++
#include <bits/stdc++.h>
using namespace std;
class UF{
private:
    int* eleGroup;  // 元素的节点标识符
    int _count;  // 元素分组的个数
    int* _size;  // 每个树的大小  
    int _maxN;  //  数组的最大值 
public:
    UF(int N){  // 初始化N个分组和其父节点下标
        _maxN = N;
        _count = _maxN;
        eleGroup = new int[_maxN];
        _size = new int[_maxN];
        for(int i=0;i<_maxN;++i){
            eleGroup[i] = i;
            _size[i]=1;
        }
    }
    ~UF(){  // 析构函数
        if(eleGroup != NULL){
            delete[] eleGroup;
            eleGroup = NULL;
        }
        if(_size != NULL){
            delete[] _size;
            _size = NULL;
        }
    }
    int count(){  // 返回分组的个数
        return this->_count;
    }
    bool connected(int p,int q){  // 查询p和q是否在同一个分组
        return find(p) == find(q);
    }
    int find(int p){  // 查询p的分组的父节点下标,保证p不超过数组长度
        if(p >= _maxN) return -1;
        while(true){
            if(p==eleGroup[p]) return eleGroup[p];
            p = eleGroup[p];
        }
    }
    void Union(int p,int q){  // 合并p和q所在的分组，保证p和q不超过数组长度
        int pRoot = find(p);
        int qRoot = find(q);
        if(pRoot == -1 || qRoot == -1 || pRoot==qRoot)  return;
        if(_size[qRoot] > _size[pRoot]){
            eleGroup[pRoot] = eleGroup[qRoot];
            _size[qRoot] += _size[pRoot];
        }else{
            eleGroup[qRoot] = eleGroup[pRoot];
            _size[pRoot] += _size[qRoot];
        }
        this->_count--;
    }
    void clear(){
        _count = _maxN;
        eleGroup = new int[_maxN];
        _size = new int[_maxN];
        for(int i=0;i<_maxN;++i){
            eleGroup[i] = i;
            _size[i]=1;
        }
    }
};
typedef struct {
    int start;
    int end;
    double weight;
} edge ;
#define maxM 20001
#define maxN 10001

int n,m,s,t;
edge edges[maxM];

int main()
{   
    cin>>n>>m>>s>>t;
    UF uf(n);
    if(s==t){
        cout<<0<<endl;
        system("pause");
        return 0;
    }
    for(int i=1;i<=m;++i){
        cin>>edges[i].start>>edges[i].end>>edges[i].weight;
    }       
    sort(edges+1,edges+m+1,[](edge& e1,edge& e2){return e1.weight<e2.weight;});
    for(int i=1;i<=m;++i){
        if(uf.connected(edges[i].start-1,edges[i].end-1)) continue;
        uf.Union(edges[i].start-1,edges[i].end-1);
        if(uf.connected(s-1,t-1)){  // 第一次连通就可以了
            cout<<edges[i].weight<<endl;
            system("pause");
            return 0;
        }
    }
    cout<<"不能到达！"<<endl;
    system("pause");
    return 0;
}
```





## 拆地毯（LG P2121）

**题目：[P2121 拆地毯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2121)**

**题目背景**
还记得 NOIP 2011 提高组 Day1 中的铺地毯吗？时光飞逝，光阴荏苒，三年过去了。组织者精心准备的颁奖典礼早已结束，留下的则是被人们踩过的地毯。请你来解决类似于铺地毯的另一个问题。

**题目描述**
会场上有 n 个关键区域，不同的关键区域由 m 条无向地毯彼此连接。每条地毯可由三个整数 u、v、w 表示，其中 u 和 v 为地毯连接的两个关键区域编号，w 为这条地毯的美丽度。

由于颁奖典礼已经结束，铺过的地毯不得不拆除。为了贯彻勤俭节约的原则，组织者被要求只能保留 K 条地毯，且保留的地毯构成的图中，任意可互相到达的两点间只能有一种方式互相到达。换言之，组织者要求新图中不能有环。现在组织者求助你，想请你帮忙算出这 K 条地毯的美丽度之和最大为多少。

**输入格式**
第一行包含三个正整数 n、m、K。

接下来 m 行中每行包含三个正整数 u、v、w。

**输出格式**
只包含一个正整数，表示这 K 条地毯的美丽度之和的最大值。

**输入输出样例**
**输入 #1**

```
5 4 3
1 2 10
1 3 9
2 3 7
4 5 3
```

**输出 #1**

```
22
```

**说明/提示**
选择第 1、2、4 条地毯，美丽度之和为 10 + 9 + 3 = 22。

若选择第 1、2、3 条地毯，虽然美丽度之和可以达到 10 + 9 + 7 = 26，但这将导致关键区域 1、2、3 构成一个环，这是题目中不允许的。

1<=n,m,k<=100000



**代码：**

```c++
#include <bits/stdc++.h>
using namespace std;
class UF{
private:
    int* eleGroup;  // 元素的节点标识符
    int _count;  // 元素分组的个数
    int* _size;  // 每个树的大小  
    int _maxN;  //  数组的最大值 
public:
    UF(int N){  // 初始化N个分组和其父节点下标
        _maxN = N;
        _count = _maxN;
        eleGroup = new int[_maxN];
        _size = new int[_maxN];
        for(int i=0;i<_maxN;++i){
            eleGroup[i] = i;
            _size[i]=1;
        }
    }
    ~UF(){  // 析构函数
        if(eleGroup != NULL){
            delete[] eleGroup;
            eleGroup = NULL;
        }
        if(_size != NULL){
            delete[] _size;
            _size = NULL;
        }
    }
    int count(){  // 返回分组的个数
        return this->_count;
    }
    bool connected(int p,int q){  // 查询p和q是否在同一个分组
        return find(p) == find(q);
    }
    int find(int p){  // 查询p的分组的父节点下标,保证p不超过数组长度
        if(p >= _maxN) return -1;
        while(true){
            if(p==eleGroup[p]) return eleGroup[p];
            p = eleGroup[p];
        }
    }
    void Union(int p,int q){  // 合并p和q所在的分组，保证p和q不超过数组长度
        int pRoot = find(p);
        int qRoot = find(q);
        if(pRoot == -1 || qRoot == -1 || pRoot==qRoot)  return;
        if(_size[qRoot] > _size[pRoot]){
            eleGroup[pRoot] = eleGroup[qRoot];
            _size[qRoot] += _size[pRoot];
        }else{
            eleGroup[qRoot] = eleGroup[pRoot];
            _size[pRoot] += _size[qRoot];
        }
        this->_count--;
    }
    void clear(){
        _count = _maxN;
        eleGroup = new int[_maxN];
        _size = new int[_maxN];
        for(int i=0;i<_maxN;++i){
            eleGroup[i] = i;
            _size[i]=1;
        }
    }
};
typedef struct {
    int start;
    int end;
    double weight;
}edge;

#define maxM 100001

int n,m,k;
edge edges[maxM];

int main()
{   
    int res=0;
    cin>>n>>m>>k;
    UF uf(n);
    for(int i=1;i<=m;++i){
        cin>>edges[i].start>>edges[i].end>>edges[i].weight;
    }
    sort(edges+1,edges+m+1,[](edge& e1,edge& e2){return e1.weight > e2.weight;});
    for(int i=1;i<=m;++i){
        if(uf.connected(edges[i].start-1,edges[i].end-1)) continue;
        uf.Union(edges[i].start-1,edges[i].end-1);
        res += edges[i].weight;
        if(--k == 0) {
            cout<<res<<endl;
            system("pause");
            return 0;
        }
    }
    cout<<"输入数据不符合题意！！"<<endl;
    system("pause");
    return 0;
}
```



## 买礼物（LG P1194）

**题目：[P1194 买礼物 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1194)**

**题目描述**
又到了一年一度的明明生日了，明明想要买BB样东西，巧的是，这BB样东西价格都是AA元。

但是，商店老板说最近有促销活动，也就是：

如果你买了第II样东西，再买第JJ样，那么就可以只花KI,JKI,J元，更巧的是，KI,JKI,J竟然等于KJ,IKJ,I。

现在明明想知道，他最少要花多少钱。

**输入输出格式**
**输入格式：**
第一行两个整数，A,B。

接下来B行，每行B个数，第i行第j个为K[i] [j]。

我们保证 K [i] [j] = K [j] [i]并且 K[i] [i] = 0;

特别的，如果K[i] [j] = 0，那么表示这两样东西之间不会导致优惠。

**输出格式：**
一个整数，为最小要花的钱数。

**输入输出样例**
**输入样例#1**

```
1 1
0
```

**输出样例#1**

```
1
```

**输入样例#2**

```
3 3
0 2 4
2 0 2
4 2 0
```

**输出样例#2**

```
7
```

**说明**
**样例解释2**

先买第22样东西，花费33元，接下来因为优惠，买1,31,3样都只要22元，共77元。

（同时满足多个“优惠”的时候，聪明的明明当然不会选择用44元买剩下那件，而选择用22元。）

**数据规模**

对于30%的数据,1≤B≤10。

对于100%的数据,1≤B≤500,0≤A,K[i] [j]≤1000。



```c++
#include <bits/stdc++.h>
using namespace std;

#define maxB 501

int A,B;
int K[maxB][maxB];
bool visited[maxB];
int minCost[maxB];

int main()
{   
    int res = 0;
    cin>>A>>B;
    for(int i=1;i<=B;++i){
        for(int j=1;j<=B;++j){
            cin>>K[i][j];
            if(K[i][j] != 0) K[i][j] -= A;
        }    
    }
    visited[1] = true;
    for(int i=1;i<=B;++i){
        if(visited[i]==true) continue;
        minCost[i] = K[1][i];
    }
    for(int i=1;i<B;++i){
        int minVal = INT_MAX;
        int minIndex = -1;
        for(int j=1;j<=B;++j){
            if(visited[j]==true) continue;
            if(minVal > minCost[j]){
                minIndex = j;
                minVal = minCost[j];
            }
        }
        visited[minIndex] = true;
        if(minVal < 0)
            res += minVal;
        for(int j=1;j<=B;++j){
            if(visited[j]==true) continue;
            minCost[j] = min(minCost[j],K[minIndex][j]);
        }
    }
    cout<<A*B+res<<endl;
    system("pause");
    return 0;
}
```

## 公路修建（LG P1265）

**题目：[P1265 公路修建 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1265)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 5e4+10 , inf = 1e9 ; 
double ddd(double u,double v,double x,double y){
    return sqrt((u-x)*(u-x)+(v-y)*(v-y)) ;
}
int n ; double ans = 0 ;
struct node{double x,y;int idx;} Node[N] ;
double dis[N] ; int vis[N] ;
struct qwq{
    double priority ;
    node nod ;
    bool operator<(const qwq& e)const{return priority > e.priority;} ;
};
void prim(){
    fill(dis+1,dis+1+n,inf) ; dis[1] = 0 ; qwq u , v ;
    priority_queue<qwq> q ; q.push({dis[1],Node[1]}) ;
    while(q.size()){
        u = q.top() ; q.pop() ;
        if(vis[u.nod.idx]) continue ;
        vis[u.nod.idx] = 1 ; ans += u.priority ;
        for(int i=1;i<=n;++i){
            double dd1 = ddd(u.nod.x,u.nod.y,Node[i].x,Node[i].y) ;
            if(dis[Node[i].idx] > dd1) {
                dis[Node[i].idx] = dd1 ;
                q.push({dd1,Node[i]}) ;
            }
        }
    }
}
int main(){
    cin >> n ; 
    for(int i=1;i<=n;++i) cin >> Node[i].x >> Node[i].y , Node[i].idx = i ; 
    prim() ; 
    cout << fixed << setprecision(2) << ans << endl ;
    system("pause") ;
}
```

## Watering The Fields S （LG P2212）

**题目：[P2212 [USACO14MAR\]Watering the Fields S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2212)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e5 + 10 , inf = 1e9 ;
int n , c , ans ;
struct node1{int x,y,idx;}vex[N] ;
struct node2{
    int dis,x,y,idx;
    bool operator<(const node2& e)const {return dis > e.dis;} 
} ;
int dis[N] , vis[N] ;
void prim(){
    fill(dis+1,dis+1+n,inf) ; memset(vis,0,sizeof(vis)) ; node2 u , v ;
    dis[1] = 0 ; priority_queue<node2> q ; q.push({dis[1],vex[1].x,vex[1].y,1}) ;
    while(q.size()) {
        u = q.top() ; q.pop() ;
        if(vis[u.idx]) continue ;
        vis[u.idx] = 1 ; ans += u.dis ;
        for(int i=1;i<=n;++i) {
            v.dis = (vex[i].x - u.x ) * (vex[i].x - u.x ) + (vex[i].y - u.y) * (vex[i].y - u.y) ;
            if(dis[i] > v.dis && v.dis >= c){
                dis[i] = v.dis ; v.x = vex[i].x ; v.y = vex[i].y ; v.idx = vex[i].idx ;
                q.push(v) ;
            }
        }
    }
}
int main(){
    cin >> n >> c ; 
    for(int i=1;i<=n;++i) cin >> vex[i].x >> vex[i].y , vex[i].idx = i ; 
    prim() ;
    for(int i=1;i<=n;++i) if(!vis[i]) return cout << -1 << endl , 0 ;
    cout << ans << endl ;
    system("pause") ;
}
```



# 最短路径

## （hard）得到带权要求路径的最小带权子图（LC 2203）

**题目：[2203. 得到要求路径的最小带权子图 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-weighted-subgraph-with-the-required-paths/)**

```c++
class Solution {
public:
    #define maxN (int)1e5+1
    #define inf 0x3f3f3f3f3f3f3f3f
    int n;
    long long minPathSrc1[maxN];
    long long minPathSrc2[maxN];
    long long minPathDest[maxN];
    struct edge{
        long long to,next,w;
    }Edges[maxN];
    edge EdgesReverse[maxN];
    long long head[maxN];
    long long headReverse[maxN];
    long long tot;
    void addedge(long long s,long long e,long long w){
        Edges[++tot].to = e;
        Edges[tot].next = head[s];
        Edges[tot].w = w;
        head[s] = tot;
        EdgesReverse[tot].to = s;
        EdgesReverse[tot].next = headReverse[e];
        EdgesReverse[tot].w = w;
        headReverse[e] = tot;
    }
    void Init(int n){
        memset(head,0,sizeof(head));
        memset(headReverse,0,sizeof(headReverse));
        tot = 0;
        this->n = n;
    }
    void Dijkstra(long long u,long long* minPath, edge* Edge,long long* Head){
        bool visited[n];
        priority_queue<pair<long long,long long>,vector<pair<long long, long long> >, greater<pair<long long,long long> > > Q;
        for(long long i=0;i<n;++i)
            minPath[i] = inf;
        memset(visited,0,sizeof(visited));
        minPath[u] = 0;
        Q.push(make_pair(minPath[u],u));
        while(!Q.empty()){
            long long v = Q.top().second;
            Q.pop();
            if(visited[v]==true) continue;
            visited[v] = true;
            for(long long i=Head[v];i!=0;i=Edge[i].next){
                long long to = Edge[i].to;
                if(visited[to]==true) continue;
                if(minPath[to] > minPath[v]+Edge[i].w){
                    minPath[to] = minPath[v]+Edge[i].w;
                    Q.push(make_pair(minPath[to],to));
                }
            }
        }
    }
    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {
        Init(n);
        for(long long i=0;i<edges.size();++i) 
            addedge(edges[i][0],edges[i][1],edges[i][2]);
        long long ans=inf;
        Dijkstra(src1,minPathSrc1,Edges,head);
        Dijkstra(src2,minPathSrc2,Edges,head);
        Dijkstra(dest,minPathDest,EdgesReverse,headReverse);
        for(int i=0;i<n;++i){
            //cout<<minPathSrc1[i]<<"  "<<minPathSrc2[i]<<"  "<<minPathDest[i]<<endl;
            if(minPathSrc1[i]!=inf && minPathSrc2[i]!=inf && minPathDest[i]!=inf)
                ans = min(ans,minPathSrc1[i]+minPathSrc2[i]+minPathDest[i]);
        }
        if(ans==inf) return -1;
        return ans;
    }
};
```

## 直捣黄龙

本题是一部战争大片 —— 你需要从己方大本营出发，一路攻城略地杀到敌方大本营。首先时间就是生命，所以你必须选择合适的路径，以最快的速度占领敌方大本营。当这样的路径不唯一时，要求选择可以沿途解放最多城镇的路径。若这样的路径也不唯一，则选择可以有效杀伤最多敌军的路径。

**输入格式**
输入第一行给出2个正整数N（2 ≤ N ≤ 200，城镇总数）和K（城镇间道路条数），以及己方大本营和敌方大本营的代号。随后N-1行，每行给出除了己方大本营外的一个城镇的代号和驻守的敌军数量，其间以空格分隔。再后面有K行，每行按格式城镇1 城镇2 距离给出两个城镇之间道路的长度。这里设每个城镇（包括双方大本营）的代号是由3个大写英文字母组成的字符串。

**输出格式**
按照题目要求找到最合适的进攻路径（题目保证速度最快、解放最多、杀伤最强的路径是唯一的），并在第一行按照格式己方大本营->城镇1->…->敌方大本营输出。第二行顺序输出最快进攻路径的条数、最短进攻距离、歼敌总数，其间以1个空格分隔，行首尾不得有多余空格。

**输入样例**

```
10 12 PAT DBY
DBY 100
PTA 20
PDS 90
PMS 40
TAP 50
ATP 200
LNN 80
LAO 30
LON 70
PAT PTA 10
PAT PMS 10
PAT ATP 20
PAT LNN 10
LNN LAO 10
LAO LON 10
LON DBY 10
PMS TAP 10
TAP DBY 10
DBY PDS 10
PDS PTA 10
DBY ATP 10



```

**输出样例**

```
PAT->PTA->PDS->DBY
3 30 210
```

**代码实现：**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 2e2+10 , inf = 1e9 ;
int idx=1 , h[N] ; 
struct qwq{int to,w,ne;} e[N*N] ;
void add(int u,int v,int w){
    e[++idx]={v,w,h[u]};h[u]=idx;
    e[++idx]={u,w,h[v]};h[v]=idx;
}
int dis[N] , cnt[N] , enemy[N] , des[N] , num[N] , pre[N] ;  // 最短距离，条数，敌人数量,歼敌总数, 沿途城镇数量,前一节点
int  n , m , S , T ; unordered_map<string,int> mp ; string s[N] ;
struct node{
    int v , dis ;
    bool operator<(const node& x) const {return dis > x.dis ;}
};
void dijkstra(){
    fill(dis+1,dis+1+n,inf) ; dis[S] = 0 ; cnt[S] = 1 ; num[S] = 1 ;
    int vis[N] ; memset(vis,0,sizeof(vis)) ;
    priority_queue<node> q ; q.push({S,dis[S]}) ;
    while(q.size()) {
        int u = q.top().v ; q.pop() ; 
        if(vis[u]) continue ; vis[u] = 1 ;
        for(int i=h[u];i;i=e[i].ne){
            int v = e[i].to , w = e[i].w ;
            if(dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w ;
                cnt[v] = cnt[u];
                num[v] = num[u] + 1 ;
                des[v] = des[u] + enemy[v] ;
                pre[v] = u ;
                q.push({v,dis[v]}) ;
            } else if(dis[v] == dis[u] + w) {
                cnt[v] += cnt[u];
                if(num[v] < num[u] + 1){
                    num[v] = num[u] + 1 ;
                    des[v] = des[u] + enemy[v] ;
                    pre[v] = u ;
                } else if(num[v] == num[u] + 1){
                    if(des[v] < des[u] + enemy[v]) des[v] = des[u] + enemy[v] , pre[v] = u ;
                }
            }
        }
    }
}
int main(){
    string s1 , s2 ; int x ;
    cin >> n >> m >> s1 >> s2 ;
    S = 1 ; mp[s1] = 1 ; s[S] = s1 ; // 起点
    for(int i=2;i<=n;++i) {
        cin >> s1 >> x ; 
        mp[s1] = i ; enemy[i] = x ; s[i] = s1 ;
    } 
    T = mp[s2] ;   // 终点
    for(int i=1;i<=m;++i){
        cin >> s1 >> s2 >> x ;
        add(mp[s1],mp[s2],x) ;
    }
    dijkstra() ; x = T ; stack<int> st ; 
    while(x != S) st.push(x) , x = pre[x] ; st.push(S) ;
    while(st.size()-1) cout << s[st.top()] << "->" , st.pop() ;
    cout << s[st.top()] << endl ; st.pop() ;
    cout << cnt[T] << " " << dis[T] << " " << des[T] << endl ;
    system("pause") ;
}
```

## 大众情人

```c++
#include <bits/stdc++.h>
using namespace std;
#define maxN 501
#define inf 0x3f3f3f3f
int n,dis[maxN][maxN];
double opSex[maxN];
struct edge{
	int end;
	int weight;
	edge* next;
	edge(int _end,int _weight):end(_end),weight(_weight),next(NULL){}
};
struct vex{
	char gender;
	edge* first;
	vex():first(NULL){};
} vexs[maxN];
void addedge(int s,int e,int w){
	edge* temp = vexs[s].first;
	vexs[s].first = new edge(e,w);
	vexs[s].first->next = temp;
}
void read(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		getchar();  // 残留一个换行符，提取掉
		char g;
		int k;
		scanf("%c %d",&g,&k);
		vexs[i].gender = g;
		for(int j=0;j<k;++j){
			int e,w;
			scanf("%d:%d",&e,&w);
			addedge(i,e,w);
		}
	}
}
void Dijkstra(int s){
	priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > Q;
	bool visited[maxN];
	memset(visited,0,sizeof(visited));
	for(int i=1;i<=n;++i) dis[s][i] = inf;
	dis[s][s] = 0;
	Q.push(make_pair(dis[s][s],s));
	while(!Q.empty()){
		int u = Q.top().second;
		Q.pop();
		if(visited[u]==true) continue;
		visited[u] = true;
		for(edge* it=vexs[u].first;it!=NULL;it=it->next){
			int v = it->end;
			if(visited[v]==true) continue;
			if(dis[s][v] > dis[s][u]+it->weight){
				dis[s][v] = dis[s][u] + it->weight;
				Q.push(make_pair(dis[s][v],v));
			}
		} 
	}
}
void all_pair(){
	for(int i=1;i<=n;++i)
		Dijkstra(i);

	// 调试
	cout<<endl<<"dis[][]:  "<<endl;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			cout<<dis[i][j]<<" ";
		}
		cout<<endl;
	}
	cout<<endl;
}
void OpSex(){
	for(int i=1;i<=n;++i){
		opSex[i] = inf;
		for(int j=1;j<=n;++j){
			if(vexs[j].gender == 'M' && vexs[i].gender == 'F')
				opSex[i] = min(opSex[i],(double)1/(double)dis[j][i]);
			else if(vexs[j].gender == 'F' && vexs[i].gender == 'M')
				opSex[i] = min(opSex[i],(double)1/(double)dis[j][i]);
		}
	}
	// 调试
	cout<<"opSex[]: "<<endl;
	for(int i=1;i<=n;++i){
		cout<<vexs[i].gender<<":"<<opSex[i]<<"     ";
	}
	cout<<endl;
}
void ans(){
	double maleMax=-inf,femaleMax=-inf;
	for(int i=1;i<=n;++i){  
		if(vexs[i].gender=='F' && femaleMax < opSex[i]){
			femaleMax = opSex[i];
		}else if(vexs[i].gender=='M' && maleMax < opSex[i]){
			maleMax = opSex[i];
		}
	}
	for(int i=1;i<=n;++i){  
		if(vexs[i].gender=='F' && femaleMax == opSex[i]){
			cout<<i<<" ";
		}
	}
	cout<<endl;
	for(int i=1;i<=n;++i){  
		if(vexs[i].gender=='M' && maleMax == opSex[i]){
			cout<<i<<" ";
		}
	}
}
int main() {

	read();
	all_pair();
	OpSex();
	ans();

	system("pause");
	return 0;
}
/*
6
F 1 4:1
F 2 1:3 4:10
F 2 4:2 2:2
M 2 5:1 3:2
M 2 2:2 6:2
M 2 3:1 2:5
*/
```

## 工程计划（LG P1260）

**题目：[P1260 工程规划 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1260)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e5 +10 , M = 2e6 + 10 , inf = 1e9 ;
int n , m ; int S = 0 ;
int h[N] , tot ; struct node{int to,w,ne;}e[M] ; void add(int u,int v,int w){e[++tot]={v,w,h[u]};h[u]=tot;}
int dis[N] , vis[N] , cnt[N] ;
bool spfa(int s){
    memset(dis,0x3f,sizeof(dis)) ; memset(vis,0,sizeof(vis)) ;
    dis[s] = 0 ; queue<int> q ; q.push(s) ; vis[s] = 1 ;
    while(q.size()) {
        int u = q.front() ; q.pop() ; vis[u] = 0 ;
        for(int i=h[u];i;i=e[i].ne) {
            int v = e[i].to , w = e[i].w ;
            if(dis[v] > dis[u] + w){
                dis[v] = dis[u] + w ; 
                if(!vis[v]) q.push(v) , vis[v] = 1 , cnt[v] ++ ;
                if(cnt[v] == n + 1) return true ;
            }
        }
    }
    return false ;
}
int main(){
    cin >> n >> m ; int u , v , w ;
    for(int i=1;i<=m;++i) cin >> v >> u >> w , add(u,v,w) ;
    for(int i=1;i<=n;++i) add(S,i,0) ;
    if(spfa(S)) cout << "NO SOLUTION" << endl ;
    else {
        int Min = *min_element(dis+1,dis+1+n) ;
        for(int i=1;i<=n;++i) cout << dis[i] - Min << endl ;
    }
    system("pause") ;
}
```

## 糖果（LG P5960）

**题目：[P5960 【模板】差分约束算法 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5960)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e5 +10 , M = 2e6 + 10 , inf = 1e9 ;
int n , m ; int S = 0 ;
int h[N] , tot ; struct node{int to,w,ne;}e[M] ; void add(int u,int v,int w){e[++tot]={v,w,h[u]};h[u]=tot;}
int dis[N] , vis[N] , cnt[N] ;
bool spfa(int s){
    memset(dis,0x3f,sizeof(dis)) ; memset(vis,0,sizeof(vis)) ;
    dis[s] = 0 ; queue<int> q ; q.push(s) ; vis[s] = 1 ;
    while(q.size()) {
        int u = q.front() ; q.pop() ; vis[u] = 0 ;
        for(int i=h[u];i;i=e[i].ne) {
            int v = e[i].to , w = e[i].w ;
            if(dis[v] > dis[u] + w){
                dis[v] = dis[u] + w ; 
                if(!vis[v]) q.push(v) , vis[v] = 1 , cnt[v] ++ ;
                if(cnt[v] == n + 1) return true ;
            }
        }
    }
    return false ;
}
int main(){
    cin >> n >> m ; int u , v , w ;
    for(int i=1;i<=m;++i) cin >> v >> u >> w , add(u,v,w) ;
    for(int i=1;i<=n;++i) add(S,i,0) ;
    if(spfa(S)) cout << "NO" << endl ;
    else {
        for(int i=1;i<=n;++i) cout << dis[i] << " " ; cout << endl ;
    }
    system("pause") ;
}
```

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e5+10 , M = 2e6+10 ;
int n , m , S ; 
int h[N] , tot ; struct node{int to,w,ne;}e[M] ; void add(int u,int v,int w){e[++tot]={v,w,h[u]};h[u]=tot;}
int dis[N] , vis[N] , cnt[N] ;
bool spfa(int u){
    vis[u] = 1 ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to , w = e[i].w ;
        if(dis[v] < dis[u] + w) {
            dis[v] = dis[u] + w ;
            if(vis[v] || spfa(v)){vis[u]=0 ; return true ;}
        }
    }
    vis[u] = 0 ;
    return false ;
}
int main(){
    cin >> n >> m ; int u , v , X ;
    for(int i=1;i<=m;++i) {
        cin >> X >> u >> v ;
        if(X == 1){  // dis[u]==dis[v]  
            add(v,u,0) ; add(u,v,0) ;
        }else if(X == 2){  // dis[u] < dis[v] : dis[v] - dis[u] >= 1
            add(u,v,1) ;
        }else if(X == 3){  // dis[u] >= dis[v] 
            add(v,u,0) ;
        }else if(X == 4){  // dis[u] > dis[v] : dis[u] - dis[v] >= 1
            add(v,u,1) ;
        }else if(X == 5){ // dis[u] <= dis[v] : dis[v] - dis[u] >= 0
            add(u,v,0) ;
        }
    }
    for(int i=1;i<=n;++i) add(S,i,1) ;
    memset(dis,0,sizeof(dis)) ;
    if(spfa(S)) cout << -1 << endl ;
    else {
        int ans = 0 ;
        for(int i=1;i<=n;++i) ans += dis[i] ;
        cout << ans << endl ;
    }
    system("pause") ;
}
```

## 狡猾的商人（LG P2294）

**题目：[P2294 [HNOI2005\]狡猾的商人 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2294)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e5+10 , M = 2e6+10 ;
int n , m , S , T ; 
int h[N] , tot ; struct node{int to,w,ne;}e[M] ; void add(int u,int v,int w){e[++tot]={v,w,h[u]};h[u]=tot;}
int dis[N] , vis[N] ;
bool spfa(int u){
    vis[u] = 1 ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to , w = e[i].w ;
        if(dis[v] > dis[u] + w){
            dis[v] = dis[u] + w ;
            if(vis[v] || spfa(v)){vis[u] = 0 ; return true ;}
        }
    }
    vis[u] = 0 ;
    return false ;
}
int main(){
    cin >> T ; int u , v , w ;
    while(T -- ){
        memset(h,0,sizeof(h)) ; tot = 0 ; 
        memset(dis,0x3f,sizeof(dis)) ;
        cin >> n >> m ; S = n + 1 ;  dis[S] = 0 ;
        for(int i=1;i<=n;++i) add(S,i,0) ;
        while(m -- ){
            cin >> u >> v >> w ;
            add(u-1,v,w) ; add(v,u-1,-w) ;
        }
        if(spfa(S)) cout << "false" << endl ;
        else cout << "true" << endl ;
    }
    
}
```

## 赛车游戏（LG P5590）

**题目：[P5590 赛车游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5590)**

```c++
#include <bits/stdc++.h>
using namespace std ;
const int N = 1e5+10 , M = 2e6+10 ;
int n , m , S , T ; 
/**********正图与反图***********************/
int h[N] , tot , rh[N] , rtot ; 
struct node{int u,to,w,ne;}e[M] , re[M] ; 
void add(int u,int v,int w){
    e[++tot]={u,v,w,h[u]};h[u]=tot;
    re[++rtot]={v,u,w,rh[v]};rh[v]=rtot;
}
/**********新图，约束图***********************/
int neh[N] , netot ; node ne[M] ;
void addne(int u,int v,int w){
    ne[++netot]={u,v,w,neh[u]}; neh[u]=netot ;
}
/**********spfa跑约束图***********************/
int dis[N] , vis[N] ;
bool spfa(int u){
    vis[u] = 1 ;
    for(int i=neh[u];i;i=ne[i].ne){
        int v = ne[i].to , w = ne[i].w ;
        if(dis[v] > dis[u] + w){
            dis[v] = dis[u] + w ;
            if(vis[v] || spfa(v)){vis[u] = 0 ; return true ;}
        }
    }
    vis[u] = 0 ;
    return false ;
}
/**********正向遍历与反向遍历寻找出都经过的点***********************/
int vis1[N] ;
void dfs1(int u){
    vis1[u] = 1 ;
    for(int i=h[u];i;i=e[i].ne){
        int v = e[i].to ;
        if(vis1[v]) continue ;
        dfs1(v) ;
    }
}
int vis2[N] ;
void dfs2(int u){
    vis2[u] = 1 ;
    for(int i=rh[u];i;i=re[i].ne){
        int v = re[i].to ;
        if(vis2[v]) continue ;
        dfs2(v) ;
    }
}
/**********主程序***********************/
int main(){
    cin >> n >> m ; S = 1 ; T = n ; int u , v ;
    for(int i=1;i<=m;++i){
        cin >> u >> v ;
        add(u,v,1) ;
    }
    dfs1(S) ; dfs2(T) ; 
    if(!vis1[S] || !vis2[S] || !vis1[T] || !vis2[T]) {
        cout << -1 << endl ; return 0 ;
    }
    for(int u=1;u<=n;++u) if(vis1[u] && vis2[u]) for(int i=h[u];i;i=e[i].ne) {
        int v = e[i].to , w = e[i].w ;
        if(vis1[v] && vis2[v]) {
            addne(u,v,9) ; addne(v,u,-1) ;
        }
    }
    memset(dis,0x3f,sizeof(vis)) ; dis[S] = 0 ;
    if(spfa(S)) cout << -1 << endl ;
    else {
        cout << n << " " << m << endl ;
        for(int i=1;i<=m;++i) {
            int u = e[i].u , v = e[i].to ;
            if(vis1[u] && vis2[u] && vis1[v] && vis2[v]) cout << u << " " << v << " " << dis[v] - dis[u] << endl ;
            else cout << u << " " << v << " " << 3 << endl ;
        }
    }
    system("pause") ;
}
```

## 从第一个节点出发到最后一个节点的受限路径数

**题目：[1786. 从第一个节点出发到最后一个节点的受限路径数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-restricted-paths-from-first-to-last-node/)**

```c++
class Solution {
public:
    static const int P = 1e9 + 7 ;
    long long mod(long long x){ return (x + P) % P ; }
    struct node{int to,w;};
    struct qwq{
        int v,dis ;
        bool operator<(const qwq& y)const{ return dis > y.dis ; }
    } ;
    int countRestrictedPaths(int n, vector<vector<int>>& edges) {
        vector<node> e[n+1] ;
        for(auto& v : edges){
            e[v[0]].push_back({v[1],v[2]}) ;
            e[v[1]].push_back({v[0],v[2]}) ;
        }

        priority_queue<qwq> q ; vector<int> vis(n + 1) , dis(n + 1) ;
        fill(dis.begin()+1,dis.end(),INT_MAX) ; dis[n] = 0 ; 
        q.push({n,dis[n]}) ;
        while(q.size()){
            int u = q.top().v ; q.pop() ;
            if(vis[u]) continue ; vis[u] = 1 ;
            for(int i=0;i<e[u].size();++i){
                int v = e[u][i].to , w = e[u][i].w ;
                if(dis[v] > dis[u] + w){
                    dis[v] = dis[u] + w ;
                    q.push({v,dis[v]}) ;
                }
            }
        }

        vector<int> id(n + 1) ; iota(id.begin(),id.end(),0) ;
        sort(id.begin()+1,id.end(),[&](int x,int y){
            return dis[x] > dis[y] ;
        }) ;

        vector<long long> cnt(n + 1) ; 
        fill(vis.begin(),vis.end(),0) ; cnt[1] = 1 ; 
        for(int i=1;i<=n;++i){  // 保证无有效性
            int u = id[i] ;
            for(int j=0;j<e[u].size();++j){
                int v = e[u][j].to ;
                if(dis[u] > dis[v]) cnt[v] = mod(cnt[v] + cnt[u]) ;
            }
        }

        return cnt[n] ;
    }
};
```



# 深度搜索优先

## **模板：**

### 四方运动模板

```c++
class Solution {
private:
    vector<vector<int>> grid;
    vector<vector<int>> visited;
    void dfs(int r,int c){
        if(!isArea(r,c)) return;
        if(visited[r][c]==1) return;
        visited[r][c] = 1;
        cout<<grid[r][c]<<" ";
        dfs(r+1,c);  //上
        dfs(r-1,c);  //下
        dfs(r,c-1);  // 左
        dfs(r,c+1);  // 右
    }
    bool isArea(int r,int c){
        if(r>=0 && r<grid.size() && c>=0 && c<grid[r].size())
            return true;
        return false;
    }
public:
    int numIslands(vector<vector<int>>& grid) {
        this->grid = grid;
        this->visited.resize(grid.size(),vector<int>(grid[0].size()));
        dfs(0,0);
        return 0;
    }
};
```



## 百练2815（城堡问题）

**题目：[OpenJudge - 2815:城堡问题](http://bailian.openjudge.cn/practice/2815)**

```c++
#include <bits/stdc++.h>
using namespace std;
#define maxN 100
int R,C;
int rooms[maxN][maxN];
int color[maxN][maxN];
int roomNum=0;
int Area=0;
int maxArea=0;
void dfs(int r,int c){
    if(r>R || r<1 || c>C || c<1 || color[r][c] ) return;  // 如果染过色，就直接返回
    color[r][c] = roomNum;
    Area++;
    if( (rooms[r][c] & 1) == 0 ) dfs(r,c-1); 
    if( (rooms[r][c] & 2) == 0 ) dfs(r-1,c); 
    if( (rooms[r][c] & 4) == 0 ) dfs(r,c+1); 
    if( (rooms[r][c] & 8) == 0 ) dfs(r+1,c); 
}

int main(){
    cin >> R >> C;
    for( int i = 1;i <= R;++i){
        for ( int j = 1;j <= C; ++j){
            cin >> rooms[i][j];
        }     
    } 
    memset(color,0,sizeof(color));
    for(int i=1;i<=R;++i){
        for(int j=1;j<=C;++j){
            if(!color[i][j]){  // 如果没有染色
                Area=0;
                roomNum++;
                dfs(i,j);
                maxArea = max(Area,maxArea);
            }
        }
    }
    cout<<roomNum<<endl;
    cout<<maxArea<<endl;
    system("pause");
    return 0;
}
```



## 岛屿数量（LC 200）

**题目：[200. 岛屿数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-islands/)**

```c++
class Solution {
private:
    vector<vector<char>> matrix;
    int ans=0;
    void dfs(int r,int c){
        if(!isArea(r,c)) return;
        if(matrix[r][c]=='2') return;  // 访问过
        matrix[r][c] = '2';
        dfs(r+1,c);  //上
        dfs(r-1,c);  //下
        dfs(r,c-1);  // 左
        dfs(r,c+1);  // 右
    }
    bool isArea(int r,int c){
        if(r>=0 && r<matrix.size() && c>=0 && c<matrix[r].size()){
            if(matrix[r][c]=='1') return true;
        }
        return false;
    }
public:
    int numIslands(vector<vector<char>>& grid) {
        this->matrix = grid;
        for(int i=0;i<matrix.size();++i){
            for(int j=0;j<matrix[i].size();++j){
                if(matrix[i][j] == '1') {
                    dfs(i,j);
                    ans++;
                }
            }
        }
        return ans;
    }
};
```



## 岛屿周长（LC 463）

**题目：[463. 岛屿的周长 - 力扣（LeetCode）](https://leetcode.cn/problems/island-perimeter/)**

```c++
class Solution {
public:
    int islandPerimeter(vector<vector<int>>& grid) {
        int ans=0;
        function<bool(int,int)> isArea = [&](int r,int c)->bool{
            if(r>=0 && r<grid.size() && c>=0 && c<grid[r].size()){
                if(grid[r][c]==1) return true; 
            } return false;
        };
        function<void(int,int)> dfs = [&](int r,int c)->void{
            if(!isArea(r,c)){
                if(r>=0 && r<grid.size() && c>=0 && c<grid[r].size()){
                    if(grid[r][c]==0) ++ans;
                }   
                else{
                    ++ans;
                }
                return;
            }
            if(grid[r][c]!=1) return;
            grid[r][c] = 2;  // 标记为走过
            dfs(r+1,c);  //上
            dfs(r-1,c);  //下
            dfs(r,c-1);  // 左
            dfs(r,c+1);  // 右
        };
        for(int i=0;i<grid.size();++i){
            for(int j=0;j<grid[i].size();++j){
                if(grid[i][j]==1){
                    dfs(i,j);
                    goto Flag;
                }
            }
        }
        Flag:return ans;
    }
};
```



## 岛屿的最大面积（LC 695）

**题目：[695. 岛屿的最大面积 - 力扣（LeetCode）](https://leetcode.cn/problems/max-area-of-island/)**

```c++
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int ans = 0;
        int area = 0;
        int n = max(grid.size(),grid[0].size());
        unordered_set<int> set;
        function<bool(int,int)> isArea = [&](int r,int c)->bool{
            if(r>=0 && r<grid.size() && c>=0 && c<grid[r].size()){
                if(grid[r][c]==1) return true; 
            } return false;
        };
        function<void(int,int)> dfs = [&](int r,int c)->void{
            if(!isArea(r,c)) return;
            if(set.find(r*n+c+1) != set.end()) return;  //走过了
            ++area;
            set.insert(r*n+c+1);  // 标记走过了
            dfs(r+1,c);  // 上
            dfs(r-1,c);  // 下
            dfs(r,c-1);  // 左
            dfs(r,c+1);  // 右
        };
        for(int i=0;i<grid.size();++i){
            for(int j=0;j<grid[i].size();++j){
                if(grid[i][j]==1){
                    dfs(i,j);
                    set.clear();
                    ans = max(ans,area);
                    area = 0;
                }
            }
        }
        return ans;
    }
};
```



## （hard）最大的人工岛（LC 827）

**题目：[827. 最大人工岛 - 力扣（LeetCode）](https://leetcode.cn/problems/making-a-large-island/)**

**此代码超时，不过方法正确，需要优化**

```c++
class Solution {
public:
    int largestIsland(vector<vector<int>>& grid) {
        int ans = 0;
        int area = 0;
        int n = grid.size();
        unordered_set<int> set;
        function<bool(int,int)> isArea = [&](int r,int c)->bool{
            if(r>=0 && r<grid.size() && c>=0 && c<grid[r].size()){
                if(grid[r][c]==1) return true; 
            } return false;
        };
        function<void(int,int)> dfs = [&](int r,int c)->void{
            if(!isArea(r,c)) return;
            if(set.find(r*n+c+1) != set.end()) return;  //走过了
            ++area;
            set.insert(r*n+c+1);  // 标记走过了
            dfs(r+1,c);  // 上
            dfs(r-1,c);  // 下
            dfs(r,c-1);  // 左
            dfs(r,c+1);  // 右
        };
        for(int i=0;i<grid.size();++i){
            for(int j=0;j<grid[i].size();++j){
                if(grid[i][j]==1){
                    dfs(i,j);
                    set.clear();
                    ans = max(ans,area);
                    area = 0;
                }else{
                    grid[i][j] = 1;
                    dfs(i,j);
                    set.clear();
                    ans = max(ans,area);
                    area = 0;
                    grid[i][j] = 0;
                }
            }
        }
        return ans;
    }
};
```



## 填涂颜色（LG P1162）

**题目：[P1162 填涂颜色 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1162)**

```c++
#include <bits/stdc++.h>
using namespace std;
#define maxN 31
int n;
int matrix[maxN][maxN],visited[maxN][maxN];
void read(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			scanf("%d",&matrix[i][j]);
		}
	}
}
bool isVaild(int x,int y){
	if(x<0 || x>n+1 || y<0 || y>n+1 || matrix[x][y]==1) return false;
	return true;
}
void DFS(int x,int y){
	if(!isVaild(x,y)) return;
	if(visited[x][y]) return;
	visited[x][y] = 1;
	DFS(x-1,y);
	DFS(x+1,y);
	DFS(x,y-1);
	DFS(x,y+1);
}
void ans(){
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			if(visited[i][j]==1 && matrix[i][j]==0){
				printf("0 ");
			}else if(visited[i][j]==0 && matrix[i][j]==1){
				printf("1 ");
			}else printf("2 ");
		}
		printf("\n");
	}
}
int main() {
	read();
	DFS(0,0);
	ans();
	system("pause");
	return 0;
}
/*
6
0 0 0 0 0 0
0 0 1 1 1 0
0 1 1 0 0 1
1 0 0 0 0 1
1 1 1 1 1 0
0 0 0 0 0 0
*/
```



## 八皇后（LG P1219）

**题目：[P1219 [USACO1.5\]八皇后 Checker Challenge - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1219)**

```c++
#include <bits/stdc++.h>
using namespace std;
#define maxN 14
int n;
int visited[maxN][maxN];
vector<vector<int>> ans;
vector<int> path;
void read(){
	scanf("%d",&n);
}
bool isVaild(int x,int y){
	if(x<1 || x>n || y<1 || y>n) return false;
	// 列
	for(int i=1;i<x;++i){
		if(visited[i][y]==1) return false;
	}
	// 45°
	int ty=y;
	for(int i=x-1;i>0;--i){
		if(ty+1 <= n && visited[i][ty+1]==1) return false;
		ty++;
	}
	// 135°
	ty = y;
	for(int i=x-1;i>0;--i){
		if(ty-1 > 0 && visited[i][ty-1]==1) return false;
		ty--;
	}
	return true;
}
void DFS(int x,int y){
	if(!isVaild(x,y)) return;
	if(visited[x][y]) return;
	visited[x][y] = 1;
	path.push_back(y);
	if(path.size()==n){
		ans.push_back(path);
		visited[x][y] = 0;
		path.pop_back();
		return;
	}
	for(int i=1;i<=n;++i){
		DFS(x+1,i);
	}
	visited[x][y] = 0;
	path.pop_back();
}
void ans1(){
	for(int i=0;i<ans.size() && i<3;++i){
		for(int j=0;j<ans[i].size();++j){
			printf("%d ",ans[i][j]);
		}
		printf("\n");
	}
	printf("%d\n",ans.size());
}
int main() {
	read();
	for(int i=1;i<=n;++i){
		DFS(1,i);
	}
	ans1();
	system("pause");
	return 0;
}
/*
13
*/
```



# 广度搜索优先

## 双向BFS

**一定要保证有解，不然效率会退化到2倍的bfs**

**参考：**

[搜索算法——双向bfs_Psycho social的博客-CSDN博客_双向bfs](https://blog.csdn.net/weixin_43501684/article/details/90147421)

[双向 BFS 基本思路（含模板）以及两种「启发式搜索」算法 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/383947524)

「双向 BFS」的基本实现思路如下：

1. 创建「两个队列」分别用于两个方向的搜索；
2. 创建「两个哈希表」用于「解决相同节点重复搜索」和「记录转换次数」；
3. 为了尽可能让两个搜索方向“平均”，每次从队列中取值进行扩展时，先判断哪个队列容量较少；
4. 如果在搜索过程中「搜索到对方搜索过的节点」，说明找到了最短路径。

「双向 BFS」基本思路对应的伪代码大致如下：

```c++
// d1、d2 为两个方向的队列
// m1、m2 为两个方向的哈希表，记录每个节点距离起点的
    
// 只有两个队列都不空，才有必要继续往下搜索
// 如果其中一个队列空了，说明从某个方向搜到底都搜不到该方向的目标节点
while(!d1.isEmpty() && !d2.isEmpty()) {
    if (d1.size() < d2.size()) {
        update(d1, m1, m2);
    } else {
        update(d2, m2, m1);
    }
}

// update 为从队列 d 中取出一个元素进行「一次完整扩展」的逻辑
void update(Deque d, Map cur, Map other) {}
```

## 打开转盘锁(LC 752)

[752. 打开转盘锁 - 力扣（LeetCode）](https://leetcode.cn/problems/open-the-lock/)

## 八数码问题(AcWing 845)

**[845. 八数码 - AcWing题库](https://www.acwing.com/problem/content/description/847/)**

```c++
#include <bits/stdc++.h>
using namespace std;
string s;  // 起始状态和结束状态
const string e = "12345678x";
int cnt=-1;
unordered_set<string> visited;
void find_string(vector<string>& v,string u){
	int i;
	for(i=0;i<u.size();++i){
		if(u[i]=='x') break;
	}
	if(i==0){
		string s = u;swap(s[i],s[3]);
		v.push_back(s);
		swap(s[i],s[3]);swap(s[i],s[1]);
		v.push_back(s);
	}else if(i==1){
		string s = u;swap(s[i],s[4]);
		v.push_back(s);
		swap(s[i],s[4]);swap(s[i],s[0]);
		v.push_back(s);
		swap(s[i],s[0]);swap(s[i],s[2]);
		v.push_back(s);
	}else if(i==2){
		string s = u;swap(s[i],s[1]);
		v.push_back(s);
		swap(s[i],s[1]);swap(s[i],s[5]);
		v.push_back(s);
	}else if(i==3){
		string s = u;swap(s[i],s[0]);
		v.push_back(s);
		swap(s[i],s[0]);swap(s[i],s[6]);
		v.push_back(s);
		swap(s[i],s[6]);swap(s[i],s[4]);
		v.push_back(s);
	}else if(i==4){
		string s = u;swap(s[i],s[1]);
		v.push_back(s);
		swap(s[i],s[1]);swap(s[i],s[3]);
		v.push_back(s);
		swap(s[i],s[3]);swap(s[i],s[5]);
		v.push_back(s);
		swap(s[i],s[5]);swap(s[i],s[7]);
		v.push_back(s);
	}else if(i==5){
		string s = u;swap(s[i],s[2]);
		v.push_back(s);
		swap(s[i],s[2]);swap(s[i],s[4]);
		v.push_back(s);
		swap(s[i],s[4]);swap(s[i],s[8]);
		v.push_back(s);
	}else if(i==6){
		string s = u;swap(s[i],s[3]);
		v.push_back(s);
		swap(s[i],s[3]);swap(s[i],s[7]);
		v.push_back(s);
	}else if(i==7){
		string s = u;swap(s[i],s[4]);
		v.push_back(s);
		swap(s[i],s[4]);swap(s[i],s[6]);
		v.push_back(s);
		swap(s[i],s[6]);swap(s[i],s[8]);
		v.push_back(s);
	}else if(i==8){
		string s = u;swap(s[i],s[5]);
		v.push_back(s);
		swap(s[i],s[5]);swap(s[i],s[7]);
		v.push_back(s);
	}
}
int tag=0;
void bfs(){
	queue<string> Q;
	Q.push(s);
	while(!Q.empty()){
		int size = Q.size();
		cnt++;
		for(int i=0;i<size;++i){
			string u = Q.front();Q.pop();
			visited.insert(u);
			if(u==e) {
				tag=1;break;
			}
			vector<string> v;
			find_string(v,u);
			for(int j=0;j<v.size();++j){
				auto it = visited.find(v[j]);
				if(it==visited.end()) Q.push(v[j]);
			}
		}
		if(tag) break;
	}
}
int main(){
	s.resize(9);
	for(int i=0;i<9;++i){
		cin>>s[i];
	}
	clock_t st,en;
	st = clock();
 	bfs();
	en = clock();
	cout<<en-st<<"ms"<<endl;
	cout<<cnt<<endl;
	system("pause");return 0;
}
```



## 填涂颜色（LG 1162）

**题目：[P1162 填涂颜色 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1162)**

```c++
#include <bits/stdc++.h>
using namespace std;
#define maxN 31
#define mp(x,y) make_pair(x,y)
int n;
int matrix[maxN][maxN],visited[maxN][maxN];
void read(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			scanf("%d",&matrix[i][j]);
		}
	}
}
bool isVaild(int x,int y){
	if(x<0 || x>n+1 || y<0 || y>n+1 || matrix[x][y]==1) return false;
	return true;
}
void BFS(int x,int y){
	queue<pair<int,int>> Q;
	Q.push(mp(0,0));
	while(!Q.empty()){
		int dx = Q.front().first;
		int dy = Q.front().second;
		Q.pop();
		if(!isVaild(dx,dy)) continue;
		if(visited[dx][dy]) continue; 
		visited[dx][dy] = 1;
		Q.push(mp(dx-1,dy));
		Q.push(mp(dx+1,dy));
		Q.push(mp(dx,dy-1));
		Q.push(mp(dx,dy+1));
	}
}
void ans(){
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			if(visited[i][j]==1 && matrix[i][j]==0){
				printf("0 ");
			}else if(visited[i][j]==0 && matrix[i][j]==1){
				printf("1 ");
			}else printf("2 ");
		}
		printf("\n");
	}
}
int main() {
	read();
	BFS(0,0);
	ans();
	system("pause");
	return 0;
}
/*
6
0 0 0 0 0 0
0 0 1 1 1 0
0 1 1 0 0 1
1 0 0 0 0 1
1 1 1 1 1 0
0 0 0 0 0 0
*/
```



# 后缀数组

## 最长重复子串（LC 1044）

**题目：[1044. 最长重复子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-duplicate-substring/)**

```c++
const int N = 3e4+1;
class Solution {
public:
    string s;
    int n ;
    int height[N] , sa[N] , rk[N << 1] , oldrk[N << 1] ; 
    void init(){
        memset(height,0,sizeof(height));
        memset(sa,0,sizeof(sa));
        memset(rk,0,sizeof(rk));
        memset(oldrk,0,sizeof(oldrk));
    }
    void get_sa(){
        for(int i=1;i<=n;++i) sa[i] = i , rk[i] = s[i] ;
        for(int k=1;k<n;k<<=1){
            sort(sa+1,sa+n+1,[&](int x,int y){
                return rk[x]==rk[y] ? rk[x+k]<rk[y+k] : rk[x]<rk[y] ;
            });
            memcpy(oldrk,rk,sizeof(rk)); int p = 0;
            for(int i=1;i<=n;++i){
                if(oldrk[sa[i]]==oldrk[sa[i-1]] && oldrk[sa[i]+k]==oldrk[sa[i-1]+k])
                    rk[sa[i]] = p;
                else rk[sa[i]] = ++p ;
            }
            if(p == n) break;
        }
    }
    void getHeight(){
        int k = 0; 
        for(int i=1;i<=n;++i){
            if(rk[i] == 1) continue;
            if(k) k--;
            int j = sa[rk[i]-1] ;
            while(i+k <=n && j+k <= n && s[i+k]==s[j+k]) k++;
            height[rk[i]] = k;
        }
    }

    string longestDupSubstring(string s) {
        this->n = s.size(); this->s = " " + s;
        init();get_sa();getHeight();
        int max_p =1;
        for(int i=1;i<=n;i++){
            if(height[i]>height[max_p]) max_p = i;
        }
        return s.substr(sa[max_p]-1,height[max_p]);
    }
};
```

## 字符加密（LG P4051）

**题目：[P4051 [JSOI2007\]字符加密 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4051)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5+10;
char s[N] ; int n ;
int sa[N] , rk[N << 1] , oldrk[N << 1] ;
void get_sa(){
    n = strlen(s+1) ;
    for(int i=1;i<=n;++i) rk[i] = s[i] , sa[i] = i ;
    for(int k=1 ; k < n ; k <<= 1) {
        sort(sa+1,sa+n+1,[&](int x,int y){
            return rk[x]==rk[y] ? rk[x+k] < rk[y+k] : rk[x] < rk[y] ;
        });
        memcpy(oldrk,rk,sizeof(rk));
        int p = 0;
        for(int i=1;i<=n;++i){
            if(oldrk[sa[i]]==oldrk[sa[i-1]] && oldrk[sa[i]+k]==oldrk[sa[i-1]+k])
                rk[sa[i]] = p ;
            else rk[sa[i]] = ++p;
        }
        if(p == n) break ;
    }
}

int main(){
    cin >> s+1 ; n = strlen(s+1) ;
    for(int i=1 ; i<= n ; ++i) s[i+n] = s[i] ;
    get_sa() ; 
    for(int i=1;i<=n;++i) if(sa[i] <= n/2) cout << s[sa[i] + n/2 - 1] ;
    system("pause");
}
```

## 不同子串个数（LG P2408）

**题目：[P2408 不同子串个数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2408)**

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6+10;

char s[N] ; int n ;
int height[N] , sa[N] , rk[N << 1] , oldrk[N << 1] ;
void get_sa(){
    for(int i=1;i<=n;++i) sa[i] = i , rk[i] = s[i] ;
    for(int k=1;k<n;k<<=1){
        sort(sa+1,sa+n+1,[&](int x,int y){
            return rk[x]==rk[y] ? rk[x+k]<rk[y+k] : rk[x]<rk[y] ;
        });
        memcpy(oldrk,rk,sizeof(rk)); int p = 0;
        for(int i=1;i<=n;++i){
            if(oldrk[sa[i]]==oldrk[sa[i-1]] && oldrk[sa[i]+k]==oldrk[sa[i-1]+k])
                rk[sa[i]] = p;
            else rk[sa[i]] = ++p ;
        }
        if(p == n) break;
    }
}
void getHeight(){
    int k = 0;
    for(int i=1;i<=n;++i){
        if(rk[i] == 1) continue;
        if(k) k--;
        int j = sa[rk[i]-1] ;
        while(i+k <=n && j+k <= n && s[i+k]==s[j+k]) k++;
        height[rk[i]] = k;
    }
}

signed main(){
    cin >> n ; cin >> s+1 ;
    get_sa(); getHeight();
    int tp = 0 ;
    for(int i=1;i<=n;++i) tp += height[i] ;
    cout << n*(n+1)/2 - tp << endl ;
    system("pause");
}
```

## 构造字典序最大的合并字符串（LC 1754）

**题目：[1754. 构造字典序最大的合并字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-merge-of-two-strings/)**

```c++
class Solution {
public:
    class SA{
    public:
        static const int N = 3e4+1;
        string s;
        int n ;
        int height[N] , sa[N] , rk[N << 1] , oldrk[N << 1] ; 
        SA(string t){
            this->s = " " + t;
            n = t.size() ;
            init();
            get_sa();
            getHeight();
        }
        void init(){
            memset(height,0,sizeof(height));
            memset(sa,0,sizeof(sa));
            memset(rk,0,sizeof(rk));
            memset(oldrk,0,sizeof(oldrk));
        }
        void get_sa(){
            for(int i=1;i<=n;++i) sa[i] = i , rk[i] = s[i] ;
            for(int k=1;k<n;k<<=1){
                sort(sa+1,sa+n+1,[&](int x,int y){
                    return rk[x]==rk[y] ? rk[x+k]<rk[y+k] : rk[x]<rk[y] ;
                });
                memcpy(oldrk,rk,sizeof(rk)); int p = 0;
                for(int i=1;i<=n;++i){
                    if(oldrk[sa[i]]==oldrk[sa[i-1]] && oldrk[sa[i]+k]==oldrk[sa[i-1]+k])
                        rk[sa[i]] = p;
                    else rk[sa[i]] = ++p ;
                }
                if(p == n) break;
            }
        }
        void getHeight(){
            int k = 0; 
            for(int i=1;i<=n;++i){
                if(rk[i] == 1) continue;
                if(k) k--;
                int j = sa[rk[i]-1] ;
                while(i+k <=n && j+k <= n && s[i+k]==s[j+k]) k++;
                height[rk[i]] = k;
            }
        }
    };
    // 这道题可以用后缀数组优化
    string largestMerge(string word1, string word2) {
        string merge=""; int n = word1.size(); 
        SA S(word1+" "+word2) ;  // 一定要加没出现过的字符
        int i=0,j=0;
        while(i<word1.size() || j<word2.size()){
            if(i<word1.size() && S.rk[i+1] > S.rk[j+n+2]) merge += word1[i++];
            else merge += word2[j++];
        }
        return merge;
    }
};

```

## Best Cow Line S (LG P6140)

**题目：[P6140 [USACO07NOV\]Best Cow Line S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P6140)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 2e3+10;
int n ; char s[N]; 
int sa[N] , rk[N << 1] ,oldrk[N << 1] ;
void get_sa(){
    for(int i=1;i<=n;++i) sa[i] = i , rk[i] = s[i] ;
    for(int k=1;k<n;k<<=1){
        sort(sa+1,sa+n+1,[&](int x,int y){
            return rk[x]==rk[y]?rk[x+k]<rk[y+k]:rk[x]<rk[y];
        });
        memcpy(oldrk,rk,sizeof(rk)) ; int p = 0;
        for(int i=1;i<=n;++i){
            if(oldrk[sa[i]]==oldrk[sa[i-1]] && oldrk[sa[i]+k]==oldrk[sa[i-1]+k])
                rk[sa[i]] = p ;
            else rk[sa[i]] = ++p;
        }
        if(p == n) break;
    }
}
int main(){
    cin >> n; for(int i=1;i<=n;++i) cin >> s[i] ;
    s[n+1] = '#' ; int t = 2 * n + 2;
    for(int i=n;i>=1;--i) s[t - i] = s[i] ;
    n = strlen(s+1); get_sa() ; n = (t-2)/2;
    int cnt=0 , i = 1 , j = n+2 ;
    while(i<=n || j<= 2*n+1 ){
        if(cnt && cnt%80==0)  cout << endl ;
        if(cnt == n) break ;
        if(i<=n && rk[i] < rk[j]) cout << s[i++] , cnt++;
        else cout << s[j++] , cnt++ ; 
    }
    system("pause");
}
```

## Milk Patterns G (LG P2852)

**题目：[P2852 [USACO06DEC\]Milk Patterns G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2852)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 4e4 + 10 ;
int sa[N],rk[N << 1],oldrk[N << 1],height[N];
int n , k ; int s[N] ;
void get_sa(){
	for(int i=1;i<=n;++i) sa[i] = i , rk[i] = s[i] ;
	for(int k=1;k<n;k<<=1){
		sort(sa+1,sa+1+n,[&](int x,int y){
			return rk[x]==rk[y]?rk[x+k]<rk[y+k]:rk[x]<rk[y];
		});
		memcpy(oldrk,rk,sizeof(rk)); int p = 0 ;
		for(int i=1;i<=n;++i){
			if(oldrk[sa[i]]==oldrk[sa[i-1]]&&oldrk[sa[i]+k]==oldrk[sa[i-1]+k])
				rk[sa[i]] = p;
			else rk[sa[i]] = ++p ;
		}
		if(p == n) break;
	}
}
void get_height(){
	int k = 0;
	for(int i=1;i<=n;++i) {
		if(rk[i]==1) continue ;
		if(k) k-- ;
		int j = sa[rk[i]-1] ;
		while(i+k <= n && j+k <= n && s[i+k]==s[j+k]) k++;
		height[rk[i]] = k;
	}
}
class MyDeque{
public:
	deque<int> q;
	void pop(int val){
		if(q.front() == val) q.pop_front();
	}	
	void push(int val){
		while(q.size() && q.back() > val) q.pop_back();
		q.push_back(val) ;
	}
	int getMin(){
		return q.front();
	}
};

int main(){
	cin >> n >> k ;
	for(int i=1;i<=n;++i) cin >> s[i] ; 
	get_sa() ; get_height() ;
	MyDeque que; int ans = 0; k -= 1;
	for(int i=1;i<=n;++i){
		if(i<k) que.push(height[i]);
		else{
			que.push(height[i]);
			ans = max(ans,que.getMin()) ;
			que.pop(height[i-k+1]);
		}
	}
	cout << ans << endl ;
	system("pause");
}
```

## 差异（LG P4248）

**题目：[P4248 [AHOI2013\]差异 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4248)**

```c++

```

## 找相同字符（LG P3181）

**题目：[P3181 [HAOI2016\]找相同字符 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3181)**

```c++

```



# 并查集

## 一中校运会之百米跑（LG P2256）

**题目：[P2256 一中校运会之百米跑 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2256)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 20001;
int fa[N],n,m,k;
int find(int x){
	if(x==fa[x]) return x;
	return fa[x] = find(fa[x]);
}
void unionset(int x,int y){
	fa[find(x)] = find(y);
}
int main() {
	cin>>n>>m;
	string t1,t2;
	unordered_map<string,int> mp;
	for(int i=1;i<=n;++i) {
		fa[i] = i;
		cin>>t1;
		mp[t1] = i;
	}
	for(int i=1;i<=m;++i){
		cin>>t1>>t2;
		unionset(mp.find(t1)->second,mp.find(t2)->second);
	}
	cin>>k;
	for(int i=1;i<=k;++i){
		cin>>t1>>t2;
		auto it1 = mp.find(t1);
		auto it2 = mp.find(t2);
		if(it1==mp.end() || it2==mp.end()) cout<<"No."<<endl;
		else if(find(it1->second)==find(it2->second)){
			cout<<"Yes."<<endl;
		} else {
			cout<<"No."<<endl;
		}
	}
	system("pause");
	return 0;
}

```

## 选学霸（LG P2170）

**题目：[P2170 选学霸 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2170)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 20001;
int fa[N],siz[N],n,m,k;
int find(int x){
	if(x==fa[x]) return x;
	return fa[x] = find(fa[x]);
}
void unionset(int x,int y){
	int fx = find(x);
	int fy = find(y);
	if(fx==fy) return;
	fa[fx] = fy;
	siz[fy] += siz[fx];
}

int main() {
	cin>>n>>m>>k;
	if(k==0){
	    cout<<m<<endl;
	    return 0;
	}
	int t1,t2;
	for(int i=1;i<=n;++i) fa[i] = i,siz[i] = 1;
	for(int i=1;i<=k;++i){
		cin>>t1>>t2;
		unionset(t1,t2);
	}
	vector<int> v(1);
	for(int i=1;i<=n;++i){
		if(fa[i]==i){
			v.push_back(siz[i]);
		}
	}
	int dp[2*m+1];
	memset(dp,0,sizeof(dp));
	for(int i=1;i<v.size();++i){
		for(int j=2*m;j>=v[i];--j){
			dp[j] = max(dp[j],dp[j-v[i]]+v[i]);
		}
	}
	if(dp[m] == m){
		cout<<m<<endl;
	} else {
		int ans,min=INT_MAX;
		for(int i=m;i<=2*m;++i){
			if(min > abs(dp[i]-m)) ans=dp[i],min=abs(dp[i]-m);
		}
		cout<<ans<<endl;
	}
	system("pause");
	return 0;
}

```

## 村村通（LG 1536）

**题目：[P1536 村村通 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1536)**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1001;
int n,m;
int fa[N],cnt;
int find(int x){
	if(fa[x]==x) return x;
	return fa[x] = find(fa[x]);
}
void unionset(int x,int y){
	int fx = find(x);
	int fy = find(y);
	if(fx==fy) return;
	fa[fx] = fy;
	cnt--;
}
void init(){
	for(int i=1;i<=n;++i) fa[i] = i;
	cnt=n;
}
int main() {
	while(1){
		cin>>n;
		if(n==0) break;
		init();
		cin>>m;
		int t1,t2;
		for(int i=0;i<m;++i){
			cin>>t1>>t2;
			unionset(t1,t2);
		}
		cout<<cnt-1<<endl;
	}
	
	system("pause");
	return 0;
}

```

## 寻找图中是否存在路径（LC 1971）

**题目：[1971. 寻找图中是否存在路径 - 力扣（LeetCode）](https://leetcode.cn/problems/find-if-path-exists-in-graph/)**

```c++
class Solution {
public:
    class UF{
    public:
        vector<int> fa;
        UF(int n){fa.resize(n,0);for(int i=0;i<n;++i) fa[i] = i;}
        int find(int x){return fa[x]==x?fa[x]:fa[x]=find(fa[x]);}
        void Union(int x,int y){int fx = find(x),fy = find(y);if(fx==fy) return ;fa[fx] = fa[fy];}
        bool connected(int x,int y){return find(x)==find(y);}
    };
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        UF uf(n);
        for(auto elem : edges) uf.Union(elem[0],elem[1]);
        return uf.connected(source,destination);
    }
};
```

## 炸弹人（NC）

**题目：[F-鸡玩炸蛋人_2023牛客寒假算法基础集训营1 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/46800/F)**

```c++
#include <bits/stdc++.h>

using i64 = long long ;

const int N = 1e5+10 , M = 1e6+10 ;

struct DSU{
    std::vector<int> fa , siz ;
    DSU(int n){
        fa.resize(n+1) ; siz.resize(n+1) ;
        for(int i=1;i<=n;++i){
            fa[i] = i ; 
            siz[i] = 1 ;
        }
    }
    int find(int x) {return x==fa[x]?fa[x]:fa[x]=find(fa[x]);}
    void merge(int x,int y){
        int xx = find(x) , yy = find(y) ;
        if(xx == yy) return ;
        fa[xx] = fa[yy] ;
        siz[yy] += siz[xx] ;
    }
    bool connected(int x,int y){return find(x) == find(y);}
} ;

void solve(){  
    int n , m ; 
    std::cin >> n >> m ;
    
    DSU dsu(n) ;
    int u , v ;
    for(int i=1;i<=m;++i) {
        std::cin >> u >> v ; 
        dsu.merge(u,v) ;
    }
    
    int cnt = 0 ;
    std::vector<int> s(n+1) ;
    for(int i=1;i<=n;++i) {
        int c ; 
        std::cin >> c ;
        if(c) {
            if(s[dsu.find(i)] == 0){
                s[dsu.find(i)] = 1 ;
                cnt ++ ;
            }
        }
    }
    
    if(cnt > 1) {
        std::cout << 0 << std::endl ;
        return ;
    }
    i64 ans = 0 ;
    if(cnt == 1){
        for(int i=1;i<=n;++i) {
            if(i == dsu.fa[i] && s[i]) {
                ans += 1LL * dsu.siz[i] * dsu.siz[i] ;
            }
        }
    } else {
        for(int i=1;i<=n;++i) {
            if(i == dsu.fa[i]) {
                ans += 1LL * dsu.siz[i] * dsu.siz[i] ;
            }
        }
    }
    
    std::cout << ans << std::endl ;
}

int main(){
    std::ios::sync_with_stdio(false) ;
    std::cin.tie(nullptr) ;
    
    solve() ;
    
    return 0 ;
}

```

## 红色警报（PTA L2-013）

**题目：[题目详情 - L2-013 红色警报 (pintia.cn)](https://pintia.cn/problem-sets/994805046380707840/exam/problems/994805063963230208)**

**思路：并查集的逆用**

```c++
#include <bits/stdc++.h>
using namespace std ;
using ll = long long ;

int find(int x,vector<int>& fa){return fa[x]==x?x:fa[x]=find(fa[x],fa);}
void solve(){
	int n , m ;  cin >> n >> m ;

	vector<int> e[n] ; 
	for(int i=1;i<=m;++i) {
		int u , v ; cin >> u >> v ;
		e[u].push_back(v) ; e[v].push_back(u) ;
	}

	vector<int> fa(n) ; fill(begin(fa),end(fa),-1) ; int count = 0 ; // 并查集

	int k ; cin >> k ; vector<int> a(k) ;  // 记录破坏的城市
	for(int i=0;i<k;++i) cin >> a[i] ;

	vector<int> vis(n) , ans(k);  // 记录答案
	if(k != n){  // 特判没有全部攻占的情况
		vector<int> meet(n) ;
		for(int i=0;i<k;++i) meet[a[i]] = 1 ;
		for(int i=0;i<n;++i) if(!meet[i]) {

			fa[i] = i ; vis[i] = 1 ; count ++ ;
			int xx = find(fa[i] , fa) ;
			
			for(int j=0;j<e[i].size();++j) if(vis[e[i][j]]){
				int v = e[i][j] ;
				int yy = find(fa[v] , fa) ;
				if(xx == yy) continue ;
				fa[yy] = xx ; count -- ;
			}
		}
	}
	for(int i=k-1;i>=0;--i){  // 倒序

		fa[a[i]] = a[i] ; vis[a[i]] = 1 ; count ++ ;
		int xx = find(fa[a[i]] , fa) ; int t = count - 1 ;
		
		for(int j=0;j<e[a[i]].size();++j){
			int v = e[a[i]][j] ;
			if(vis[v]){
				int yy = find(fa[v] , fa) ;
				if(xx == yy) continue ;
				fa[yy] = xx ; count -- ;
			}
		}

		if(count < t) ans[i] = 1 ;  // 如果连通块减少了就说明是答案

	}

	for(int i=0;i<k;++i) {
		if(ans[i]){
			cout << "Red Alert: City " << a[i] << " is lost!" << endl ;
		}else {
			cout << "City " << a[i] << " is lost." << endl ;
		}
	}
	if(k == n) cout << "Game Over." << endl ;

}

int main(){
	ios::sync_with_stdio(false) ; cin.tie(nullptr) ; cout.tie(nullptr) ;

	int t = 1 ; //cin >> t ;

	while(t --) solve() ;

	return 0 ;
}
```

## [矩阵转换后的秩](https://leetcode.cn/problems/rank-transform-of-a-matrix/)

```c++
#include <bits/stdc++.h>
#define debug cout << "__LINE__ : " << __LINE__ - 9 << endl ;
using namespace std ;
#define num(x,y) (x*m+y)
#define X(x) (x / m)
#define Y(x) (x % m) 

using ll = long long ;
class Solution {
public:
    int find(int x,vector<int>& fa){return x==fa[x]?x:fa[x]=find(fa[x],fa);}
    vector<vector<int>> matrixRankTransform(vector<vector<int>>& matrix) {
        int n = matrix.size() , m = matrix[0].size() ; 


        vector<int> fa(n*m) ; iota(fa.begin(),fa.end(),0) ;
        for (int i = 0; i < n; ++i) {
            map<int, vector<int>> mp;
            for (int j = 0; j < m; ++j)
                mp[matrix[i][j]].push_back(i * m + j);
            for (auto &[num, vec] : mp) {
                for (int k = 0; k + 1 < vec.size(); ++k)
                    fa[find(vec[k],fa)] =  find(vec[k + 1],fa);
            }
        }
        for (int j = 0; j < m; ++j) {
            map<int, vector<int>> mp;
            for (int i = 0; i < n; ++i)
                mp[matrix[i][j]].emplace_back(i * m + j);
            for (auto &[num, vec] : mp) {
                for (int k = 0; k + 1 < vec.size(); ++k)
                    fa[find(vec[k],fa)] =  find(vec[k + 1],fa);
            }
        }


        vector<int> idx(m) , idy(n) ; vector<int> e[n * m] , indegree(n * m) ;
        for(int i=0;i<n;++i) {
            iota(idx.begin(),idx.end(),0) ;
            sort(idx.begin(),idx.end(),[&](int x,int y){
                return matrix[i][x] < matrix[i][y] ;
            }) ;   
            for(int j=0;j+1<m;++j){
                if(matrix[i][idx[j]] == matrix[i][idx[j+1]]) continue ;
                int now = find(num(i,idx[j+1]),fa) ;
                int pre = find(num(i,idx[j]),fa) ; 
                e[pre].push_back(now) ;
                indegree[now] ++ ; pre = now ;
            }
        }
        for(int j=0;j<m;++j) {
            iota(idy.begin(),idy.end(),0) ;
            sort(idy.begin(),idy.end(),[&](int x,int y){
                return matrix[x][j] < matrix[y][j] ;
            }) ; 
            for(int i=0;i+1<n;++i){
                if(matrix[idy[i]][j] == matrix[idy[i+1]][j]) continue ;
                int now = find(num(idy[i+1],j),fa) ;
                int pre = find(num(idy[i],j),fa) ;
                e[pre].push_back(now) ;
                indegree[now] ++ ; pre = now ;
            }
        }
        

        vector<vector<int>> ans(n , vector<int>(m)) ;
        queue<int> q ; int id = 1 ;
        for(int i=0;i<n*m;++i) if(indegree[i] == 0 && fa[i] == i) {
            q.push(i) ; ans[X(i)][Y(i)] = id ; 
        } 
        while(q.size()){
            int siz = q.size() ; ++ id ;
            for(int i=0;i<siz;++i) {
                int u = q.front() ; q.pop() ;
                for(int j=0;j<e[u].size();++j){
                    int v = e[u][j] ;
                    if( -- indegree[v] == 0) q.push(v) , ans[X(v)][Y(v)] = id ;
                }
            }
        }


        for(int i=0;i<n*m;++i) if(fa[i] != i) {
            ans[X(i)][Y(i)] = ans[X(find(i,fa))][Y(find(i,fa))] ;
        } 


        return ans ;
    }
};
```

## 【典】函数维护

**题目：[P4145 上帝造题的七分钟 2 / 花神游历各国 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4145)**

```c++
#include <bits/stdc++.h>
#define int long long
#define debug cout << "__LINE__" << __LINE__ << endl ;
using namespace std ;  
const int N = 1e5 + 2 ;

int fa[N] , a[N] , c[N] ; int n , m ;
int find(int x){return x==fa[x]?fa[x]:fa[x]=find(fa[x]);}
void add(int x,int v){while(x<=n) c[x] += v , x += x&-x ;}
int ask(int x){int r=0;while(x>=1) r += c[x] , x -= x&-x ; return r ;}

void solve(){
	cin >> n ;
	for(int i = 1 ; i <= n ; ++ i)
	{
		cin >> a[i] ; add(i,a[i]) ;
		fa[i] = i ; 
	}
	fa[n + 1] = n + 1 ;

	cin >> m ; 
	while(m -- )
	{
		int k , l , r ; cin >> k >> l >> r ;
		if(l > r) swap(l , r) ;
		if(k == 1) 
		{
			cout << ask(r) - ask(l-1) << endl ; continue ;
		}
		else
		{
			while(l <= r)
			{
				int tp = sqrt(a[l]) ;
				add(l , tp - a[l]) ; a[l] = tp ;
				if(a[l] <= 1) fa[l] = l + 1 ;
				if(fa[l] == l) ++ l ;
				else l = find(fa[l]) ;
			}
		}
	}

}

signed main(){
	ios::sync_with_stdio(false) ; 
	cin.tie(nullptr) ; cout.tie(nullptr) ;
	int t = 1 ; // cin >> t ;
	while( t -- ) solve() ;
	return 0 ;
}
```

​	
