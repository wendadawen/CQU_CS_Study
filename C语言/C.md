# 系统命令system

**头文件<stdlib.h>**

**system()可以放系统命令：**执行成功返回0，失败返回0。

```c++
system("cls");
system("pause");
system("G:\\文红兵的快乐学习");  // 注意用"\\"或者"/"
```



# GCC

**执行程序：**`gcc -o hello.exe hello.c`

**gcc与g++:** gcc 能够编译c/c++/java等等，能够自动区别c和cpp

​					g++统一按照cpp文件编译，会自动链接STL库，gcc需要手动

# 分步编译

- 预处理

  `gcc -E hello.c -o hello.i`

  （1）宏定义展开

  （2）头文件展开

  （3）条件编译

  （4）去掉注释

- 编译

  `gcc -S hello.i -o hello.s`

  （1）检查语法

  （2）将C语言转成汇编语言

- 汇编

  `gcc -c hello.s -o hello.o`

  将汇编语言转成机器语言（二进制码）

- 链接

  `gcc hello.o -o hello.exe`

  将C语言依赖库链接到程序中

# #define

`#define PI 3.1415926`

简单的替换操作

# typedef

**数据类型取别名，和#define不一样，这个不是简单的替换**

- `typedef unsigned int ui;  `  给内置的数据类型取别名
- `typedef struct student ss;  定义结构体`
- `typedef struct {} student,*student_p;`  定义结构体
- `typedef int(*fp)(int,int)`  定义函数指针

# printf与scanf

**包含头文件：<stdio.h>**

## printf

`%[flags][width][ .precision ][length]specifier，即：%[标志][最小宽度][.精度][类型长度]说明符`

```c++
printf("%d",a);
printf("%.2f",a);
printf("%3.2f",a);
printf("%-3.2f",a);

```

### 标志位

| **flags（标志）** | 字符名称 | 描述                                                         |
| ----------------- | -------- | ------------------------------------------------------------ |
| -                 | 减号     | 在给定的字段宽度内左对齐，右边填充空格（默认右对齐）         |
| +                 | 加号     | 强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号；默认情况下，只有负数前面会显示一个 - 号 |
| （空格）          | 空格     | 输出值为正时加上空格，为负时加上负号 [3]                     |
| #                 | 井号     | specifier 是 o、x、X 时，增加前缀 0、0x、0X；specifier 是 e、E、f、g、G 时，一定使用小数点；specifier 是 g、G 时，尾部的 0 保留 |
| 0                 | 数字零   | 对于所有的数字格式，使用前导零填充字段宽度（如果出现了减号标志或者指定了精度，则忽略该标志） |

### **说明符（specifier）**

| 说明符（specifier） | 对应数据类型 | 描述                                                         |
| ------------------- | ------------ | ------------------------------------------------------------ |
| d / i               | int          | 输出类型为有符号的十进制整数，i 是老式写法                   |
| o                   | unsigned int | 输出类型为无符号八进制整数（没有前导 0）                     |
| u                   | unsigned int | 输出类型为无符号十进制整数                                   |
| x / X               | unsigned int | 输出类型为无符号十六进制整数，x 对应的是 abcdef，X 对应的是 ABCDEF（没有前导 0x 或者 0X） |
| f / lf              | double       | 输出类型为十进制表示的浮点数，默认精度为6（lf 在 C99 开始加入标准，意思和 f 相同） |
| e / E               | double       | 输出类型为科学计数法表示的数，此处 "e" 的大小写代表在输出时用的 “e” 的大小写，默认浮点数精度为6 |
| g                   | double       | 根据数值不同自动选择 %f 或 %e，%e 格式在指数小于-4或指数大于等于精度时用使用 [1] |
| G                   | double       | 根据数值不同自动选择 %f 或 %E，%E 格式在指数小于-4或指数大于等于精度时用使用 |
| c                   | char         | 输出类型为字符型。可以把输入的数字按照ASCII码相应转换为对应的字符 |
| s                   | char *       | 输出类型为字符串。输出字符串中的字符直至遇到字符串中的空字符（字符串以 '\0‘ 结尾，这个 '\0' 即空字符）或者已打印了由精度指定的字符数 |
| p                   | void *       | 以16进制形式输出指针                                         |
| %                   | 不转换参数   | 不进行转换，输出字符‘%’（百分号）本身                        |
| n                   | int *        | 到此字符之前为止，一共输出的字符个数，不输出文本 [4]         |



### 最小宽度（width）

| **width（最小宽度）** | 字符名称 | 描述                                                         |
| --------------------- | -------- | ------------------------------------------------------------ |
| digit(n)              | 数字     | 字段宽度的最小值，如果输出的字段长度小于该数，结果会用前导空格填充；如果输出的字段长度大于该数，结果使用更宽的字段，不会截断输出 [3] |
| *                     | 星号     | 宽度在 format 字符串中规定位置未指定，使用星号标识附加参数，指示下一个参数是width [5] |



### 精度（.precision）

| **.precision（精度）** | 字符名称 | 描述                                                         |
| ---------------------- | -------- | ------------------------------------------------------------ |
| .digit(n)              | 点+数字  | 对于整数说明符（d、i、o、u、x、X）：precision 指定了要打印的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符；对于 e、E 和 f 说明符：要在小数点后输出的小数位数；对于 g 和 G 说明符：要输出的最大有效位数；对于 s 说明符：要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符；对于 c 说明符：没有任何影响；当未指定任何精度时，默认为 1。如果指定时只使用点而不带有一个显式值，则标识其后跟随一个 0。 [3] |
| .*                     | 点+星号  | 精度在 format 字符串中规定位置未指定，使用点+星号标识附加参数，指示下一个参数是精度 [5] |



### 类型长度（length） 

| **length（类型长度）** | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| h                      | 参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X） [3] |
| l                      | 参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串） [3] |



## scanf

`scanf("%d%d%s",&a,&b,s)`

| 格式控制符   | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| %c           | 读取一个单一的字符                                           |
| %hd、%d、%ld | 读取一个十进制整数，并分别赋值给 short、int、long 类型       |
| %ho、%o、%lo | 读取一个八进制整数（可带前缀也可不带），并分别赋值给 short、int、long 类型 |
| %hx、%x、%lx | 读取一个十六进制整数（可带前缀也可不带），并分别赋值给 short、int、long 类型 |
| %hu、%u、%lu | 读取一个无符号整数，并分别赋值给 unsigned short、unsigned int、unsigned long 类型 |
| %f、%lf      | 读取一个十进制形式的小数，并分别赋值给 float、double 类型    |
| %e、%le      | 读取一个指数形式的小数，并分别赋值给 float、double 类型      |
| %g、%lg      | 既可以读取一个十进制形式的小数，也可以读取一个指数形式的小数，并分别赋值给 float、double 类型 |
| %s           | 读取一个字符串（以空白符为结束）                             |

（1）%s 表示读字符串，而 %d 表示读整数。格式串的处理顺序为从左到右，格式说明符逐一与变元表中的变元匹配。为了读取长整数，可以将 L / l 放在格式说明符的前面；为了读取短整数，可以将 h 放在格式说明符的前面。这些修饰符可以与 d、i、o、u 和 x 格式代码一起使用。

（2）默认情况下，a、f、e 和 g 告诉 scanf() 为 float 分配数据。 如果将 L / l放在这些修饰符的前面，则 scanf() 为 double 分配数据。使用 L 就是告诉 scanf()，接收数据的变量是 long double 型变量。

（3）如果使用的现代编译器程序支持 1995 年增加的宽字符特性， 则可以与 c 格式代码一起，用 l 修饰符说明类型 wchar_t 的宽字符指针；也可以与 s 格式代码一起，用 l 修饰符说明宽字符串的指针。l 修饰符也可以用于修饰扫描集，以说明宽字符。

（4）控制串中的空白符使 scanf() 在输入流中跳过一个或多个空白行。空白符可以是空格(space)、制表符(tab)和新行符(newline)。 本质上，控制串中的空白符使 scanf() 在输入流中读，但不保存结果，直到发现非空白字符为止。

（5）非空白符使 scanf() 在流中读一个匹配的字符并忽略之。例如，"%d,%d" 使 scanf() 先读入一个整数，读入中放弃逗号，然后读另一个整数。如未发现匹配，scanf() 返回。

（6）scanf() 中用于保存读入值的变元必须都是变量指针，即相应变量的地址。

（7）在输入流中，数据项必须由空格、制表符和新行符分割。逗号和分号等不是分隔符，比如以下代码：

```
scanf("%d%d",&r,&c);
```

将接受输入 10 20，但遇到 10,20 则失败。

（8）百分号(%)与格式符之间的星号(*)表示读指定类型的数据但不保存。因此，

```
scanf("%d%*c%d",&x,&y);
```

对 10/20 的读入操作中，10 放入变量 x，20 放入 y。

（9）格式命令可以说明最大域宽。 在百分号(%)与格式码之间的整数用于限制从对应域读入的最大字符数。例如，希望向 address 读入不多于 20 个字符时，可以书写成如下形式：

```
scanf("%20s",address);
```

如果输入流的内容多于 20 个字符，则下次 scanf() 从此次停止处开始读入。 若达到最大域宽前已遇到空白符，则对该域的读立即停止；此时，scanf() 跳到下一个域。

（10）虽然空格、制表符和新行符都用做域分割符号，但读单字符操作中却按一般字符处理。例如，对输入流 "x y" 调用：

```
scanf("%c%c%c",&a,&b,&c);
```

返回后，x 在变量 a 中，空格在变量 b 中，y 在变量 c 中。

注意，控制串中的其它字符，包括空格、制表符和新行符，都用于从输入流中匹配并放弃字符，被匹配的字符都放弃。例如，给定输入流 "10t20"，调用：

```
scanf("%dt%d",&x,&y);
```

将把 10 和 20 分别放到 x 和 y 中，t 被放弃，因为 t 在控制串中。

（11）ANSI C 标准向 scanf() 增加了一种新特性，称为扫描集(scanset)。 扫描集定义一个字符集合，可由 scanf() 读入其中允许的字符并赋给对应字符数组。 扫描集合由一对方括号中的一串字符定义，左方括号前必须缀以百分号。 例如，以下的扫描集使 scanf() 读入字符 A、B 和 C：

```
%[ABC]
```

使用扫描集时，scanf() 连续吃进集合中的字符并放入对应的字符数组，直到发现不在集合中的字符为止(即扫描集仅读匹配的字符)。返回时，数组中放置以 null 结尾、由读入字符组成的字符串。

用字符 ^ 可以说明补集。把 ^ 字符放为扫描集的第一字符时，构成其它字符组成的命令的补集合，指示 scanf() 只接受未说明的其它字符。

对于许多实现来说，用连字符可以说明一个范围（ISO C99标准没有规定）。例如，以下扫描集使 scanf() 接受字母 A 到 Z：

```
%[A-Z]
```

重要的是要注意扫描集是区分大小写的。因此，希望扫描大、小写字符时，应该分别说明大、小写字母。

（12） scanf() 返回等于成功赋值的域数的值，但由于星号修饰符而读入未赋值的域不计算在内。遇到文件结束则返回EOF；若出错则返回0。



# 字符数组与字符串

**包含头文件：<string.h>**

**strcpy：**`strcpy(char* s,"wenwenwen");`

**strlen：**`strlen(char* s);`

字符串中最后一位是：'\0'，表示结束符号。

字符数组没有该限制，因此字符串是特殊的字符数组

**字符串的输入：**

**字符串的输出：**



# 二进制表示方式

**原码：**正（负）数不变

**反码：**正数不变，负数符号位不变，其余取反

**补码：**正数不变，负数在反码基础上加1

**补码相加：**符号位参与运算，若最高位有进位，则进位被舍弃

# 静态变量

**特点：静态变量只会初始化一次。**

**生命周期：和程序相同。**

**作用域：和普通变量一样，且只能在本文件使用**

# 内在开辟与释放

**开辟：**`int* p = (int*)malloc(sizeof(int)*100);`

​			`malloc(字节大小)，返回void*`

​           开辟成功：返回地址。

​		   开辟失败：返回空指针。

**释放：**`free(p)`

# 内存操作函数

**包含头文件：<string.h>**

- **memset**

  `memset(void* s,int c,int n)`

  将 s 的内存空间的前 n 个字节以 c 填入，一个字节8个byte

- **memcpy**

  `memcpy(void* dest,void* src,int n)`

  将 src 的内存空间的前 n 个字节填入 dest ，一个字节8个byte,内存重叠可能报错误

- **memmove**

  `memmove(void* dest,void* src,int n)`

  将 src 的内存空间的前 n 个字节填入 dest ，一个字节8个byte,内存重叠不会报错误

- **memcmp**

  `memcmp(void* s1,void* s2,int n)`

  比较 s1 和 s2 的前n个字节，

  相等返回 0

  大于返回1

  小于返回-1